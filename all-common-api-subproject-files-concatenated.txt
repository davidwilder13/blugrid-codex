===== ./common/common-kotlin/common-api/common-api-domain/src/main/kotlin/net/blugrid/common/domain/IdentityID.kt =====
package net.blugrid.common.domain

@JvmInline
value class IdentityID(val value: Long)

===== ./common/common-kotlin/common-api/common-api-domain/src/main/kotlin/net/blugrid/common/domain/IdentityUUID.kt =====
package net.blugrid.common.domain

import java.util.UUID

@JvmInline
value class IdentityUUID(val value: UUID)

===== ./common/common-kotlin/common-api/common-api-domain/src/main/kotlin/net/blugrid/common/domain/CreatedTimestamp.kt =====
package net.blugrid.common.domain

import java.time.Instant

@JvmInline
value class CreatedTimestamp(val value: Instant)

===== ./common/common-kotlin/common-api/common-api-domain/src/main/kotlin/net/blugrid/common/domain/EffectiveTimestamp.kt =====
package net.blugrid.common.domain

import java.time.Instant

@JvmInline
value class EffectiveTimestamp(val value: Instant)

===== ./common/common-kotlin/common-api/common-api-domain/src/main/kotlin/net/blugrid/common/domain/LastChangedTimestamp.kt =====
package net.blugrid.common.domain

import java.time.Instant

@JvmInline
value class LastChangedTimestamp(val value: Instant)

===== ./common/common-kotlin/common-api/common-api-domain/build.gradle.kts =====
plugins {
    alias(libs.plugins.jvm)
}

version = "0.1"
group = "net.blugrid.api"

repositories {
    mavenCentral()
}

dependencies {
    implementation("jakarta.validation:jakarta.validation-api:3.0.2")
}

java {
    sourceCompatibility = JavaVersion.toVersion("17")
}

kotlin {
    jvmToolchain {
        languageVersion.set(JavaLanguageVersion.of(17))
    }
}

===== ./common/common-kotlin/common-api/common-api-domain/gradle.properties =====
micronautVersion=4.4.3
kotlinVersion=1.9.23

===== ./common/common-kotlin/common-api/common-api-domain/README.md =====
# common-api-domain

This module defines **Blugrid's canonical domain primitives** for use across all Kotlin-based modules and code generation targets.

It provides strongly typed value classes to enforce correctness and consistency for commonly used concepts like IDs and timestamps. These types are used in generated APIs, database entities, and GraphQL/gRPC contracts.

## üì¶ Provided Domain Types

| Type                  | Description                                                   |
|-----------------------|---------------------------------------------------------------|
| `IdentityID`          | A strongly typed wrapper for `Long` IDs                       |
| `IdentityUUID`        | A UUID-based identity type for external references            |
| `CreatedTimestamp`    | The time a resource was created (read-only field)             |
| `LastChangedTimestamp`| The last time a resource was modified (read-only field)       |
| `EffectiveTimestamp`  | The datetime when a resource becomes active or takes effect   |

These types are implemented as Kotlin [inline value classes](https://kotlinlang.org/docs/value-classes.html) for zero-cost abstraction and strong typing.

## üîç Usage

```kotlin
data class Organisation(
    val id: IdentityID,
    val uuid: IdentityUUID,
    val created: CreatedTimestamp,
    val effectiveTimestamp: EffectiveTimestamp
)

===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/util/Either.kt =====
package net.blugrid.api.util

sealed class Either<out L, out R> {

    data class Left<out L, out R>(val a: L) : Either<L, R>()

    data class Right<out L, out R>(val b: R) : Either<L, R>()

}

fun <E> E.left() = Either.Left<E, Nothing>(this)

fun <T> T.right() = Either.Right<Nothing, T>(this)
===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/util/SwaggerContants.kt =====
package net.blugrid.api.util

object SwaggerConstants {

    // Generic Actions
    const val CREATE = "Create"
    const val UPDATE = "Update"
    const val GET = "Get"
    const val DELETE = "Delete"
    const val FETCH = "Fetch"
    const val SUCCESSFULLY = "successfully"
}

===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/util/CommonExtensions.kt =====
package net.blugrid.api.util

import kotlin.reflect.KClass
import kotlin.reflect.full.memberProperties

inline fun <reified R : Any> R.toMap() = objectToMap(this)

val emptyLinesRegex = Regex("\n\\s*\n")

fun String.removeEmptyLines(): String = this.replace(emptyLinesRegex, "")

fun String?.toWords(): List<String>? = this
    ?.trim()
    ?.splitToSequence(' ')
    ?.filter { it.isNotBlank() }
    ?.toList()

fun String?.toSearchTerms(): String? = this?.let {
    toWords()
        ?.joinToString(" ") {
            it.filter {
                !it.isWhitespace()
            }
        }
}

fun List<String?>.toSearchTerms(): String =
    filter { !it.isNullOrBlank() }
        .map { it.toSearchTerms() }
        .joinToString(" ")

@Suppress("UNCHECKED_CAST")
fun <T : Any> objectToMap(obj: T): Map<String, Any?> {
    return (obj::class as KClass<T>).memberProperties.associate { prop ->
        prop.name to prop.get(obj)
            ?.let { value ->
                if (value::class.isData) {
                    objectToMap(value)
                } else {
                    value
                }
            }
    }
}

@Suppress("UNCHECKED_CAST")
fun Map<String, Any?>.flatten(): Map<String, Any?> {
    // Flatten a nested JSON file

    // Keep iterating until the termination condition is satisfied
    var currentDictionary = this
    while (true) {
        // Keep unpacking the JSON file until all values are atomic elements (not dictionary or list)
        val flattenedDictionary = currentDictionary
            .filterNotNullValues()
            .flatMap { (key, value) -> unpack(key, value) }
            .toMap()
        // Terminate condition: not any value in the JSON file is dictionary or list
        if (!flattenedDictionary.any { it.value is Map<*, *> } && !flattenedDictionary.any { it.value is List<*> }) {
            return flattenedDictionary
        }
        currentDictionary = flattenedDictionary as Map<String, Any>
    }
}

@Suppress("UNCHECKED_CAST")
fun <K, V> Map<K, V?>.filterNotNullValues(): Map<K, V> =
    filterValues { it != null } as Map<K, V>

fun unpack(parentKey: String, parentValue: Any): Sequence<Pair<String, Any>> {
    // Unpack one level of nesting in the JSON file
    // Unpack one level only!!!

    return when (parentValue) {
        is Map<*, *> -> parentValue.entries.asSequence().flatMap { (key, value) ->
            val temp1 = "$parentKey${if (parentKey.isNotEmpty()) "_" else ""}$key"
            unpack(temp1, value!!)
        }

        is List<*> -> parentValue.asSequence().withIndex().flatMap { (index, value) ->
            val temp2 = "$parentKey${if (parentKey.isNotEmpty()) "_" else ""}$index"
            unpack(temp2, value!!)
        }

        else -> sequenceOf(parentKey to parentValue)
    }
}

===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/util/EntityExtensions.kt =====
package net.blugrid.api.util

import java.util.Objects
import kotlin.reflect.KMutableProperty
import kotlin.reflect.KProperty1
import kotlin.reflect.KVisibility

interface SupportsMixedTypeEquality {

    /**
     * Returns true if this object can be compared for equality with the other object.
     *
     * The typical implementation is to check if other is an instance of this class. This method should always be
     * overridden in subclasses, unless they are trivially different (no new fields).
     */
    fun canEqual(other: Any?): Boolean
}

/**
 * Extension functions for Any.
 *
 * @author James Bassett (james.bassett@console.com.au)
 */

/**
 * Checks the other object for equality with this one, based on the supplied properties.
 *
 * @param other the other object to test for equality with this object
 * @param properties the list of properties to use when calculating equality
 * @param superEquals lambda for calling super.equals() if required (if used, all classes involved should implement the [SupportsMixedTypeEquality] interface)
 * @param T the type of the receiving class
 */
inline fun <reified T : Any> T.kotlinEquals(
    other: Any?,
    properties: Array<out KProperty1<T, Any?>>,
    noinline superEquals: (() -> Boolean)? = null,
): Boolean {
    return when {
        other === this -> true
        other !is T -> false
        other is SupportsMixedTypeEquality && !other.canEqual(this) -> false
        superEquals != null && !superEquals() -> false
        else -> properties.all {
            val property = it.get(this)
            val otherProperty = it.get(other)
            if (property is Array<*>) {
                Objects.deepEquals(property, otherProperty)
            } else {
                Objects.equals(property, otherProperty)
            }
        }
    }
}


inline fun <reified T : Any> T.kotlinUpdate(
    update: T,
    propertiesToUpdate: Array<out KProperty1<T, Any?>>
): T {
    propertiesToUpdate.forEach { property ->
        val updatedValue = property.get(update)

        if (property.visibility == KVisibility.PUBLIC && property is KMutableProperty<*>) {
            property.setter.call(this, updatedValue)
        }
    }
    return this
}

/**
 * Generates the hash of an object, based on the supplied properties.
 *
 * @param properties the list of properties to include
 * @param superHashCode lambda for calling super.hashCode() if required
 * @param T the type of the receiving class
 */
inline fun <reified T : Any> T.kotlinHashCode(properties: Array<out KProperty1<T, Any?>>, noinline superHashCode: (() -> Int)? = null): Int {
    val values = Array(properties.size) { i ->
        val property = properties[i].get(this)
        if (property is Array<*>) {
            property.contentDeepHashCode()
        } else {
            property
        }
    }

    return if (superHashCode != null) {
        Objects.hash(*values, superHashCode())
    } else {
        Objects.hash(*values)
    }
}

/**
 * Generates the String representation of an object, based on the supplied properties.
 *
 * The implementation is based on the implementation provided by Guava's ToStringHelper (https://github.com/google/guava/wiki/CommonObjectUtilitiesExplained).
 *
 * @param properties the list of properties to include
 * @param omitNulls whether to exclude null values
 * @param superToString lambda for calling super.toString() if required
 * @param T the type of the receiving class
 */
inline fun <reified T : Any> T.kotlinToString(
    properties: Array<out KProperty1<T, Any?>>,
    omitNulls: Boolean = false,
    noinline superToString: (() -> String)? = null,
): String {
    val builder = StringBuilder(32).append(T::class.java.simpleName).append("(")
    var nextSeparator = ""

    properties.forEach {
        val property = it.name
        val value = it.get(this)
        if (!omitNulls || value != null) {
            with(builder) {
                append(nextSeparator)
                nextSeparator = ", "
                append(property)
                append("=")
                if (value is Array<*>) {
                    val arrayString = arrayOf(value).contentDeepToString()
                    append(arrayString, 1, arrayString.length - 1)
                } else {
                    append(value)
                }
            }
        }
    }

    if (superToString != null) {
        with(builder) {
            append(nextSeparator)
            append("super=")
            append(superToString())
        }
    }

    return builder.append(")").toString()
}

===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/common/model/audit/AuditEvent.kt =====
package net.blugrid.api.common.model.audit

import com.fasterxml.jackson.annotation.JsonProperty
import io.micronaut.context.event.ApplicationEvent
import net.blugrid.api.common.model.resource.GenericAuditedResource
import net.blugrid.api.common.model.resource.ResourceType
import java.time.LocalDateTime

class AuditEvent(
    val auditEventType: AuditEventType,
    val auditEventTimestamp: LocalDateTime,
    val resourceType: ResourceType,
    val resourceId: Long,
    val resource: GenericAuditedResource<*>,
    val tenantId: Long,
    val sessionId: Long,
    val version: Int? = null
) : ApplicationEvent(resource)

enum class AuditEventType {
    @JsonProperty("CREATE")
    CREATE,

    @JsonProperty("UPDATE")
    UPDATE,

    @JsonProperty("DELETE")
    DELETE
}


===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/common/model/audit/AuditStamp.kt =====
package net.blugrid.api.common.model.audit

import io.swagger.v3.oas.annotations.media.Schema
import java.time.LocalDateTime

@Schema(description = "Stamp of a user session and time of action.")
data class AuditStamp(
    val sessionId: Long?,
    val session: Any?,
    val timestamp: LocalDateTime?
)

===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/common/model/audit/AuditEventLog.kt =====
package net.blugrid.api.common.model.audit

import net.blugrid.api.common.model.resource.ResourceType
import java.time.LocalDateTime

class AuditEventLog(
    val auditEventType: AuditEventType,
    val auditEventTimestamp: LocalDateTime,
    val resourceType: ResourceType,
    val resourceId: Long,
    val resource: Any,
    val tenantId: Long,
    val sessionId: Long,
    val version: Int? = 0
)

===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/common/model/audit/ResourceAudit.kt =====
package net.blugrid.api.common.model.audit

import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Audit metadata tracking resource creation and modification.")
data class ResourceAudit(
    @Schema(description = "Optimistic locking version.", example = "1")
    val version: Int = 0,

    @Schema(description = "Who and when the resource was created.")
    val created: AuditStamp? = null,

    @Schema(description = "Who and when the resource was last changed.")
    val lastChanged: AuditStamp? = null
)

===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/common/model/scope/TenantScope.kt =====
package net.blugrid.api.common.model.scope

import io.swagger.v3.oas.annotations.media.Schema


@Schema(description = "Represents the base Scopes associated with a tenant in a multi-tenant environment.")
open class TenantScope(
    @Schema(description = "The unique identifier of the tenant.", example = "1001")
    open var tenantId: Long? = null,
) {
    @Schema(description = "Indicates whether the resource is external to the tenant.", example = "false")
    var isExternalResource: Boolean? = null
}

===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/common/model/scope/BusinessUnitScope.kt =====
package net.blugrid.api.common.model.scope

import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Represents the Scopes associated with a business unit within a tenant.")
class BusinessUnitScope(
    @Schema(description = "The unique identifier of the tenant.", example = "1001")
    override var tenantId: Long? = null,

    @Schema(description = "The unique identifier of the business unit within the tenant.", example = "2001")
    var businessUnitId: Long? = null,
) : TenantScope(tenantId)

===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/common/query/SortField.kt =====
package net.blugrid.api.common.query

import io.micronaut.data.model.Sort
import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Represents a field by which results can be sorted, including the direction of the sort.")
class SortField(
    @Schema(description = "The name of the field by which to sort the results.", example = "name")
    val field: String,

    @Schema(description = "The direction of the sort, either ascending or descending.", example = "ASC")
    val direction: Sort.Order.Direction = Sort.Order.Direction.ASC
)

===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/common/query/PageMapping.kt =====
package net.blugrid.api.common.query

import io.micronaut.data.model.Pageable
import io.micronaut.data.model.Sort


fun <T> Pageable.toPageableQuery(query: T): PageableQuery<T> {
    val pageRequest = this
    return PageableQuery(
        number = pageRequest.number,
        size = pageRequest.size,
        sort = pageRequest.sort.toSortFields().takeIf { it.isNotEmpty() },
        query = query
    )
}

fun PageableQuery<*>.toPageable(): Pageable {
    val sortOrUnsorted = sort
        ?.let {
            Sort.of(it.map { it.toSortOrder() })
        }
        ?: Sort.unsorted()

    return DefaultPageRequest(number, size, sortOrUnsorted)
}

private fun SortField.toSortOrder(): Sort.Order {
    return Sort.Order(field, direction, true)
}

fun Sort.toSortFields(): List<SortField> = this.orderBy.map { SortField(field = it.property, direction = it.direction) }.toList()

===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/common/query/PageableQuery.kt =====
package net.blugrid.api.common.query

import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Represents a pageable query with customizable pagination and sorting options.")
open class PageableQuery<T>(
    @Schema(description = "The query object containing the criteria for the search or filtering.", example = "SomeQueryObject")
    open val query: T,

    @Schema(description = "The page number to retrieve, starting from 0.", example = "0")
    open val number: Int = DEFAULT_NUMBER,

    @Schema(description = "The number of records to retrieve per page.", example = "50")
    open val size: Int = DEFAULT_SIZE,

    @Schema(description = "The sorting criteria to apply to the query results.", example = "[{\"field\": \"name\", \"direction\": \"ASC\"}]")
    open val sort: List<SortField>? = null,
) {
    companion object {
        const val DEFAULT_NUMBER = 0
        const val DEFAULT_SIZE = 50
    }
}

===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/common/query/SortableQuery.kt =====
package net.blugrid.api.common.query

import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Represents a query with optional sorting criteria.")
class SortableQuery<T>(
    @Schema(description = "The query object containing the criteria for the search or filtering.", example = "SomeQueryObject")
    val query: T,

    @Schema(description = "The sorting criteria to apply to the query results.", example = "[{\"field\": \"name\", \"direction\": \"ASC\"}]")
    val sort: List<SortField>? = null,
)

===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/common/query/DefaultPageRequest.kt =====
package net.blugrid.api.common.query

import io.micronaut.data.model.Pageable
import io.micronaut.data.model.Sort
import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Default page request create")
data class DefaultPageRequest(
    @Schema(description = "The page number to retrieve, starting from 0.", example = "0")
    val page: Int,

    @Schema(description = "The number of records to retrieve per page.", example = "20")
    private val size: Int,

    @Schema(description = "The sorting criteria to apply to the page request.", example = "Sort.by('name').ascending()")
    private val sort: Sort? = Sort.unsorted()
) : Pageable {

    init {
        require(size >= 0) { "Page size must not be less than zero!" }
        require(page >= 0) { "Page index must not be less than zero!" }
    }

    override fun getNumber(): Int = page
    override fun next(): Pageable = DefaultPageRequest(page + 1, size, getSort())
    override fun getSort(): Sort = sort ?: Sort.unsorted()
    override fun getSize(): Int = size
    override fun getOffset(): Long = page.toLong() * size.toLong()
    fun hasPrevious(): Boolean = page > 0
    fun first(): Pageable = DefaultPageRequest(0, page, sort)
    override fun previous(): Pageable = if (page == 0) this else DefaultPageRequest(page - 1, size, sort)
    fun previousOrFirst(): Pageable = if (hasPrevious()) previous() else first()
}

===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/common/search/SearchPage.kt =====
package net.blugrid.api.common.search

import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Search page")
data class SearchPage<T, S>(
    val content: List<T> = emptyList(),
    val searchResults: S? = null,
    val size: Int? = 0,
    val number: Int? = 1,
    val first: Boolean? = true,
    val last: Boolean? = true,
    val numberOfElements: Int? = 0,
    val totalElements: Int? = 0,
    val totalPages: Int? = 1,
)

===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/common/search/SearchIndex.kt =====
package net.blugrid.api.common.search

import io.swagger.v3.oas.annotations.media.Schema
import net.blugrid.api.common.model.resource.ResourceType
import java.time.LocalDateTime

@Schema(description = "Represents a search index entry, storing searchable metadata for a resource.")
data class SearchIndex<T>(
    @Schema(description = "The unique identifier of the resource.", example = "12345")
    val resourceId: Long,

    @Schema(description = "The type of resource being indexed, such as 'Document', 'User', etc.", example = "DOCUMENT")
    val resourceType: ResourceType,

    @Schema(description = "The resource object itself, which can be of any type.", example = "ResourceObject")
    val resource: T,

    @Schema(description = "The unique identifier of the tenant associated with this resource.", example = "1001")
    val tenantId: Long,

    @Schema(description = "A string containing search terms related to the resource, used for indexing.", example = "sample, document, user guide")
    val searchTerms: String,

    @Schema(description = "The timestamp when the resource was created in the index.", example = "2024-08-25T10:15:30")
    val createdTimestamp: LocalDateTime? = null,

    @Schema(description = "The timestamp when the resource was last changed in the index.", example = "2024-08-26T12:30:45")
    val lastChangedTimestamp: LocalDateTime? = null
)

===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/common/service/SearchPage.kt =====
package net.blugrid.api.common.service

import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Represents a paginated response for search results, including content and metadata about the search.")
data class SearchPage<T, S>(
    @Schema(description = "The list of content items returned by the search query.", example = "List of items")
    val content: List<T> = emptyList(),

    @Schema(description = "Additional search results or metadata related to the search query.", example = "SearchResultMetadata")
    val searchResults: S? = null,

    @Schema(description = "The number of items per page.", example = "20")
    val size: Int? = 0,

    @Schema(description = "The current page number, starting from 1.", example = "1")
    val number: Int? = 1,

    @Schema(description = "Indicates whether this is the first page of results.", example = "true")
    val first: Boolean? = true,

    @Schema(description = "Indicates whether this is the last page of results.", example = "true")
    val last: Boolean? = true,

    @Schema(description = "The number of elements in the current page.", example = "20")
    val numberOfElements: Int? = 0,

    @Schema(description = "The total number of elements across all pages.", example = "100")
    val totalElements: Int? = 0,

    @Schema(description = "The total number of pages available.", example = "5")
    val totalPages: Int? = 1,
)

===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/common/service/GenericCrudService.kt =====
package net.blugrid.api.common.service

import io.micronaut.data.model.Page
import io.micronaut.data.model.Pageable
import net.blugrid.api.common.model.resource.GenericCreateResource
import net.blugrid.api.common.model.resource.GenericResource
import net.blugrid.api.common.model.resource.GenericUpdateResource
import net.blugrid.api.common.repository.model.GenericEntity
import net.blugrid.api.common.repository.model.GenericEntityMapper
import java.util.Optional
import java.util.UUID

@Deprecated("Use GenericQueryService and GenericCommandService instead")
interface GenericCrudService<T : GenericResource<T>, U : GenericCreateResource<U>, V : GenericUpdateResource<V>, X : GenericEntity<X>, Y : GenericEntityMapper<T, U, V, X>> {
    fun getPage(pageable: Pageable): Page<T>
    fun getById(id: Long): T
    fun getByIdOptional(id: Long): Optional<T>
    fun getAll(): List<T>
    fun getByUuid(uuid: UUID): T
    fun getByUuidOptional(uuid: UUID): Optional<T>
    fun update(id: Long, update: V): T
    fun create(newResource: U): T
    fun delete(id: Long)
}

===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/common/service/GenericQueryService.kt =====
package net.blugrid.api.common.service

import io.micronaut.data.model.Page
import io.micronaut.data.model.Pageable
import java.util.Optional
import java.util.UUID

interface GenericQueryService<F, T> {
    fun getPage(pageable: Pageable): Page<T>
    fun getById(id: Long): T
    fun getByIdOptional(id: Long): Optional<T>
    fun getAll(): List<T>
    fun getByUuid(uuid: UUID): T
    fun getByUuidOptional(uuid: UUID): Optional<T>
    fun findByFilter(filter: F, pageable: Pageable): Page<T>
}

===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/common/service/GenericCommandService.kt =====
package net.blugrid.api.common.service

import net.blugrid.api.common.model.resource.GenericCreateResource
import net.blugrid.api.common.model.resource.GenericResource
import net.blugrid.api.common.model.resource.GenericUpdateResource
import net.blugrid.api.common.repository.model.GenericEntity
import net.blugrid.api.common.repository.model.GenericEntityMapper

interface GenericCommandService<T : GenericResource<T>, U : GenericCreateResource<U>, V : GenericUpdateResource<V>, X : GenericEntity<X>, Y : GenericEntityMapper<T, U, V, X>> {
    fun update(id: Long, update: V): T
    fun create(newResource: U): T
    fun delete(id: Long)
}

===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/common/exception/APIError.kt =====
package net.blugrid.api.common.exception

import com.fasterxml.jackson.annotation.JsonIgnore
import com.fasterxml.jackson.annotation.JsonProperty
import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Base api error interface")
interface APIError {

    @get: [JsonProperty("statusCode")]
    val statusCode: String

    @get: [JsonProperty("code")]
    val code: String

    @get: [JsonProperty("message")]
    val message: String

    @get: [JsonIgnore]
    val headers: Map<String, String>?

    @get: [JsonProperty("details")]
    val details: List<Any>?

    @get: [JsonProperty("_links")]
    val links: Map<String, Link>?
}

data class Link(
    val href: String,
    val templated: Boolean = false
)

@Schema(description = "Default API error")
data class DefaultAPIError(
    override val statusCode: String,
    override val code: String,
    override val message: String,
    override val headers: Map<String, String>? = null,
    override val links: Map<String, Link>? = null,
    override val details: List<Any>? = null
) : APIError

@Schema(description = "OAuth error")
data class OAuthError(

    override val statusCode: String,
    override val code: String,
    override val message: String,

    val errorDescription: String? = null,

    override val headers: Map<String, String>? = null,
    override val links: Map<String, Link>?,
    override val details: List<Any>? = null
) : APIError

@Schema(description = "API Error detail")
data class APIErrorDetail(

    @JsonProperty("field")
    val field: String? = null,

    @JsonProperty("index")
    val index: Int? = null,

    @JsonProperty("message")
    val message: String,
)

@Schema(description = "API validation detail")
data class APIErrorValidationDetail(

    @JsonProperty("field")
    val field: String? = null,

    @JsonProperty("value")
    val value: String? = null,

    @JsonProperty("message")
    val message: String,
)

===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/common/exception/APIException.kt =====
package net.blugrid.api.common.exception

import io.micronaut.http.HttpStatus
import io.micronaut.http.exceptions.HttpStatusException

open class APIException(
    val apiError: APIError,
    val includeStackTrace: Boolean = false
) : HttpStatusException(HttpStatus.valueOf(apiError.statusCode.toInt()), apiError.message) {

    private val stackTraceInfo: List<String> = if (includeStackTrace) {
        this.stackTrace.map { it.toString() }
    } else {
        emptyList()
    }

    fun toResponseBody(): Map<String, Any> {
        val response = mutableMapOf<String, Any>(
            "status" to apiError.statusCode,
            "message" to apiError.message,
            "code" to apiError.code,
            "details" to apiError.details.orEmpty(),
            "_links" to apiError.links.orEmpty()
        )
        apiError.headers?.let { response.putAll(it) }
        if (includeStackTrace && stackTraceInfo.isNotEmpty()) {
            response["stackTrace"] = stackTraceInfo
        }
        return response
    }
}

===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/common/exception/NotFoundException.kt =====
package net.blugrid.api.common.exception

import io.micronaut.http.HttpStatus

class NotFoundException(
    message: String = "Resource Not Found",
    details: List<Any>? = null,
    includeStackTrace: Boolean = false
) : APIException(
    apiError = DefaultAPIError(
        statusCode = HttpStatus.NOT_FOUND.code.toString(),
        code = "NOT_FOUND",
        message = message,
        details = details
    ),
    includeStackTrace = includeStackTrace
)

===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/common/exception/APIAccessDeniedException.kt =====
package net.blugrid.api.common.exception

import io.micronaut.http.HttpStatus

class APIAccessDeniedException(
    message: String = "Access Denied",
    details: List<Any>? = null,
    includeStackTrace: Boolean = false
) : APIException(
    apiError = DefaultAPIError(
        statusCode = HttpStatus.FORBIDDEN.code.toString(),
        code = "ACCESS_DENIED",
        message = message,
        details = details
    ),
    includeStackTrace = includeStackTrace
)

===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/common/exception/APIInternalServerException.kt =====
package net.blugrid.api.common.exception

import io.micronaut.http.HttpStatus


class APIInternalServerException(
    message: String = "API Internal Server Error",
    details: List<Any>? = null,
    includeStackTrace: Boolean = false
) : APIException(
    apiError = DefaultAPIError(
        statusCode = HttpStatus.INTERNAL_SERVER_ERROR.code.toString(),
        code = "INTERNAL_SERVER_ERROR",
        message = message,
        details = details
    ),
    includeStackTrace = includeStackTrace
)

===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/common/controller/GenericCrudResource.kt =====
package net.blugrid.api.common.controller

import io.micronaut.data.model.Page
import io.micronaut.data.model.Pageable
import io.micronaut.http.MediaType
import io.micronaut.http.annotation.Body
import io.micronaut.http.annotation.Delete
import io.micronaut.http.annotation.Get
import io.micronaut.http.annotation.PathVariable
import io.micronaut.http.annotation.Post
import io.micronaut.http.annotation.Put
import net.blugrid.api.common.model.resource.GenericCreateResource
import net.blugrid.api.common.model.resource.GenericResource
import net.blugrid.api.common.model.resource.GenericUpdateResource
import net.blugrid.api.common.repository.model.GenericEntity
import net.blugrid.api.common.repository.model.GenericEntityMapper

interface GenericCrudResource<T : GenericResource<T>, U : GenericCreateResource<U>, V : GenericUpdateResource<V>> {

    @Put(consumes = [MediaType.APPLICATION_JSON], produces = [MediaType.APPLICATION_JSON])
    fun create(@Body created: U): T

    @Post(uri = "/{id}", consumes = [MediaType.APPLICATION_JSON], produces = [MediaType.APPLICATION_JSON])
    fun update(@PathVariable id: Long, @Body updated: V): T

    @Get(value = "/{id}", produces = [MediaType.APPLICATION_JSON])
    fun getById(@PathVariable id: Long): T

    @Post(consumes = [MediaType.APPLICATION_JSON], produces = [MediaType.APPLICATION_JSON])
    fun getPage(@Body pageable: Pageable): Page<T>

    @Get(produces = [MediaType.APPLICATION_JSON])
    fun getAll(): List<T>

    @Delete(value = "/{id}", produces = [MediaType.APPLICATION_JSON])
    fun delete(@PathVariable id: Long)
}

interface GenericReadOnlyResource<T : GenericResource<T>, U : GenericCreateResource<U>, V : GenericUpdateResource<V>> {

    @Get(value = "/{id}", produces = [MediaType.APPLICATION_JSON])
    fun getById(@PathVariable id: Long): T

    @Post(consumes = [MediaType.APPLICATION_JSON], produces = [MediaType.APPLICATION_JSON])
    fun getPage(@Body pageable: Pageable): Page<T>

    @Get(produces = [MediaType.APPLICATION_JSON])
    fun getAll(): List<T>
}

interface GenericCrudController<T : GenericResource<T>, U : GenericCreateResource<U>, V : GenericUpdateResource<V>, X : GenericEntity<X>, Y : GenericEntityMapper<T, U, V, X>> {

    @Put(consumes = [MediaType.APPLICATION_JSON], produces = [MediaType.APPLICATION_JSON])
    fun create(@Body created: U): T

    @Post(uri = "/{id}", consumes = [MediaType.APPLICATION_JSON], produces = [MediaType.APPLICATION_JSON])
    fun update(@PathVariable id: Long, @Body updated: V): T

    @Get(value = "/{id}", produces = [MediaType.APPLICATION_JSON])
    fun getById(@PathVariable id: Long): T

    @Post(consumes = [MediaType.APPLICATION_JSON], produces = [MediaType.APPLICATION_JSON])
    fun getPage(@Body pageable: Pageable): Page<T>

    @Get(produces = [MediaType.APPLICATION_JSON])
    fun getAll(): List<T>

    @Delete(value = "/{id}", produces = [MediaType.APPLICATION_JSON])
    fun delete(@PathVariable id: Long)
}


===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/common/controller/GenericQueryResource.kt =====
package net.blugrid.api.common.controller

import io.micronaut.data.model.Page
import io.micronaut.http.MediaType
import io.micronaut.http.annotation.Body
import io.micronaut.http.annotation.Post
import net.blugrid.api.common.query.PageableQuery

interface GenericQueryResource<F, T> {

    @Post(uri = "/query", consumes = [MediaType.APPLICATION_JSON], produces = [MediaType.APPLICATION_JSON])
    fun query(@Body query: PageableQuery<F>): Page<T>
}

===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/common/repository/model/HasUuid.kt =====
package net.blugrid.api.common.repository.model

import io.swagger.v3.oas.annotations.media.Schema
import java.util.UUID

@Schema(description = "Base uuidentity interface")
interface HasUuid {
    var uuid: UUID
}

fun <T : HasUuid, E : PersistableResource<T>> MutableSet<E>.merge(newEntities: MutableSet<E>, updateFn: (existing: E, update: E) -> E) {
    // delete entities
    this.except(newEntities).takeIf { it.isNotEmpty() }
        ?.let { existing ->
            this.removeAll(existing.toSet())
        }

    // insert new entities
    newEntities.except(this).takeIf { it.isNotEmpty() }
        ?.let { this.addAll(it) }

    // update existing
    this.intersect(newEntities).takeIf { it.isNotEmpty() }
        ?.forEach { existing ->
            newEntities.find { it.uuid == existing.uuid }
                ?.let { update -> updateFn(existing, update) }
        }
}

fun <T : HasUuid> MutableSet<T>.except(otherEntities: MutableSet<T>) =
    if (otherEntities.isEmpty())
        this
    else
        filter { existing -> !otherEntities.hasAny(existing) }

fun <T : HasUuid> MutableSet<T>.intersect(otherEntities: MutableSet<T>) =
    if (otherEntities.isEmpty())
        emptySet()
    else
        filter { existing -> otherEntities.hasAny(existing) }

fun <T : HasUuid> MutableSet<T>.hasAny(otherEntity: T) =
    filter { it.uuid == otherEntity.uuid }.any()

===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/common/repository/model/TenantScoped.kt =====
package net.blugrid.api.common.repository.model

import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Represents tenant scope metadata for a resource.")
interface TenantScoped {
    var tenantId: Long?
}

===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/common/repository/model/AuditEmbeddable.kt =====
package net.blugrid.api.common.repository.model

import io.micronaut.data.annotation.Embeddable
import io.micronaut.data.annotation.Version
import io.micronaut.data.annotation.event.PrePersist
import io.micronaut.data.annotation.event.PreUpdate
import jakarta.persistence.Column
import jakarta.persistence.Embedded
import jakarta.persistence.MappedSuperclass
import net.blugrid.api.security.context.CurrentRequestContext
import org.hibernate.annotations.CreationTimestamp
import org.hibernate.annotations.UpdateTimestamp
import java.time.LocalDateTime

@Embeddable
class AuditEmbeddable : AuditableEntityFields {

    @CreationTimestamp
    @Column(name = "created_timestamp", updatable = false)
    override var createdTimestamp: LocalDateTime? = null

    @UpdateTimestamp
    @Column(name = "last_changed_timestamp")
    override var lastChangedTimestamp: LocalDateTime? = null

    @Column(name = "created_by_session_id", updatable = false)
    override var createdBySessionId: Long? = null

    @Column(name = "last_changed_by_session_id")
    override var lastChangedBySessionId: Long? = null

    @Version
    @Column(name = "version")
    override var version: Int = 0

    fun prePersist(sessionId: Long) {
        createdBySessionId = sessionId
        lastChangedBySessionId = sessionId
    }

    fun preUpdate(sessionId: Long) {
        lastChangedBySessionId = sessionId
    }
}

interface AuditableEntityFields {
    var createdTimestamp: LocalDateTime?
    var lastChangedTimestamp: LocalDateTime?
    var createdBySessionId: Long?
    var lastChangedBySessionId: Long?
    var version: Int
}

@MappedSuperclass
abstract class AuditableEntity {

    @Embedded
    abstract var audit: AuditEmbeddable

    @PrePersist
    fun auditCreate() {
        val sessionId = getCurrentSessionId()
        audit.prePersist(sessionId)
    }

    @PreUpdate
    fun auditUpdate() {
        val sessionId = getCurrentSessionId()
        audit.preUpdate(sessionId)
    }

    private fun getCurrentSessionId(): Long =
       CurrentRequestContext.currentSession?.sessionId?.toLong() ?: 0L
}

===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/common/repository/model/BusinessUnitScoped.kt =====
package net.blugrid.api.common.repository.model

import io.swagger.v3.oas.annotations.media.Schema

@Schema(description = "Represents business unit + tenant scope metadata for a resource.")
interface BusinessUnitScoped : TenantScoped {
    var businessUnitId: Long?
}

===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/common/repository/model/PersistableResource.kt =====
package net.blugrid.api.common.repository.model

import java.util.UUID

interface PersistableResource<T> : HasUuid {

    var id: Long?

    override var uuid: UUID

    fun update(update: T): T
}

===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/common/repository/model/UnscopedPersistable.kt =====
package net.blugrid.api.common.repository.model

interface UnscopedPersistable<T> : PersistableResource<T> {

    var audit: AuditEmbeddable
}

===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/common/repository/model/TenantScopedResource.kt =====
package net.blugrid.api.common.repository.model

interface TenantScopedResource<T> : PersistableResource<T> {

    val audit: EmbeddedAuditInterface?

    val permission: ITenantPermissionEntity?
}

===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/common/repository/model/BusinessUnitScopedResource.kt =====
package net.blugrid.api.common.repository.model

interface BusinessUnitScopedResource<T> : PersistableResource<T> {

    val audit: EmbeddedAuditInterface?

    val permission: IBusinessUnitPermissionEntity?
}

===== ./common/common-kotlin/common-api/common-api-model/src/main/kotlin/net/blugrid/api/common/repository/model/BusinessUnitScopeEmbeddable.kt =====
package net.blugrid.api.common.repository.model

import io.micronaut.data.annotation.Embeddable

@Embeddable
data class BusinessUnitScopeEmbeddable(
    override var tenantId: Long? = null,

    override var businessUnitId: Long? = null
) : BusinessUnitScoped

===== ./common/common-kotlin/common-api/common-api-model/gradle.properties =====
micronautVersion=4.4.3
kotlinVersion=1.9.23

===== ./common/common-kotlin/common-api/common-api-model/build.gradle.kts =====
plugins {
   alias(libs.plugins.jvm)
   alias(libs.plugins.kapt)
   alias(libs.plugins.allopen)
   alias(libs.plugins.shadow)
   alias(libs.plugins.application)
}

version = "0.1"
group = "net.blugrid.api"

repositories {
    mavenCentral()
}

dependencies {
    api(project(":common:common-kotlin:common-api:common-api-domain"))

    implementation(platform("io.micronaut.platform:micronaut-platform"))
    implementation(platform("aws.sdk.kotlin:bom:1.4.92"))
    kapt(annotationProcessorLibs.bundles.commonAnnotationProcessors)
    implementation(libs.bundles.commonLibs)
    implementation(libs.bundles.webServiceLibs)

    runtimeOnly(runTimeLibs.bundles.commonRuntimeLibs)

    compileOnly(libs.bundles.compileOnlyLibs)
    testImplementation(testLibs.bundles.testImplementationLibs) {
        exclude(group = "org.slf4j", module = "slf4j-api")
    }
}

application {
    mainClass.set("net.blugrid.api.ApplicationKt")
}
java {
    sourceCompatibility = JavaVersion.toVersion("17")
}
kapt {
    arguments {
        arg("micronaut.openapi.project.dir", projectDir.toString())
    }
}
kotlin {
    jvmToolchain {
        languageVersion.set(JavaLanguageVersion.of(17))
    }
}

graalvmNative.toolchainDetection = false
micronaut {
    runtime("netty")
    testRuntime("junit5")
    processing {
        incremental(true)
        annotations("net.blugrid.api.*")
    }
}

===== ./common/common-kotlin/common-api/common-api-security/src/main/kotlin/net/blugrid/api/security/jwt/model/JwtToken.kt =====
package net.blugrid.api.security.jwt.model

import com.fasterxml.jackson.annotation.JsonInclude
import com.fasterxml.jackson.databind.DeserializationFeature
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.databind.PropertyNamingStrategies
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule
import com.fasterxml.jackson.module.kotlin.KotlinModule
import net.blugrid.api.common.model.session.SessionType
import net.blugrid.api.security.authentication.model.AuthenticatedBusinessUnitSession
import net.blugrid.api.security.authentication.model.AuthenticatedOrganisation
import net.blugrid.api.security.authentication.model.AuthenticatedSession
import net.blugrid.api.security.authentication.model.AuthenticatedUser
import net.blugrid.api.security.authentication.model.AuthenticatedWebApplicationSession
import net.blugrid.api.security.authentication.model.AuthenticationType
import java.util.Date

data class JwtToken(
    val authenticationType: AuthenticationType,
    val user: AuthenticatedUser,
    val organisation: AuthenticatedOrganisation? = null,
    val session: AuthenticatedSession,
    val expirationTime: Date? = null,
    val roles: MutableList<String> = mutableListOf(),
    val attributes: MutableMap<String, Any> = mutableMapOf()
) {
    val name: String?
        get() = user.displayName
    val providerId: String
        get() = user.providerId
    val principalName: String?
        get() = user.displayName
    val principalEmail: String
        get() = user.email
    val userIdentityId: String
        get() = user.userIdentityId

    val tenantId: String?
        get() =  when (authenticationType) {
            AuthenticationType.BUSINESS_UNIT -> (session as AuthenticatedBusinessUnitSession).tenantId
            AuthenticationType.TENANT ->  (session as AuthenticatedWebApplicationSession).tenantId
            else -> null
        }
    val businessUnitId: String?
        get() = if (authenticationType === AuthenticationType.BUSINESS_UNIT) {
            (session as AuthenticatedBusinessUnitSession).businessUnitId
        } else {
            null
        }
    val sessionId: String
        get() = session.sessionId
    val sessionType: SessionType
        get() = session.sessionType
}


val jwtObjectMapper: ObjectMapper = with(ObjectMapper()) {
    propertyNamingStrategy = PropertyNamingStrategies.SNAKE_CASE
    setSerializationInclusion(JsonInclude.Include.NON_NULL)
    disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)
    registerModule(KotlinModule.Builder().build())
    registerModule(JavaTimeModule())
}

@Suppress("UNCHECKED_CAST")
inline fun <reified T : Any> T.toJWTRawMap(): Map<out String, Any> =
    jwtObjectMapper.convertValue(this, Map::class.java) as Map<out String, Any>


===== ./common/common-kotlin/common-api/common-api-security/src/main/kotlin/net/blugrid/api/security/jwt/model/JwtDecoder.kt =====
package net.blugrid.api.security.jwt.model

import com.nimbusds.jwt.JWT

interface JwtDecoder {
    fun decode(token: String): JWT
}

===== ./common/common-kotlin/common-api/common-api-security/src/main/kotlin/net/blugrid/api/security/jwt/model/SelfSignedJwtDecoder.kt =====
package net.blugrid.api.security.jwt.model

import com.nimbusds.jwt.JWT
import java.util.Optional

interface SelfSignedJwtDecoder {
    fun decode(token: String): Optional<JWT>
}

===== ./common/common-kotlin/common-api/common-api-security/src/main/kotlin/net/blugrid/api/security/jwt/factory/AccessTokenFactory.kt =====
package net.blugrid.api.security.jwt.factory

import net.blugrid.api.security.jwt.model.JwtToken
import net.blugrid.api.security.jwt.model.toJWTRawMap

object AccessTokenFactory : AbstractJwtGenerator(
    keystoreFile = "keystore.jks",
    keystorePassword = "password",
    keyPairAlias = "jwt_key",
) {
    override val baseJwtPayload: Map<String, Any> = emptyMap()

    fun token(
        jwtToken: JwtToken
    ): String {
        val payloadMap = jwtToken.toJWTRawMap().toMutableMap()
        return generateToken(payloadMap)
    }
}


===== ./common/common-kotlin/common-api/common-api-security/src/main/kotlin/net/blugrid/api/security/jwt/factory/AbstractJwtGenerator.kt =====
package net.blugrid.api.security.jwt.factory

import com.fasterxml.jackson.databind.ObjectMapper
import com.nimbusds.jose.JOSEObjectType
import com.nimbusds.jose.JWSAlgorithm
import com.nimbusds.jose.JWSHeader.Builder
import com.nimbusds.jose.JWSSigner
import com.nimbusds.jose.crypto.RSASSASigner
import com.nimbusds.jwt.JWTClaimsSet
import com.nimbusds.jwt.SignedJWT
import net.blugrid.api.security.jwt.mapping.jwtObjectMapper
import java.security.KeyStore
import java.security.KeyStore.PasswordProtection


abstract class AbstractJwtGenerator(
    keystoreFile: String = "keystore.jks",
    keystorePassword: String = "password",
    keyPairAlias: String = "jwt_key"
) {

    open val baseJwtPayload: Map<String, Any> = emptyMap()

    private val jwtSigner: JWSSigner
    private var objectMapper: ObjectMapper

    init {
        val store = loadKeystore(keystoreFile, keystorePassword)
        val keyPasswordProtection = PasswordProtection(keystorePassword.toCharArray())
        val privateKeyEntry = store.getEntry(keyPairAlias, keyPasswordProtection) as KeyStore.PrivateKeyEntry

        jwtSigner = RSASSASigner(privateKeyEntry.privateKey)

        objectMapper = jwtObjectMapper
    }

    private fun loadKeystore(keystoreFile: String, keystorePassword: String): KeyStore {
        val keyStore = KeyStore.getInstance("JKS")
        val keystoreStream = javaClass.classLoader.getResourceAsStream(keystoreFile)
            ?: throw IllegalArgumentException("Keystore file not found: $keystoreFile")
        keystoreStream.use {
            keyStore.load(it, keystorePassword.toCharArray())
        }
        return keyStore
    }

    protected fun generateToken(extraAttributes: Map<out String, Any>): String {
        val payloadMap = baseJwtPayload + extraAttributes
        val payload = objectMapper.writeValueAsString(payloadMap)
        val jwsHeader = Builder(JWSAlgorithm.RS256)
            .type(JOSEObjectType.JWT)
            .build()
        val jwt = SignedJWT(jwsHeader, JWTClaimsSet.parse(payload))
        jwt.sign(jwtSigner)
        return jwt.serialize()
    }
}

===== ./common/common-kotlin/common-api/common-api-security/src/main/kotlin/net/blugrid/api/security/jwt/mapping/JwtTokenMapping.kt =====
package net.blugrid.api.security.jwt.mapping

import net.blugrid.api.security.authentication.model.BusinessUnitAuthentication
import net.blugrid.api.security.authentication.model.DecoratedAuthentication
import net.blugrid.api.security.authentication.model.GuestAuthentication
import net.blugrid.api.security.authentication.model.TenantAuthentication
import net.blugrid.api.security.jwt.model.JwtToken

fun DecoratedAuthentication.toJwtToken(): JwtToken = let { source ->
    when (source) {
        is GuestAuthentication -> source.toGuestJwtToken()
        is TenantAuthentication -> source.toTenantJwtToken()
        is BusinessUnitAuthentication -> source.toBusinessUnitJwtToken()
        else -> throw UnsupportedOperationException(source.toString())
    }
}

fun GuestAuthentication.toGuestJwtToken(
    attributes: MutableMap<String, Any> = mutableMapOf(),
    roles: MutableList<String> = mutableListOf()
): JwtToken {
    val source = this
    return JwtToken(
        authenticationType = source.authenticationType,
        user = source.user,
        session = source.session,
        expirationTime = source.expirationTime,
        roles = roles,
        attributes = attributes,
    )
}

fun TenantAuthentication.toTenantJwtToken(
    attributes: MutableMap<String, Any> = mutableMapOf(),
    roles: MutableList<String> = mutableListOf()
): JwtToken {
    val source = this
    return JwtToken(
        authenticationType = source.authenticationType,
        organisation = source.organisation,
        user = source.user,
        session = source.session,
        expirationTime = source.expirationTime,
        roles = roles,
        attributes = attributes,
    )
}

fun BusinessUnitAuthentication.toBusinessUnitJwtToken(
    attributes: MutableMap<String, Any> = mutableMapOf(),
    roles: MutableList<String> = mutableListOf()
): JwtToken {
    val source = this
    return JwtToken(
        authenticationType = source.authenticationType,
        organisation = source.organisation,
        user = source.user,
        session = source.session,
        expirationTime = source.expirationTime,
        roles = roles,
        attributes = attributes,
    )
}


===== ./common/common-kotlin/common-api/common-api-security/src/main/kotlin/net/blugrid/api/security/jwt/mapping/jwtObjectMapper.kt =====
package net.blugrid.api.security.jwt.mapping

import com.fasterxml.jackson.annotation.JsonInclude
import com.fasterxml.jackson.databind.DeserializationFeature
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.databind.PropertyNamingStrategies
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule
import com.fasterxml.jackson.module.kotlin.KotlinModule

val jwtObjectMapper: ObjectMapper = ObjectMapper().apply {
    propertyNamingStrategy = PropertyNamingStrategies.SNAKE_CASE
    setSerializationInclusion(JsonInclude.Include.NON_NULL)
    disable(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES)
    registerModule(KotlinModule.Builder().build())
    registerModule(JavaTimeModule())
}

===== ./common/common-kotlin/common-api/common-api-security/src/main/kotlin/net/blugrid/api/security/jwt/JwtUtils.kt =====
package net.blugrid.api.security.jwt

import io.micronaut.http.MutableHttpRequest
import io.micronaut.http.MutableHttpResponse
import io.micronaut.http.cookie.Cookie
import io.netty.handler.codec.http.cookie.DefaultCookie
import io.netty.handler.codec.http.cookie.ServerCookieEncoder

fun <T> MutableHttpRequest<T>.applyCookies(cookies: List<Cookie>): MutableHttpRequest<T> {
    return apply {
        cookies.forEach { this.cookie(it) }
    }
}

fun DefaultCookie.toCookie() = let { defaultCookie ->
    val cookie = Cookie.of(defaultCookie.name(), defaultCookie.value())
    cookie.domain(defaultCookie.domain())
    cookie.path(defaultCookie.path())
    cookie.httpOnly(defaultCookie.isHttpOnly)
    cookie.secure(defaultCookie.isSecure)
    cookie.maxAge(defaultCookie.maxAge())
    cookie
}

fun String.toCookie(cookieName: String, ttl: Long): Cookie = this.let { value ->
    return DefaultCookie(cookieName, value)
        .apply {
            isHttpOnly = true
            setMaxAge(ttl)
            setPath("/")
        }
        .toCookie()
}

fun MutableHttpResponse<*>.clearCookies(cookies: List<String>): MutableHttpResponse<*> {
    cookies.forEach { clearCookie(it) }
    return this
}

fun MutableHttpResponse<*>.clearCookie(cookieName: String) {
    cookie(Cookie.of(cookieName, "")
        .maxAge(0)
        .path("/"))
}

fun MutableHttpResponse<*>.setCookie(cookieName: String, cookieValue: String, maxAge: Long = 300000L): MutableHttpResponse<*> {
    val cookie = DefaultCookie(cookieName, cookieValue).apply {
        isHttpOnly = true
        setMaxAge(maxAge)
        setPath("/")
    }
    val cookieHeader = ServerCookieEncoder.LAX.encode(cookie)
    headers.add("set-cookie", cookieHeader)
    return this
}

fun MutableHttpResponse<*>.applyCookies(cookies: List<DefaultCookie>): MutableHttpResponse<*> {
    cookies.forEach { cookie ->
        val cookieHeader = ServerCookieEncoder.LAX.encode(cookie)
        this.headers.add("set-cookie", cookieHeader)
    }
    return this
}

===== ./common/common-kotlin/common-api/common-api-security/src/main/kotlin/net/blugrid/api/security/config/RedirectProps.kt =====
package net.blugrid.api.security.config

import io.micronaut.context.annotation.ConfigurationProperties

@ConfigurationProperties("redirect")
interface RedirectProps {

    val loginCallbackUrl: String
    val loginSuccessUrl: String
    val loginFailureUrl: String
    val logoutCallbackUrl: String
    val logoutUrl: String
    val registrationUrl: String
    val registrationCallbackUrl: String
}

===== ./common/common-kotlin/common-api/common-api-security/src/main/kotlin/net/blugrid/api/security/config/SecurityProps.kt =====
package net.blugrid.api.security.config

import io.micronaut.context.annotation.ConfigurationProperties
import io.micronaut.core.bind.annotation.Bindable

@ConfigurationProperties("security")
interface SecurityProps {

    @ConfigurationProperties("auth0")
    class Auth0Config {
        lateinit var audience: String
        lateinit var auth0Domain: String
        lateinit var clientId: String
    }

    @ConfigurationProperties("cookies")
    interface CookieConfig {

        @get:Bindable(defaultValue = "JWT")
        val jwt: String

        @get:Bindable(defaultValue = "OAUTH2_PKCE")
        val oauthPkce: String

        @get:Bindable(defaultValue = "OAUTH2_STATE")
        val oathState: String

        @get:Bindable(defaultValue = "OPENID_NONCE")
        val oathNonce: String

        @get:Bindable(defaultValue = "300000L")
        val maxAge: Long
    }
}

===== ./common/common-kotlin/common-api/common-api-security/src/main/kotlin/net/blugrid/api/security/context/CurrentRequestContext.kt =====
package net.blugrid.api.security.context

import io.micronaut.http.HttpRequest
import io.micronaut.http.context.ServerRequestContext
import net.blugrid.api.security.authentication.mapping.toMultitenantAuthentication
import net.blugrid.api.security.authentication.model.AuthenticatedBusinessUnitSession
import net.blugrid.api.security.authentication.model.AuthenticatedOrganisation
import net.blugrid.api.security.authentication.model.AuthenticatedSession
import net.blugrid.api.security.authentication.model.AuthenticatedUser
import net.blugrid.api.security.authentication.model.AuthenticatedWebApplicationSession
import net.blugrid.api.security.authentication.model.BusinessUnitAuthentication
import net.blugrid.api.security.authentication.model.DecoratedAuthentication
import net.blugrid.api.security.authentication.model.GuestAuthentication
import net.blugrid.api.security.authentication.model.TenantAuthentication
import java.util.Optional

interface CurrentRequestContextProvider {
    val currentOrganisation: AuthenticatedOrganisation?
    val currentSession: AuthenticatedSession?
    val currentUser: AuthenticatedUser?
    val authentication: DecoratedAuthentication?
    val authenticationOpt: Optional<DecoratedAuthentication>?
    val currentIsUnscoped: Boolean
    val currentTenantId: Long?
    val currentBusinessUnitId: Long?
}

object CurrentRequestContext : CurrentRequestContextProvider {

    override val currentBusinessUnitId: Long?
        get() = if (BusinessUnitIdOverride.hasOverride()) {
            BusinessUnitIdOverride.value.toLong()
        } else {
            when (currentSession) {
                is AuthenticatedWebApplicationSession -> null
                is AuthenticatedBusinessUnitSession -> (currentSession as AuthenticatedBusinessUnitSession)
                    .businessUnitId
                    .toLong()

                else -> null
            }
        }

    override val currentTenantId: Long?
        get() = if (TenantIdOverride.hasOverride()) {
            TenantIdOverride.value.toLong()
        } else {
            when (currentSession) {
                is AuthenticatedWebApplicationSession -> (currentSession as AuthenticatedWebApplicationSession)
                    .tenantId
                    .toLong()

                is AuthenticatedBusinessUnitSession -> (currentSession as AuthenticatedBusinessUnitSession)
                    .tenantId.toLong()

                else -> null
            }
        }

    override val currentIsUnscoped: Boolean
        get() = if (IsUnscoped.isSet()) {
            IsUnscoped.value
        } else {
            false
        }

    override val currentOrganisation: AuthenticatedOrganisation?
        get() = when (authentication) {
            is TenantAuthentication -> (authentication as TenantAuthentication).organisation
            is BusinessUnitAuthentication -> (authentication as BusinessUnitAuthentication).organisation
            else -> null
        }


    override val currentSession: AuthenticatedSession?
        get() = when (authentication) {
            is GuestAuthentication -> (authentication as GuestAuthentication).session
            is TenantAuthentication -> (authentication as TenantAuthentication).session
            is BusinessUnitAuthentication -> (authentication as BusinessUnitAuthentication).session
            else -> null
        }

    override val currentUser: AuthenticatedUser?
        get() = when (authentication) {
            is GuestAuthentication -> (authentication as GuestAuthentication).user
            is TenantAuthentication -> (authentication as TenantAuthentication).user
            is BusinessUnitAuthentication -> (authentication as BusinessUnitAuthentication).user
            else -> null
        }

    override val authentication: DecoratedAuthentication?
        get() = authenticationOpt.orElse(null)


    override val authenticationOpt: Optional<DecoratedAuthentication>
        get() = ServerRequestContext.currentRequest<Any>()
            .flatMap { request: HttpRequest<Any> ->
                request.toMultitenantAuthentication()
            }
}

===== ./common/common-kotlin/common-api/common-api-security/src/main/kotlin/net/blugrid/api/security/context/RequestContextOverride.kt =====
package net.blugrid.api.security.context

import io.micronaut.http.HttpRequest
import io.micronaut.http.context.ServerRequestContext
import java.io.Closeable
import java.util.Optional
import java.util.function.Supplier

abstract class IdOverride(private val attributeName: String) : Closeable {

    var value: String
        get() = currentRequestContext().getStringAttribute(attributeName)
            .orElseThrow {
                IllegalStateException("No $attributeName override found")
            }
        set(value) {
            currentRequestContext().setStringAttribute(attributeName, value)
        }

    fun hasOverride(): Boolean = currentRequestContext().getStringAttribute(attributeName).isPresent

    override fun close() {
        currentRequestContext().removeStringAttribute(attributeName)
    }

    private fun currentRequestContext() = ServerRequestContext.currentRequest<Any?>()
    private fun Optional<HttpRequest<Any>>.getStringAttribute(name: String) = flatMap { it.getAttribute(name, String::class.java) }
    private fun Optional<HttpRequest<Any>>.setStringAttribute(name: String, value: String) = get().setAttribute(name, value)
    private fun Optional<HttpRequest<Any>>.removeStringAttribute(name: String) = flatMap { it.removeAttribute(name, String::class.java) }
}

object IsUnscoped : Closeable {

    private val attributeName = "isUnscoped"

    var value: Boolean
        get() = currentRequestContext().getBooleanAttribute(attributeName)
            .orElseThrow {
                IllegalStateException("No $attributeName override found")
            }
        set(value) {
            currentRequestContext().setBooleanAttribute(attributeName, value)
        }

    fun isSet(): Boolean = currentRequestContext().getBooleanAttribute(attributeName).isPresent

    override fun close() {
        currentRequestContext().removeBooleanAttribute(attributeName)
    }

    private fun currentRequestContext() = ServerRequestContext.currentRequest<Any?>()
    private fun Optional<HttpRequest<Any>>.getBooleanAttribute(name: String) = flatMap { it.getAttribute(name, Boolean::class.java) }
    private fun Optional<HttpRequest<Any>>.setBooleanAttribute(name: String, value: Boolean) = get().setAttribute(name, value)
    private fun Optional<HttpRequest<Any>>.removeBooleanAttribute(name: String) = flatMap { it.removeAttribute(name, Boolean::class.java) }
}

object TenantIdOverride : IdOverride("tenantIdOverride")
object BusinessUnitIdOverride : IdOverride("businessUnitIdOverride")

fun <T> doInRequestContext(action: () -> T): Any? {
    val currentRequest = ServerRequestContext.currentRequest<Any>()

    return if (currentRequest.isPresent) {
        // If the current request context is present, just execute the action
        action()
    } else {
        // If no request context is present, create a new one
        val newRequest: HttpRequest<Any?> = createNewRequest()
        ServerRequestContext.with(newRequest, Supplier { action() })
    }
}

private fun createNewRequest(): HttpRequest<Any?> {
    // Implement this method to create a new HttpRequest object as per your application's needs
    // For instance, you can use a dummy request or a specific request object required by your context
    return HttpRequest.GET("/")
}

===== ./common/common-kotlin/common-api/common-api-security/src/main/kotlin/net/blugrid/api/security/authentication/model/DecoratedAuthentication.kt =====
package net.blugrid.api.security.authentication.model

import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.annotation.JsonSubTypes
import com.fasterxml.jackson.annotation.JsonSubTypes.Type
import com.fasterxml.jackson.annotation.JsonTypeInfo
import com.fasterxml.jackson.annotation.JsonTypeInfo.Id.NAME
import com.nimbusds.jwt.JWT
import io.micronaut.security.authentication.Authentication
import io.swagger.v3.oas.annotations.media.Schema
import net.blugrid.api.common.model.session.SessionType
import java.util.Date

@Schema(description = "Decorated Authentication")
@JsonTypeInfo(use = NAME, property = "authenticationType")
@JsonSubTypes(
    Type(value = GuestAuthentication::class, name = "GUEST"),
    Type(value = TenantAuthentication::class, name = "TENANT"),
    Type(value = BusinessUnitAuthentication::class, name = "BUSINESS_UNIT"),
)
abstract class DecoratedAuthentication(
    open val authenticationType: AuthenticationType,
    //sso
    open val providerId: String,
    open val principalName: String,
    open val principalEmail: String,

    // session
    open val sessionId: String,
    open val userId: String,
    open val expirationTime: Date? = null,

    // user
    open val user: AuthenticatedUser,

) : Authentication {

    var token: JWT? = null

    override fun getName(): String? {
        return principalName
    }

    override fun getAttributes(): MutableMap<String, Any> {
        return mutableMapOf()
    }

    val isExpired: Boolean
        get() = expirationTime?.before(Date()) ?: false
}

data class GuestAuthentication(
    override val providerId: String,
    override val principalName: String,
    override val principalEmail: String,
    override val sessionId: String,
    override val userId: String,
    override val expirationTime: Date? = null,
    override val user: AuthenticatedUser,

    val webApplicationId: String,

    val session: AuthenticatedGuestSession,
): DecoratedAuthentication(
    authenticationType = AuthenticationType.GUEST,
    providerId = principalName,
    principalName = principalName,
    principalEmail = principalEmail,
    sessionId = sessionId,
    userId = userId,
    user = user,
    expirationTime = expirationTime,
)

data class TenantAuthentication(
    override val providerId: String,
    override val principalName: String,
    override val principalEmail: String,
    override val sessionId: String,
    override val userId: String,
    override val expirationTime: Date? = null,

    val tenantId: String,
    val webApplicationId: String,

    val organisation: AuthenticatedOrganisation,
    val session: AuthenticatedWebApplicationSession,
    override val user: AuthenticatedUser,
): DecoratedAuthentication(
    authenticationType = AuthenticationType.TENANT,
    providerId = principalName,
    principalName = principalName,
    principalEmail = principalEmail,
    sessionId = sessionId,
    userId = userId,
    user = user,
    expirationTime = expirationTime,
)

data class BusinessUnitAuthentication(
    override val providerId: String,
    override val principalName: String,
    override val principalEmail: String,
    override val sessionId: String,
    override val userId: String,
    override val expirationTime: Date? = null,

    val tenantId: String,
    val webApplicationId: String,
    val businessUnitId: String,

    val organisation: AuthenticatedOrganisation,
    val session: AuthenticatedBusinessUnitSession,
    override val user: AuthenticatedUser,
): DecoratedAuthentication(
    authenticationType = AuthenticationType.BUSINESS_UNIT,
    providerId = principalName,
    principalName = principalName,
    principalEmail = principalEmail,
    sessionId = sessionId,
    userId = userId,
    user = user,
    expirationTime = expirationTime,
)

data class AuthenticatedOrganisation(
    val tenantId: String,
    val primaryPartyId: String? = null,
    val displayName: String? = null,
    val partyId: String? = null
)

@Schema(description = "Session web token type")
@JsonTypeInfo(use = NAME, property = "sessionType")
@JsonSubTypes(
    Type(value = AuthenticatedGuestSession::class, name = "GUEST"),
    Type(value = AuthenticatedWebApplicationSession::class, name = "WEB_APPLICATION"),
    Type(value = AuthenticatedBusinessUnitSession::class, name = "BUSINESS_UNIT"),
)
abstract class AuthenticatedSession(
    open val sessionId: String,
    open val sessionType: SessionType,
    open val userId: String,
    open val webApplicationId: String,
)

data class AuthenticatedGuestSession(
    override val sessionId: String,
    override val userId: String,
    override val webApplicationId: String,
) : AuthenticatedSession(
    sessionId = sessionId,
    sessionType = SessionType.GUEST,
    userId = userId,
    webApplicationId = webApplicationId,
)

data class AuthenticatedWebApplicationSession(
    override val sessionId: String,
    override val userId: String,
    override val webApplicationId: String,
    val tenantId: String,
    val operatorId: String
) : AuthenticatedSession(
    sessionId = sessionId,
    sessionType = SessionType.WEB_APPLICATION,
    userId = userId,
    webApplicationId = webApplicationId,
)

class AuthenticatedBusinessUnitSession(
    override val sessionId: String,
    override val userId: String,
    override val webApplicationId: String,
    val tenantId: String,
    val operatorId: String,
    val businessUnitId: String,
) : AuthenticatedSession(
    sessionId = sessionId,
    sessionType = SessionType.BUSINESS_UNIT,
    userId = userId,
    webApplicationId = webApplicationId,
)

data class AuthenticatedUser(
    val userIdentityId: String,
    val partyId: String? = null,
    val tenantId: String? = null,
    val displayName: String? = null,
    val email: String,
    val emailVerified: Boolean? = true,
    val nickName: String? = null,
    val givenName: String? = null,
    val familyName: String? = null,
    val pictureUrl: String? = null,
    val providerId: String,
)

enum class AuthenticationType {
    @JsonProperty("GUEST") GUEST,
    @JsonProperty("TENANT") TENANT,
    @JsonProperty("BUSINESS_UNIT") BUSINESS_UNIT,
}


===== ./common/common-kotlin/common-api/common-api-security/src/main/kotlin/net/blugrid/api/security/authentication/mapping/AuthenticationMapping.kt =====
package net.blugrid.api.security.authentication.mapping

import com.fasterxml.jackson.core.JsonProcessingException
import com.fasterxml.jackson.databind.JsonNode
import com.fasterxml.jackson.databind.ObjectMapper
import com.nimbusds.jwt.JWT
import io.micronaut.http.HttpRequest
import io.micronaut.security.authentication.Authentication
import io.micronaut.security.filters.SecurityFilter
import net.blugrid.api.common.model.session.BusinessUnitSession
import net.blugrid.api.common.model.session.GuestSession
import net.blugrid.api.common.model.session.WebApplicationSession
import net.blugrid.api.common.model.user.UserIdentity
import net.blugrid.api.common.model.user.UserIdentityCreate
import net.blugrid.api.common.model.user.UserIdentityUpdate
import net.blugrid.api.security.authentication.model.AuthenticatedBusinessUnitSession
import net.blugrid.api.security.authentication.model.AuthenticatedGuestSession
import net.blugrid.api.security.authentication.model.AuthenticatedOrganisation
import net.blugrid.api.security.authentication.model.AuthenticatedUser
import net.blugrid.api.security.authentication.model.AuthenticatedWebApplicationSession
import net.blugrid.api.security.authentication.model.AuthenticationType
import net.blugrid.api.security.authentication.model.BusinessUnitAuthentication
import net.blugrid.api.security.authentication.model.DecoratedAuthentication
import net.blugrid.api.security.authentication.model.GuestAuthentication
import net.blugrid.api.security.authentication.model.TenantAuthentication
import org.slf4j.Logger
import java.time.Instant
import java.util.Date
import java.util.Optional
import java.util.UUID

fun GuestSession.toGuestAuthentication(
    userIdentity: UserIdentity,
) = let { session ->
    GuestAuthentication(
        providerId = userIdentity.providerId,
        principalName = userIdentity.name,
        principalEmail = userIdentity.email,
        sessionId = session.id.toString(),
        userId = user.id.toString(),
        webApplicationId = session.webApplication.id.toString(),

        session = AuthenticatedGuestSession(
            sessionId = session.id.toString(),
            userId = session.user.id.toString(),
            webApplicationId = session.webApplication.id.toString(),
        ),
        user = AuthenticatedUser(
            userIdentityId = userIdentity.id.toString(),
            displayName = userIdentity.displayName,
            partyId = userIdentity.partyId.toString(),
            email = userIdentity.email,
            emailVerified = userIdentity.emailVerified,
            nickName = userIdentity.nickName,
            givenName = userIdentity.givenName,
            familyName = userIdentity.familyName,
            pictureUrl = userIdentity.pictureUrl,
            providerId = userIdentity.providerId
        ),
    )
}

fun WebApplicationSession.toTenantAuthentication() = let { session ->
    TenantAuthentication(
        providerId = session.user.providerId,
        principalName = session.user.name,
        principalEmail = session.user.email,
        sessionId = session.id.toString(),
        userId = user.id.toString(),
        tenantId = organisation.id.toString(),
        webApplicationId = session.webApplication.id.toString(),

        organisation = AuthenticatedOrganisation(
            tenantId = organisation.id.toString(),
            primaryPartyId = organisation.primaryPartyId.toString(),
            displayName = organisation.displayName,
            partyId = organisation.partyId?.toString()
        ),
        session = AuthenticatedWebApplicationSession(
            sessionId = session.id.toString(),
            userId = session.user.id.toString(),
            tenantId = session.organisation.id.toString(),
            webApplicationId = session.webApplication.id.toString(),
            operatorId = operator.id.toString(),
        ),
        user = AuthenticatedUser(
            userIdentityId = session.user.id.toString(),
            displayName = session.user.displayName,
            partyId = session.user.partyId.toString(),
            email = session.user.email,
            emailVerified = session.user.emailVerified,
            nickName = session.user.nickName,
            givenName = session.user.givenName,
            familyName = session.user.familyName,
            pictureUrl = session.user.pictureUrl,
            providerId = session.user.providerId
        ),
    )
}

fun BusinessUnitSession.toBusinessUnitAuthentication() = let { session ->
    BusinessUnitAuthentication(
        providerId = session.user.providerId,
        principalName = session.user.name,
        principalEmail = session.user.email,
        sessionId = session.id.toString(),
        userId = user.id.toString(),
        tenantId = organisation.id.toString(),
        webApplicationId = session.webApplication.id.toString(),
        businessUnitId = session.businessUnitId.toString(),

        organisation = AuthenticatedOrganisation(
            tenantId = organisation.id.toString(),
            primaryPartyId = organisation.primaryPartyId.toString(),
            displayName = organisation.displayName,
            partyId = organisation.partyId?.toString()
        ),
        session = AuthenticatedBusinessUnitSession(
            sessionId = session.id.toString(),
            userId = session.user.id.toString(),
            tenantId = session.organisation.id.toString(),
            businessUnitId = session.businessUnitId.toString(),
            webApplicationId = session.webApplication.id.toString(),
            operatorId = operator.id.toString(),
        ),
        user = AuthenticatedUser(
            userIdentityId = session.user.id.toString(),
            displayName = session.user.displayName,
            partyId = session.user.partyId.toString(),
            email = session.user.email,
            emailVerified = session.user.emailVerified,
            nickName = session.user.nickName,
            givenName = session.user.givenName,
            familyName = session.user.familyName,
            pictureUrl = session.user.pictureUrl,
            providerId = session.user.providerId
        ),
    )
}

fun TenantAuthentication.toBusinessUnitAuthentication(businessUnitSession: BusinessUnitSession) = let { existing ->
    BusinessUnitAuthentication(
        providerId = existing.providerId,
        principalName = existing.principalName,
        principalEmail = existing.principalEmail,
        sessionId = existing.sessionId,
        userId = existing.userId,
        expirationTime = expirationTime,
        tenantId = existing.tenantId,
        webApplicationId = existing.webApplicationId,
        businessUnitId = businessUnitSession.businessUnitId.toString(),
        organisation = existing.organisation,
        session = businessUnitSession.toAuthenticatedBusinessUnitSession(),
        user = existing.user,
    )
}

fun BusinessUnitAuthentication.toBusinessUnitAuthentication(businessUnitSession: BusinessUnitSession) = let { existing ->
    BusinessUnitAuthentication(
        providerId = existing.providerId,
        principalName = existing.principalName,
        principalEmail = existing.principalEmail,
        sessionId = existing.sessionId,
        userId = existing.userId,
        expirationTime = expirationTime,
        tenantId = existing.tenantId,
        webApplicationId = existing.webApplicationId,
        businessUnitId = businessUnitSession.businessUnitId.toString(),
        organisation = existing.organisation,
        session = businessUnitSession.toAuthenticatedBusinessUnitSession(),
        user = existing.user,
    )
}

fun BusinessUnitSession.toAuthenticatedBusinessUnitSession() = let { session ->
    AuthenticatedBusinessUnitSession(
        sessionId = session.id.toString(),
        userId = session.user.id.toString(),
        tenantId = session.organisation.id.toString(),
        webApplicationId = session.webApplication.id.toString(),
        operatorId = operator.id.toString(),
        businessUnitId = session.businessUnitId.toString()
    )
}

fun Authentication.toUserIdentityCreate() =
    UserIdentityCreate(
        uuid = UUID.randomUUID(),
        displayName = attributes.get("name")?.toString(),
        email = attributes.get("email")?.toString() ?: "unknown",
        emailVerified = attributes.get("email_verified")?.let { it as Boolean },
        nickName = attributes.get("nickname")?.toString(),
        givenName = attributes.get("given_name")?.toString(),
        familyName = attributes.get("family_name")?.toString(),
        pictureUrl = attributes.get("picture")?.toString(),
        providerId = name
    )

fun Authentication.toUserIdentityUpdate(id: Long, uuid: UUID): UserIdentityUpdate =
    UserIdentityUpdate(
        id = id,
        uuid = uuid,
        displayName = attributes.get("name")?.toString(),
        email = attributes.get("email")?.toString() ?: "unknown",
        emailVerified = attributes.get("email_verified")?.let { it as Boolean },
        nickName = attributes.get("nickname")?.toString(),
        givenName = attributes.get("given_name")?.toString(),
        familyName = attributes.get("family_name")?.toString(),
        pictureUrl = attributes.get("picture")?.toString(),
        providerId = name
    )

fun JWT.toMultitenantAuthentication(log: Logger, objectMapper: ObjectMapper): DecoratedAuthentication? =
    try {
        val rootNode: JsonNode = objectMapper.readTree(jwtClaimsSet.toString())

        val providerId = rootNode.get("provider_id").asText()
        val principalName = rootNode.get("principal_name").asText()
        val principalEmail = rootNode.get("principal_email").asText()
        val sessionId = rootNode.get("session_id").asText()
        val userId = rootNode.get("user_identity_id").asText()
        val expirationTime = rootNode.toExpirationTime()
        val webApplicationId = rootNode.get("web_application_id")?.asText() ?: "100000001"

        val user = rootNode.toAuthenticatedUser(objectMapper)

        val authenticationType = objectMapper.readValue(
            rootNode.get("authentication_type").toString(),
            AuthenticationType::class.java
        )

        when (authenticationType!!) {
            AuthenticationType.GUEST -> GuestAuthentication(
                providerId = providerId,
                principalName = principalName,
                principalEmail = principalEmail,
                sessionId = sessionId,
                userId = userId,
                expirationTime = expirationTime,
                webApplicationId = webApplicationId,
                session = rootNode.toAuthenticatedGuestSession(objectMapper),
                user = user,
            )

            AuthenticationType.TENANT -> TenantAuthentication(
                providerId = providerId,
                principalName = principalName,
                principalEmail = principalEmail,
                sessionId = sessionId,
                userId = userId,
                expirationTime = expirationTime,
                tenantId = rootNode.get("tenant_id").asText(),
                webApplicationId = webApplicationId,
                organisation = rootNode.toAuthenticatedOrganisation(objectMapper),
                session = rootNode.toAuthenticatedWebApplicationSession(objectMapper),
                user = user,
            )

            AuthenticationType.BUSINESS_UNIT -> BusinessUnitAuthentication(
                providerId = providerId,
                principalName = principalName,
                principalEmail = principalEmail,
                sessionId = sessionId,
                userId = userId,
                expirationTime = expirationTime,
                tenantId = rootNode.get("tenant_id").asText(),
                businessUnitId = rootNode.get("business_unit_id").asText(),
                webApplicationId = webApplicationId,
                organisation = rootNode.toAuthenticatedOrganisation(objectMapper),
                session = rootNode.toAuthenticatedBusinessUnitSession(objectMapper),
                user = user,
            )
        }
    } catch (e: JsonProcessingException) {
        log.error("Error decoding authentication: ${e.message}")
        null
    }

fun JsonNode.toAuthenticatedOrganisation(objectMapper: ObjectMapper): AuthenticatedOrganisation {
    val organisationNode: JsonNode = get("organisation")
    return objectMapper.treeToValue(organisationNode, AuthenticatedOrganisation::class.java)
}

fun JsonNode.toAuthenticatedGuestSession(objectMapper: ObjectMapper): AuthenticatedGuestSession {
    val sessionNode: JsonNode = get("session")
    return objectMapper.treeToValue(sessionNode, AuthenticatedGuestSession::class.java)
}

fun JsonNode.toAuthenticatedBusinessUnitSession(objectMapper: ObjectMapper): AuthenticatedBusinessUnitSession {
    val sessionNode: JsonNode = get("session")
    return objectMapper.treeToValue(sessionNode, AuthenticatedBusinessUnitSession::class.java)
}

fun JsonNode.toAuthenticatedWebApplicationSession(objectMapper: ObjectMapper): AuthenticatedWebApplicationSession {
    val organisationNode: JsonNode = get("session")
    return objectMapper.treeToValue(organisationNode, AuthenticatedWebApplicationSession::class.java)
}

fun JsonNode.toAuthenticatedUser(objectMapper: ObjectMapper): AuthenticatedUser {
    val userNode: JsonNode = get("user")
    return objectMapper.treeToValue(userNode, AuthenticatedUser::class.java)
}

fun JsonNode.toExpirationTime(): Date? {
    val expirationTimeStr = get("expiration_time")?.asText()
    return if (expirationTimeStr != null) {
        try {
            Date.from(Instant.parse(expirationTimeStr))
        } catch (e: Exception) {
            null
        }
    } else {
        null
    }
}

fun HttpRequest<*>.toMultitenantAuthentication(): Optional<DecoratedAuthentication> {
    val attributeValue = attributes.getValue(SecurityFilter.AUTHENTICATION)
    return if (attributeValue != null) {
        Optional.of(attributeValue as DecoratedAuthentication)
    } else {
        Optional.empty()
    }
}


===== ./common/common-kotlin/common-api/common-api-security/src/main/resources/jwks.json =====
{
  "keys": [
    {
      "kty": "RSA",
      "use": "sig",
      "kid": "test-key-id",
      "n": "ANnWlsN92SQIavWlqw3zYJsabKNR_eLW7iA8kbIKGWsUS4FLRgdbGxTUYmncOB6G_EsUUX_POxxC8OO6Q6RsPpoafGDHCoDg_PCS3HTxrs_3VJcwQpeVnlnhgL2L1QOJ2uy-Y8tMlYNXQeMcbNtcF5ZKjNMbLCCjeqs0wnb8cW7pd_CqF5qyN_EbbqAhgZpEiVTO6MY736TasR4Y4VtoPs1DQAgPZz4Wg_Ll0BCsDGhcGFz7ciob3W6gDO6epfsS_9wW_IMTrWw3b6dXPvgkP5uRZDtVg4uiBZlwfWSp77vCA97_pMAdzlFOSwbOEiCThyyUvHQBj9XVzCRadmDIyus=",
      "e": "AQAB"
    }
  ]
}
===== ./common/common-kotlin/common-api/common-api-security/src/main/resources/keystore.jks =====
˛Ì˛Ì          jwt_key  ê›°ÿ.  0Ç˝0
+* ÇÈ#}ˆD.˚74√yJ4r íŸmu˘*ö1]•µ@â˙~|<ﬂTÏﬁÇãB
ÿëâàºA56Ïm=8â˘Ê∑∫ãƒîSπÊÁÆx|x˚qœ]‡'8°Fqõ∆@D	Cºº†<]Ù∏˚+»#¿˘>∫_Ã•˜¬Rdó ˚ê--4ƒ∞9¿ùå'±Àq∞Ãjﬁß[ÉÌBËçx…û°d^yƒ(ÃX>í±7®≈⁄5wïﬂ~VJ‚5Ú„πÎXÁ\]wK‹´ôä2Ê&äÄ
Ú±›¨µXÖ√QËy¡¸kjå∑ZÇ,¯åó[H<ª∆:ÒìÆE1÷Z 6È∂	|ß‡oAtU%ÏtÃØX∆Jò„ää˝QN@°ÄP_‚ /ÛﬁàC'ÿDé_h,äYqZ[Ô]ˇÙ…⁄ﬁPÚÀ±^m˝U¬dV9™}MV®¨∂cLÙ72E◊Üßøëv®Ì‘p%˝Ï`›Æ¥4t¶ë0ÿ~ÅË?ã|π⁄"ÙKJ£Ú¨ù§â;îØ2Ìù÷?◊⁄Bv§µo(Y∆mÀ9œùq4≠'∏£/Øôsù\”ÈOıß≈_—'}µ7¢ÆûV¢:®ı$p˝ví¿ÁÊ?Ëñ\œ|gdGæ˛ƒ:DP_∑Œøúnç_ ~ ˝,x≤}ˆ~,o‡√ûÛÕM!¬VÃÏä;v‚âôD©ù“µ‹õM42®∏ßÀ\èG≥\”R¥É`$átÕÆ®[ëßòí·pŸéÓÌ#ñÿhˇ˜•ﬂ}_yïz†tå#∆°ÅΩ°dlÕèÙd&«eiøå¬Ò!ŸùÄ¨,RÚ‹svC©Ï\¥Ë§¸XÒ“Ú!Ö˚‹~°®nQß#‰ê≈©õ“πz·ﬁÄıguÍL˛o¯DÙ4ﬁÛÊ‰w–Åë¬y,∂+@‹È∏4OÈbD=je´¸˝ÄÙ"8∑D,9ã{@≤™Á∞Ñü63ià°Ï|¥y’ï^ûBÀäût~2Y1õˇ ˜?¿dﬁ…{ugcX·≤YŒ•ë*q˝¿‘¸∆?\"#Q±ÆÉTm€åAZÈ>â\8¨à—€¯oÑ)+ôX∏ì67∏cRïÇûœŒ∑§V¨ê
Êå,Ω”Åˇ •ùBvuo–64 ◊x»”A˚ÓN!Ãn'@—.H0ÚxXQ¬RAi˚+HeÅ{^˜r3,ë.x¥s/z–»IãQéæ–˜⁄™⁄r(nf)w≠XLY'pÂJ,|Ô˜eÒ;m_†G6q9û{å´¨z¡`¨)—ÃL∑ÑÒ1êˆUeÔƒΩLxiQ‡d∂Ã∆	π-Œ5qcétò∂*ôÚóÅF.@ˆö`fßÂ'ã5ÊT
®@ﬁ(’0ıòµ’sRvØj≤Öa}ÕÙÙß˙êrúê`ØH•¥ÉÿK◊ªít€îŒH6F.å;«	\Êu'A3*¬#ÅâF{Ωkœ$E &=ŒÏ≠—¬¸õQ˘/ÇE r ãü  πWMºöåuB“§Eeÿ
ñ…ã3†i@ÓN 9•÷ÛﬂÄ VªÃ%to≠
nîCáÚvXÿAıúX§#xÅ⁄¥°Ûà∫›ÏB)P—4ë-Åõ¢çòJì*¶¿®ÈIâAœ”Ô≈ZçVl7á”§dÔ˙Ÿ¸—ZXÏ    X.509  Ä0Ç|0Çd†	 ≤k˛Ã…_í0	*ÜHÜ˜ 0l10UUnknown10UUnknown10UUnknown10U
Unknown10UUnknown10UUnknown0240723032800Z340721032800Z0l10UUnknown10UUnknown10UUnknown10U
Unknown10UUnknown10UUnknown0Ç"0	*ÜHÜ˜ Ç 0Ç
Ç Ÿ÷ñ√}Ÿ$jı•´Û`õl£Q˝‚÷Ó <ë≤
kKÅKF[‘bi‹8Ü¸KQœ;B„∫C§l>ö|`«
Ä‡¸í‹tÒÆœ˜Tó0BóïûY·ÄΩã’â⁄ÏæcÀLïÉWA„l€\ñJå”, £z´4¬v¸qnÈw™ö≤7Òn†!ÅöDâTŒË∆;ﬂ§⁄±·[h>ÕC@g>ÉÚÂ–¨h\\˚r*›n†Óû•˚ˇ‹¸É≠l7oßW>¯$?õëd;UÉã¢ôp}d©Ôª¬ﬁˇ§¿ŒQNKŒ ìá,îºtè’’Ã$Zv`» Î £!00U˚µMµÿÖ£ÅB	§Gﬁxı¡∂{âº0	*ÜHÜ˜ Ç …1Ó«•iÊîæä⁄ƒåïÏõ≤¬pøçÅa¿‹TØßﬂ%ÁFë%	%zŒ¶M›WâÄ∆AL®˘x®ìh¬g
S{ Áøm˛Û∑≈≈
Ê-¡i7Ò´(K•9¡«ñ7Ú¥Ÿ©0ﬂï˙ñåüÇQájÆqD˘ÙêœÚ˘i^< €Zj˚Ãó„ßîƒ¥Ï”ı†`x~g√™⁄^â4˛ÏMûyô‰l=¬è|ÀqÅ|"´’ˆ Ì/¸‚mÿ÷Ä@÷84*yı≠◊nÁR‡9m˜‰∑L\ÄJx<6ÀÙBÉ6Í çˇ;nÄÕ‘ÚËêzUß\«®&F0uB‘76,T;M$(
ª/¿
9Ö¡sﬁ˚ÀßÆ˜•\]=õ
===== ./common/common-kotlin/common-api/common-api-security/scripts/readme.md =====
# Scripts Directory

This directory contains scripts and utilities to manage keys and certificates for JWT token signing and verification.

## Contents

- `keystore.jks`: The Java KeyStore file containing the RSA key pair.
- `publickey.cert`: The public key certificate exported from the keystore.
- `PublicKeyExtractor.java`: A Java program to extract the public key and generate a `jwks.json` file.
- `PublicKeyExtractor.kt`: A Kotlin version of the program to extract the public key and generate a `jwks.json` file.

## Steps to Generate Keys and Create JWKS File

### 1. Create the Keystore File

Use the following command to generate an RSA key pair and store it in a Java KeyStore (JKS) file:

```sh
keytool -genkeypair -alias test-alias -keyalg RSA -keysize 2048 -keystore keystore.jks -storetype JKS -validity 3650
```

You will be prompted to enter the keystore password and other details.

### 2. Export the Public Key Certificate

Use the following command to export the public key certificate from the keystore to a file:

```sh
keytool -exportcert -alias test-alias -keystore keystore.jks -rfc -file publickey.cert
```

This will create a file named `publickey.cert` containing the public key certificate in PEM format.

### 3. Run the PublicKeyExtractor to Generate JWKS

#### Using Java

1. Compile the `PublicKeyExtractor.java` file:

    ```sh
    javac scripts/PublicKeyExtractor.java
    ```

2. Run the `PublicKeyExtractor` program to generate the `jwks.json` file:

    ```sh
    java -cp scripts PublicKeyExtractor
    ```

#### Using Kotlin

1. Compile the `PublicKeyExtractor.kt` file (if you have a Kotlin version):

    ```sh
    kotlinc scripts/PublicKeyExtractor.kt -include-runtime -d PublicKeyExtractor.jar
    ```

2. Run the `PublicKeyExtractor` program to generate the `jwks.json` file:

    ```sh
    java -jar PublicKeyExtractor.jar
    ```

### 4. Copy the `jwks.json` File

After running the `PublicKeyExtractor`, the `jwks.json` file will be created in the `scripts` directory. Copy this file to your `src/main/resources` directory in your Micronaut project or upload it to a location accessible to your clients.

### Example `application.yml` Configuration

Make sure your `application.yml` file is configured to use the `jwks.json` file:

```yaml
micronaut:
  security:
    token:
      cookie:
        enabled: true
      jwt:
        enabled: true
        signatures:
          jwks-static:
            selfSigned:
              path: "jwks.json"
```

This setup ensures that your Micronaut application can load the JWKS configuration and use it to verify JWT tokens.

## Summary

1. **Create Keystore**: Generate an RSA key pair and store it in a JKS keystore.
2. **Export Public Key**: Export the public key certificate from the keystore.
3. **Generate JWKS**: Run the `PublicKeyExtractor` to create the `jwks.json` file.
4. **Copy JWKS**: Copy the `jwks.json` file to your `src/main/resources` directory or upload it to a location accessible to clients.

===== ./common/common-kotlin/common-api/common-api-security/scripts/publickey.cert =====
-----BEGIN CERTIFICATE-----
MIIDfDCCAmSgAwIBAgIJALIFa/7MyV+SMA0GCSqGSIb3DQEBCwUAMGwxEDAOBgNV
BAYTB1Vua25vd24xEDAOBgNVBAgTB1Vua25vd24xEDAOBgNVBAcTB1Vua25vd24x
EDAOBgNVBAoTB1Vua25vd24xEDAOBgNVBAsTB1Vua25vd24xEDAOBgNVBAMTB1Vu
a25vd24wHhcNMjQwNzIzMDMyODAwWhcNMzQwNzIxMDMyODAwWjBsMRAwDgYDVQQG
EwdVbmtub3duMRAwDgYDVQQIEwdVbmtub3duMRAwDgYDVQQHEwdVbmtub3duMRAw
DgYDVQQKEwdVbmtub3duMRAwDgYDVQQLEwdVbmtub3duMRAwDgYDVQQDEwdVbmtu
b3duMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA2daWw33ZJAhq9aWr
DfNgmxpso1H94tbuIDyRsgoZaxRLgUtGB1sbFNRiadw4Hob8SxRRf887HELw47pD
pGw+mhp8YMcKgOD88JLcdPGuz/dUlzBCl5WeWeGAvYvVA4na7L5jy0yVg1dB4xxs
21wXlkqM0xssIKN6qzTCdvxxbul38KoXmrI38RtuoCGBmkSJVM7oxjvfpNqxHhjh
W2g+zUNACA9nPhaD8uXQEKwMaFwYXPtyKhvdbqAM7p6l+xL/3Bb8gxOtbDdvp1c+
+CQ/m5FkO1WDi6IFmXB9ZKnvu8ID3v+kwB3OUU5LBs4SIJOHLJS8dAGP1dXMJFp2
YMjK6wIDAQABoyEwHzAdBgNVHQ4EFgQU+7VNtdiFo4FCCaRH3nj1wbZ7ibwwDQYJ
KoZIhvcNAQELBQADggEBAMkx7hDHpWnmlL6K2sSMleybshHCcL+NgWHA3FSvGKff
JedGkSXwCQcles6mTd1XiYDGHRNBTKgD+Xiok2jCZwpTGXsA579t/vO3xcUK5i3B
BGk38asoS6U5wceWN/K02QepMB7flQ/6loyfglGHaq5xRPn0kAILDQHP8vlpXjzK
21pq+8yX46eUxLTs0/WgYHh+Z8Oq2l6JNP7sTZ55meRsPcKPfMtxgXwiq9X2yu0H
L/zibdjWgEDWODQqeRwR9a3XCG7nUuA5bffkt0xcgEp4PDbL9EKDNuogGhWN/ztu
gM3U8uiQG3pVp1zHqCZGFDB1Qh3UNzYsVDtNAyQoCg4=
-----END CERTIFICATE-----

===== ./common/common-kotlin/common-api/common-api-security/scripts/PublicKeyExtractor.java =====
import java.io.FileInputStream;
import java.io.FileWriter;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.interfaces.RSAPublicKey;
import java.util.Base64;

public class PublicKeyExtractor {

    public static void main(String[] args) throws Exception {
        String certificateFile = "publickey.cert";
        String keyId = "test-key-id"; // Use a unique key ID

        // Load the public key certificate
        CertificateFactory certFactory = CertificateFactory.getInstance("X.509");
        FileInputStream fis = new FileInputStream(certificateFile);
        X509Certificate cert = (X509Certificate) certFactory.generateCertificate(fis);
        RSAPublicKey publicKey = (RSAPublicKey) cert.getPublicKey();

        // Extract the modulus and exponent
        String modulus = Base64.getUrlEncoder().encodeToString(publicKey.getModulus().toByteArray());
        String exponent = Base64.getUrlEncoder().encodeToString(publicKey.getPublicExponent().toByteArray());

        // Create the JWKS JSON string
        String jwkTemplate = "{\n" +
                "  \"keys\": [\n" +
                "    {\n" +
                "      \"kty\": \"RSA\",\n" +
                "      \"use\": \"sig\",\n" +
                "      \"kid\": \"%s\",\n" +
                "      \"n\": \"%s\",\n" +
                "      \"e\": \"%s\"\n" +
                "    }\n" +
                "  ]\n" +
                "}";
        String jwks = String.format(jwkTemplate, keyId, modulus, exponent);

        // Write the JWKS JSON string to a file
        try (FileWriter file = new FileWriter("jwks.json")) {
            file.write(jwks);
        }

        System.out.println("JWKS JSON file created successfully: jwks.json");
    }
}

===== ./common/common-kotlin/common-api/common-api-security/scripts/PublicKeyExtractor.class =====
 ˛∫æ   4 z
  2 3 4 5
 6 7 8
  9
 6 : ;
 	 < =
 > ?  @
 A B
 C D  E F G
 H I J K
  9
  L
  M N
  O	 P Q R
 S T U <init> ()V Code LineNumberTable main ([Ljava/lang/String;)V StackMapTable V W X 8 ; = J N 
Exceptions Y 
SourceFile PublicKeyExtractor.java    publickey.cert test-key-id X.509 X Z [ java/io/FileInputStream  \ ] ^ "java/security/cert/X509Certificate _ ` %java/security/interfaces/RSAPublicKey a b e f g h i j k l m n g {{
  "keys": [
    {
      "kty": "RSA",
      "use": "sig",
      "kid": "%s",
      "n": "%s",
      "e": "%s"
    }
  ]
} java/lang/Object W o p java/io/FileWriter 	jwks.json q \ r   java/lang/Throwable s t u v w .JWKS JSON file created successfully: jwks.json x y \ PublicKeyExtractor [Ljava/lang/String; java/lang/String %java/security/cert/CertificateFactory java/lang/Exception getInstance ;(Ljava/lang/String;)Ljava/security/cert/CertificateFactory; (Ljava/lang/String;)V generateCertificate 7(Ljava/io/InputStream;)Ljava/security/cert/Certificate; getPublicKey ()Ljava/security/PublicKey; java/util/Base64 getUrlEncoder Encoder InnerClasses ()Ljava/util/Base64$Encoder; 
getModulus ()Ljava/math/BigInteger; java/math/BigInteger toByteArray ()[B java/util/Base64$Encoder encodeToString ([B)Ljava/lang/String; getPublicExponent format 9(Ljava/lang/String;[Ljava/lang/Object;)Ljava/lang/String; write close addSuppressed (Ljava/lang/Throwable;)V java/lang/System out Ljava/io/PrintStream; java/io/PrintStream println !             !        *∑ ±    "        	 # $  !       ·LM∏ Nª Y+∑ :-∂ ¿ 	:∂ 
¿ :∏ π  ∂ ∂ :∏ π  ∂ ∂ ::		Ω Y,SYSYS∏ :
ª Y∑ ::
∂ ∆ U∆ ∂ ß H:∂ ß <∂ ß 4::ø:∆ !∆ ∂ ß :∂ ß ∂ ø≤ ∂ ±  ã ê ì  z Å ß  z Å ∞   º ¡ ƒ  ß ≤ ∞    "   F             !  +  =  O  S $ l ' z ( Å ) ß ' ∞ ) ÿ + ‡ , %   õ ˇ ì  & ' ' ( ) * + ' ' ' ' , -  -G -H -ˇ   & ' ' ( ) * + ' ' ' ' , -  -  -ˇ   & ' ' ( ) * + ' ' ' '   .     /  0    1 d   
  C > c 	
===== ./common/common-kotlin/common-api/common-api-security/build.gradle.kts =====
plugins {
   alias(libs.plugins.jvm)
   alias(libs.plugins.kapt)
   alias(libs.plugins.allopen)
   alias(libs.plugins.jpa)
   alias(libs.plugins.shadow)
   alias(libs.plugins.application)
}

repositories {
    mavenCentral()
}

dependencies {
    api(project(":common:common-kotlin:common-api:common-api-model"))

    implementation(platform("io.micronaut.platform:micronaut-platform"))
    implementation(platform("aws.sdk.kotlin:bom:1.4.92"))
    kapt(annotationProcessorLibs.bundles.commonAnnotationProcessors)
    implementation(libs.bundles.commonLibs)
    implementation(libs.bundles.webServiceLibs)
    compileOnly(libs.bundles.compileOnlyLibs)

    implementation("io.micronaut.security:micronaut-security")
    implementation("com.nimbusds:nimbus-jose-jwt")

    implementation(testLibs.bundles.testImplementationLibs) {
        exclude(group = "org.slf4j", module = "slf4j-api")
    }
}
java {
    sourceCompatibility = JavaVersion.toVersion("17")
}
kapt {
    arguments {
        arg("micronaut.openapi.project.dir", projectDir.toString())
    }
}
kotlin {
    jvmToolchain {
        languageVersion.set(JavaLanguageVersion.of(17))
    }
}

graalvmNative.toolchainDetection = false
micronaut {
    runtime("netty")
    testRuntime("junit5")
    processing {
        incremental(true)
        annotations("net.blugrid.api.*")
    }
}

application {
    mainClass.set("net.blugrid.api.ApplicationKt")
}

===== ./common/common-kotlin/common-api/common-api-test/src/main/kotlin/net/blugrid/api/test/factory/RandomInstanceFactory.kt =====
package net.blugrid.api.test.factory

import java.time.LocalDate
import java.time.LocalDateTime
import java.time.LocalTime
import java.util.UUID
import kotlin.random.Random
import kotlin.reflect.KClass
import kotlin.reflect.KType
import kotlin.reflect.KTypeParameter
import kotlin.reflect.full.isSubclassOf
import kotlin.reflect.typeOf

// Copied from https://blog.kotlin-academy.com/creating-a-random-instance-of-any-class-in-kotlin-b6168655b64a
inline fun <reified T : Any> randomInstance(
    random: Random = Random,
    config: randomInstanceConfig = randomInstanceConfig()
): T {
    val producer = RandomInstanceProducer(random, config)
    return producer.makeRandomInstance(T::class, typeOf<T>()) as T
}

class NoUsableConstructor : Error()

class randomInstanceConfig(
    var possibleCollectionSizes: IntRange = 1..5,
    var possibleStringSizes: IntRange = 1..10,
    var any: Any = "Anything"
)

class RandomInstanceProducer(
    private val random: Random,
    private val config: randomInstanceConfig
) {

    private fun makeRandomInstanceForParam(paramType: KType, classRef: KClass<*>, type: KType): Any {
        return when (val classifier = paramType.classifier) {
            is KClass<*> -> makeRandomInstance(classifier, paramType)
            is KTypeParameter -> {
                val typeParameterName = classifier.name
                val typeParameterId = classRef.typeParameters.indexOfFirst { it.name == typeParameterName }
                val parameterType = type.arguments[typeParameterId].type ?: typeOf<Any>()
                makeRandomInstance(parameterType.classifier as KClass<*>, parameterType)
            }

            else -> throw Error("Type of the classifier $classifier is not supported")
        }
    }

    fun makeRandomInstance(classRef: KClass<*>, type: KType): Any {
        val primitive = makeStandardInstanceOrNull(classRef, type)
        if (primitive != null) {
            return primitive
        }

        val constructors = classRef.constructors.shuffled(random)

        for (constructor in constructors) {
            try {
                val arguments = constructor.parameters
                    .map { makeRandomInstanceForParam(it.type, classRef, type) }
                    .toTypedArray()

                return constructor.call(*arguments)
            } catch (e: Throwable) {
                e.printStackTrace()
                // no-op. We catch any possible error here that might occur during class creation
            }
        }

        throw NoUsableConstructor()
    }

    @Suppress("IMPLICIT_CAST_TO_ANY", "TYPE_MISMATCH_WARNING")
    private fun makeStandardInstanceOrNull(classRef: KClass<*>, type: KType) = when (classRef) {
        Any::class -> config.any
        Boolean::class -> true
        Char::class -> makeRandomChar(random)
        Double::class -> random.nextDouble()
        Float::class -> random.nextFloat()
        Int::class -> random.nextInt()
        List::class, Collection::class -> makeRandomList(classRef, type)
        LocalDate::class -> LocalDate.now()
        LocalTime::class -> LocalTime.now()
        LocalDateTime::class -> LocalDateTime.now()
        Long::class -> random.nextLong()
        Map::class -> makeRandomMap(classRef, type)
        Set::class -> makeRandomSet(classRef, type)
        Short::class -> random.nextInt().toShort()
        String::class -> makeRandomString(random)
        UUID::class -> UUID.randomUUID()
        else -> if (classRef.isSubclassOf(Enum::class)) {
            makeRandomEnum(classRef, random)
        } else {
            null
        }
    }

    private fun makeRandomEnum(classRef: KClass<*>, random: Random): Any? {
        val values: Array<out Any>? = classRef.java.enumConstants
        return values?.get(random.nextInt(values.size))
    }

    private fun makeRandomList(classRef: KClass<*>, type: KType): List<Any?> {
        val numOfElements = random.nextInt(config.possibleCollectionSizes.start, config.possibleCollectionSizes.endInclusive + 1)
        val elemType = type.arguments[0].type!!
        return (1..numOfElements)
            .map { makeRandomInstanceForParam(elemType, classRef, type) }
    }

    private fun makeRandomSet(classRef: KClass<*>, type: KType): Set<Any?> {
        val numOfElements = random.nextInt(config.possibleCollectionSizes.start, config.possibleCollectionSizes.endInclusive + 1)
        val elemType = type.arguments[0].type!!
        return (1..numOfElements)
            .map { makeRandomInstanceForParam(elemType, classRef, type) }
            .toSet()
    }

    private fun makeRandomMap(classRef: KClass<*>, type: KType): Map<Any?, Any?> {
        val numOfElements = random.nextInt(config.possibleCollectionSizes.start, config.possibleCollectionSizes.endInclusive + 1)
        val keyType = type.arguments[0].type!!
        val valType = type.arguments[1].type!!
        val keys = (1..numOfElements)
            .map { makeRandomInstanceForParam(keyType, classRef, type) }
        val values = (1..numOfElements)
            .map { makeRandomInstanceForParam(valType, classRef, type) }
        return keys.zip(values).toMap()
    }

    private fun makeRandomChar(random: Random) = ('A'..'z').random(random)
    private fun makeRandomString(random: Random) =
        (1..random.nextInt(config.possibleStringSizes.start, config.possibleStringSizes.endInclusive + 1))
            .map { makeRandomChar(random) }
            .joinToString(separator = "") { "$it" }
}

inline fun <reified T : Enum<T>> randomEnum(
    random: Random = Random,
): T {
    val reg = RandomEnumGenerator(T::class.java, random)
    return reg.randomEnum()
}

class RandomEnumGenerator<T : Enum<T>>(e: Class<T>, private val random: Random = Random) {
    private val values: Array<T>

    init {
        values = e.enumConstants
    }

    fun randomEnum(): T {
        return values[random.nextInt(values.size)]
    }
}

===== ./common/common-kotlin/common-api/common-api-test/src/main/kotlin/net/blugrid/api/test/factory/GenericResourceFactory.kt =====
package net.blugrid.api.test.factory

interface GenericResourceFactory<T> {

    fun create(): T

    fun update(source: T, update: T): T
}

===== ./common/common-kotlin/common-api/common-api-test/src/main/kotlin/net/blugrid/api/test/support/GrpcTestDsl.kt =====
package net.blugrid.api.test.support

import io.grpc.kotlin.AbstractCoroutineStub

suspend fun <T : AbstractCoroutineStub<T>> grpc(
    stub: T,
    block: suspend GrpcTestDsl<T>.() -> Unit
) = GrpcTestDsl(stub).block()

class GrpcTestDsl<T : AbstractCoroutineStub<T>>(
    private val stub: T
) {
    suspend fun <Req, Res> create(
        request: Req,
        call: suspend T.(Req) -> Res
    ): Res = stub.call(request)

    suspend fun <Req, Res> getById(
        request: Req,
        call: suspend T.(Req) -> Res
    ): Res = stub.call(request)

    suspend fun <Req, Res> update(
        request: Req,
        call: suspend T.(Req) -> Res
    ): Res = stub.call(request)

    suspend fun <Req> delete(
        request: Req,
        call: suspend T.(Req) -> Unit
    ) = stub.call(request)
}

===== ./common/common-kotlin/common-api/common-api-test/src/main/kotlin/net/blugrid/api/test/support/TestNetwork.kt =====
package net.blugrid.api.test.support

import org.testcontainers.containers.Network

object TestNetwork {
    val network: Network = Network.newNetwork()
}


===== ./common/common-kotlin/common-api/common-api-test/src/main/kotlin/net/blugrid/api/test/support/BaseIntegTest.kt =====
package net.blugrid.api.test.support

import io.micronaut.test.extensions.junit5.annotation.MicronautTest
import org.junit.jupiter.api.TestInstance

@MicronautTest(environments = ["debug-logging", "json", "security", "db"])
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
abstract class BaseIntegTest

===== ./common/common-kotlin/common-api/common-api-test/src/main/kotlin/net/blugrid/api/test/support/BaseGrpcIntegTest.kt =====
package net.blugrid.api.test.support

import io.grpc.ManagedChannel
import io.grpc.ManagedChannelBuilder
import io.grpc.kotlin.AbstractCoroutineStub
import io.micronaut.grpc.server.GrpcServerConfiguration
import io.micronaut.test.extensions.junit5.annotation.MicronautTest
import io.micronaut.test.support.TestPropertyProvider
import jakarta.inject.Inject
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.runBlocking
import net.blugrid.api.logging.logger
import org.junit.jupiter.api.BeforeAll
import org.junit.jupiter.api.TestInstance

@MicronautTest(environments = ["debug-logging", "json", "security", "db"])
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
abstract class BaseGrpcIntegTest : PostgresTestSupport, TestPropertyProvider {

    protected val log = logger()

    @Inject
    lateinit var grpcConfig: GrpcServerConfiguration

    protected lateinit var channel: ManagedChannel

    @BeforeAll
    fun setupChannel() {
        PostgresTestSupport.ensureStarted()
        log.info("PostgreSQL Testcontainer started on ${PostgresTestSupport.postgresContainer.host}:${PostgresTestSupport.postgresContainer.getMappedPort(5432)}")

        val port = grpcConfig.serverPort
        log.info("gRPC Embedded server started on port: $port")

        channel = ManagedChannelBuilder
            .forAddress("127.0.0.1", port)
            .usePlaintext()
            .build()
    }

    override fun getProperties(): Map<String, String> = buildMap {
        putAll(PostgresTestSupport.testProperties)
    }

    /**
     * Returns a coroutine-based gRPC stub for the given gRPC stub factory.
     *
     * Usage: `val stub = createStub(::OrganisationServiceCoroutineStub)`
     */
    protected fun <T : AbstractCoroutineStub<T>> createStub(factory: (ManagedChannel) -> T): T {
        return factory(channel)
    }

    /**
     * Runs a coroutine block in the test scope (alias for runBlocking).
     */
    protected fun <T> runGrpcTest(block: suspend CoroutineScope.() -> T): T = runBlocking { block() }
}

===== ./common/common-kotlin/common-api/common-api-test/src/main/kotlin/net/blugrid/api/test/support/ConsulTestSupport.kt =====
package net.blugrid.api.test.support

import net.blugrid.api.logging.logger
import org.testcontainers.containers.GenericContainer
import org.testcontainers.utility.DockerImageName


interface ConsulTestSupport {

    companion object {
        const val NETWORK_ALIAS = "consul"
        const val INTERNAL_PORT = 8500
        private val log = logger()

        @JvmStatic
        val consulContainer: GenericContainer<*> by lazy {
            GenericContainer(
                DockerImageName.parse("hashicorp/consul:1.15")
            ).apply {
                withExposedPorts(INTERNAL_PORT)
                withCommand("agent", "-dev", "-client=0.0.0.0")
                withNetwork(TestNetwork.network)
                withNetworkAliases(NETWORK_ALIAS)
                withReuse(true)
                start()
                log.info("üöÄ Consul container started on external port {}", firstMappedPort)
            }
        }

        fun ensureStarted() {
            consulContainer
        }

        val internalHost: String = NETWORK_ALIAS
        val internalPort: Int = INTERNAL_PORT

        val externalHost: String
            get() = consulContainer.host

        val externalPort: Int
            get() = consulContainer.getMappedPort(INTERNAL_PORT)

        val testProperties: Map<String, String> = mapOf(
            "CONSUL_HOST" to consulContainer.host,
            "CONSUL_PORT" to consulContainer.getMappedPort(8500).toString(),
            "consul.client.defaultZone" to "http://${consulContainer.host}:${consulContainer.getMappedPort(8500)}",
            "consul.client.registration.enabled" to "true",
        )
    }
}

===== ./common/common-kotlin/common-api/common-api-test/src/main/kotlin/net/blugrid/api/test/support/DockerHostIpSupport.kt =====
package net.blugrid.api.test.support

object DockerHostIpSupport {

    const val ENV_KEY = "DOCKER_HOST_IP"
    const val DEFAULT_IP = "10.200.10.1"

    val ip: String by lazy {
        System.getenv(ENV_KEY)
            ?.takeIf { it.isNotBlank() }
            ?: DEFAULT_IP
    }

    val url: String get() = "http://$ip"

    fun toEnv(): Map<String, String> = mapOf(
        ENV_KEY to ip,
    )
}

===== ./common/common-kotlin/common-api/common-api-test/src/main/kotlin/net/blugrid/api/test/support/PostgresTestSupport.kt =====
package net.blugrid.api.test.support

import kotlinx.coroutines.runBlocking
import net.blugrid.api.logging.logger
import net.blugrid.api.test.support.GrpcServerTestSupport.Companion.grpcContainer
import org.testcontainers.containers.PostgreSQLContainer
import org.testcontainers.utility.DockerImageName


interface PostgresTestSupport {

    companion object {
        const val DATABASE_NAME = "bizkinetics"
        const val USERNAME = "postgres"
        const val PASSWORD = "password"
        const val SCHEMA = "public"
        const val NETWORK_ALIAS = "postgres"
        const val INTERNAL_PORT = 5432
        const val MAX_CONNCETIONS = 1000

        private val log = logger()

        init {
            runBlocking {
                EcrDockerLoginHelper.loginToEcr()
            }
        }

        val postgresContainer: PostgreSQLContainer<*> = PostgreSQLContainer(
            DockerImageName.parse("453360777153.dkr.ecr.ap-southeast-2.amazonaws.com/blugrid/docker-postgresql:latest")
                .asCompatibleSubstituteFor("postgres")
        )
            .apply {
                withEnv("POSTGRES_USER", USERNAME)
                withEnv("POSTGRES_PASSWORD", PASSWORD)
                withEnv("POSTGRES_MULTIPLE_DATABASES", DATABASE_NAME)
                withUsername(USERNAME)
                withPassword(PASSWORD)
                withCommand("postgres", "-c", "max_connections=$MAX_CONNCETIONS")
                withNetwork(TestNetwork.network)
                withNetworkAliases(NETWORK_ALIAS)
                withReuse(true)
                start()
                log.info("üöÄ PostgreSQL container started on external port {}", INTERNAL_PORT)
            }

        val internalHost = NETWORK_ALIAS
        val internalPort = INTERNAL_PORT

        val externalHost: String
            get() = postgresContainer.host

        val externalPort: Int
            get() = postgresContainer.firstMappedPort

        val testProperties: Map<String, String> = mapOf(
            "datasources.default.url" to "jdbc:postgresql://${postgresContainer.host}:${postgresContainer.firstMappedPort}/$DATABASE_NAME",
            "datasources.default.username" to "postgres",
            "datasources.default.password" to "password",
            "env.db.schema" to SCHEMA,
            "POSTGRES_HOST_1" to postgresContainer.host,
            "POSTGRES_PORT_1" to postgresContainer.firstMappedPort.toString(),
            "POSTGRES_DB_1" to DATABASE_NAME,
            "POSTGRES_USERNAME_1" to "postgres",
            "POSTGRES_PASSWORD_1" to "password"
        )

        fun ensureStarted() {
            postgresContainer
        }
    }
}

===== ./common/common-kotlin/common-api/common-api-test/src/main/kotlin/net/blugrid/api/test/support/BaseServiceIntegTest.kt =====
package net.blugrid.api.test.support

import io.micronaut.test.extensions.junit5.annotation.MicronautTest
import io.micronaut.test.support.TestPropertyProvider
import net.blugrid.api.test.support.PostgresTestSupport.Companion.DATABASE_NAME
import net.blugrid.api.test.support.PostgresTestSupport.Companion.SCHEMA
import net.blugrid.api.test.support.PostgresTestSupport.Companion.postgresContainer
import org.junit.jupiter.api.TestInstance

@MicronautTest(
    environments = ["debug-logging", "json", "security", "db"],
    startApplication = false,
    transactional = true
)
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
abstract class BaseServiceIntegTest : PostgresTestSupport, TestPropertyProvider {

    override fun getProperties(): Map<String, String> = buildMap {
        putAll(PostgresTestSupport.testProperties)
    }
}

===== ./common/common-kotlin/common-api/common-api-test/src/main/kotlin/net/blugrid/api/test/support/EcrDockerLoginHelper.kt =====
package net.blugrid.api.test.support

import aws.sdk.kotlin.services.ecr.EcrClient
import aws.sdk.kotlin.services.ecr.model.GetAuthorizationTokenRequest
import java.util.Base64

object EcrDockerLoginHelper {

    suspend fun loginToEcr(region: String = "ap-southeast-2") {
        val ecrClient = EcrClient { this.region = region }

        val response = ecrClient.getAuthorizationToken(GetAuthorizationTokenRequest {})
        val authData = response.authorizationData?.firstOrNull()
            ?: throw IllegalStateException("No ECR authorization data received")

        val decoded = String(Base64.getDecoder().decode(authData.authorizationToken))
        val (username, password) = decoded.split(":")

        val registry = authData.proxyEndpoint?.removePrefix("https://")
            ?: throw IllegalStateException("Missing proxy endpoint in ECR response")

        println("üîê Logging in to Docker registry: $registry")
        val process = ProcessBuilder(
            "docker", "login",
            "--username", username,
            "--password", password,
            registry
        ).inheritIO().start()

        val exitCode = process.waitFor()
        if (exitCode != 0) {
            throw RuntimeException("‚ùå Docker login to ECR failed with exit code $exitCode")
        }

        println("‚úÖ Docker login successful")
    }
}

===== ./common/common-kotlin/common-api/common-api-test/src/main/kotlin/net/blugrid/api/test/support/GrpcClientTestSupport.kt =====
package net.blugrid.api.test.support

import io.grpc.ManagedChannel
import io.grpc.ManagedChannelBuilder
import io.grpc.kotlin.AbstractCoroutineStub
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.runBlocking
import net.blugrid.api.logging.logger

interface GrpcClientTestSupport {
    val grpcHost: String get() = System.getProperty("grpc.test.host", "127.0.0.1")
    val grpcPort: Int get() = System.getProperty("grpc.test.port")?.toIntOrNull() ?: 50051

    val log get() = logger()

    val channel: ManagedChannel
        get() = ManagedChannelBuilder
            .forAddress(grpcHost, grpcPort)
            .usePlaintext()
            .build()

    fun <T : AbstractCoroutineStub<T>> createStub(factory: (ManagedChannel) -> T): T = factory(channel)

    fun <T> runGrpcTest(name: String = "anonymous", block: suspend CoroutineScope.() -> T): T = runBlocking {
        try {
            log.info("‚ñ∂Ô∏è  Running gRPC test: $name")
            block()
        } catch (ex: Throwable) {
            log.error("‚ùå gRPC test '$name' failed: ${ex.message}", ex)
            throw ex
        }
    }
}

===== ./common/common-kotlin/common-api/common-api-test/src/main/kotlin/net/blugrid/api/test/support/GrpcServerTestSupport.kt =====
package net.blugrid.api.test.support

import net.blugrid.api.logging.logger
import org.testcontainers.containers.GenericContainer
import org.testcontainers.containers.wait.strategy.Wait
import org.testcontainers.utility.DockerImageName

interface GrpcServerTestSupport {

    companion object {
        private val log = logger()
        private const val GRPC_IMAGE_TAG = "core-organisation-api-grpc:local"
        private const val GRPC_INTERNAL_PORT = 50051
        private const val HTTP_HEALTH_PORT = 8080
        private const val GRPC_NETWORK_ALIAS = "organisation-grpc"

        @JvmStatic
        val grpcContainer: GenericContainer<*> by lazy {
            GenericContainer(DockerImageName.parse(GRPC_IMAGE_TAG))
                .withEnv("MICRONAUT_ENVIRONMENTS", "test,debug-logging,json,security,db")
                // Inject Postgres connection info
                .withEnv("POSTGRES_HOST_1", PostgresTestSupport.internalHost)
                .withEnv("POSTGRES_PORT_1", PostgresTestSupport.internalPort.toString())

                // Inject Consul discovery info
                .withEnv("CONSUL_HOST", ConsulTestSupport.internalHost)
                .withEnv("CONSUL_PORT", ConsulTestSupport.internalPort.toString())
                // Enable Micronaut HTTP server + health endpoint
                .withEnv("MICRONAUT_SERVER_PORT", HTTP_HEALTH_PORT.toString())
//                .withEnv("MICRONAUT_SERVER_HOST", "0.0.0.0")
                .withEnv("ENDPOINTS_ALL_ENABLED", "true")
                .withEnv("ENDPOINTS_ALL_SENSITIVE", "false")
                .withEnv("ENDPOINTS_HEALTH_ENABLED", "true")
                .withEnv("ENDPOINTS_HEALTH_SENSITIVE", "false")
                .withEnv("CONSUL_CLIENT_REGISTRATION_IP_ADDR", DockerHostIpSupport.ip)
                .withEnv("DOCKER_HOST_IP", DockerHostIpSupport.ip)

                .withExposedPorts(GRPC_INTERNAL_PORT, HTTP_HEALTH_PORT)
                .withNetwork(TestNetwork.network)
                .withNetworkAliases(GRPC_NETWORK_ALIAS)
                .waitingFor(
                    Wait
                        .forHttp("/admin/health")
                        .forPort(8080)
                        .forStatusCode(200)
                )
                .apply {
                    start()
                    log.info("üöÄ gRPC container started on external port {}", GRPC_INTERNAL_PORT)
                }
        }

        fun ensureStarted() {
            grpcContainer
        }

        val internalHost = GRPC_NETWORK_ALIAS
        val internalPort = GRPC_INTERNAL_PORT

        val externalHost: String
            get() = grpcContainer.host

        val externalPort: Int
            get() = grpcContainer.getMappedPort(GRPC_INTERNAL_PORT)
    }
}

===== ./common/common-kotlin/common-api/common-api-test/src/main/kotlin/net/blugrid/api/test/support/BaseControllerIntegTest.kt =====
package net.blugrid.api.test.support

import io.github.serpro69.kfaker.faker
import io.micronaut.core.type.Argument
import io.micronaut.data.model.Page
import io.micronaut.data.model.Pageable
import io.micronaut.http.HttpRequest
import io.micronaut.http.client.HttpClient
import io.micronaut.http.client.annotation.Client
import io.micronaut.runtime.server.EmbeddedServer
import io.micronaut.test.extensions.junit5.annotation.MicronautTest
import io.netty.handler.codec.http.HttpResponseStatus
import jakarta.inject.Inject
import net.blugrid.api.common.model.resource.GenericCreateResource
import net.blugrid.api.common.model.resource.GenericResource
import net.blugrid.api.common.model.resource.GenericUpdateResource
import net.blugrid.api.common.organisation.pageOf
import net.blugrid.api.logging.logger
import org.hamcrest.CoreMatchers
import org.hamcrest.MatcherAssert
import org.junit.jupiter.api.BeforeAll
import org.junit.jupiter.api.TestInstance

@MicronautTest(environments = ["debug-logging", "json", "security", "db"])
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
abstract class BaseControllerIntegTest(
    open val baseUri: String,
) : PostgresTestSupport {

    val log = logger()

    @Inject
    @field:Client("/")
    protected lateinit var client: HttpClient

    @Inject
    lateinit var embeddedServer: EmbeddedServer

    @BeforeAll
    fun logPort() {
        log.info("Embedded server started on port: ${embeddedServer.port}")
    }

    protected val faker = faker {}

    fun <T : GenericResource<out Any>> assertCreate(createPayload: GenericCreateResource<out Any>, responseType: Class<T>, uri: String = baseUri): T {
        return create(createPayload = createPayload, responseType = responseType, uri = uri)
    }

    fun <T : GenericResource<out Any>> create(
        createPayload: GenericCreateResource<out Any>,
        responseType: Class<T>,
        uri: String = baseUri
    ): T {
        return with(
            client.toBlocking()
                .exchange(
                    HttpRequest.PUT(uri, createPayload),
                    responseType,
                ),
        ) {
            MatcherAssert.assertThat(status.code, CoreMatchers.equalTo(HttpResponseStatus.OK.code()))
            body.get()
        }
    }

    fun <T : GenericResource<out Any>> assertUpdate(updatePayload: GenericUpdateResource<out Any>, responseType: Class<T>, uri: String = baseUri): T {
        return update(updatePayload = updatePayload, responseType = responseType, uri = uri)
    }

    fun <T : GenericResource<out Any>> update(updatePayload: GenericUpdateResource<out Any>, responseType: Class<T>, uri: String = baseUri): T {
        return with(
            receiver = client.toBlocking()
                .exchange(
                    HttpRequest.POST("$uri/${updatePayload.id}", updatePayload),
                    Argument.of(responseType),
                ),
        ) {
            MatcherAssert.assertThat(status.code, CoreMatchers.equalTo(HttpResponseStatus.OK.code()))
            body.get()
        }
    }

    fun <T : GenericResource<out Any>> assertGetById(
        createPayload: GenericCreateResource<out Any>,
        responseType: Class<T>,
        uri: String = baseUri
    ): T {
        val newResource = create(createPayload, responseType)
        return getById(id = newResource.id, responseType = responseType, uri = uri)
    }

    fun <T : GenericResource<out Any>> getById(id: Long, responseType: Class<T>, uri: String = baseUri): T {
        return with(
            receiver = client.toBlocking()
                .exchange(
                    HttpRequest.GET<Unit>("$uri/${id}"),
                    Argument.of(responseType),
                ),
        ) {
            MatcherAssert.assertThat(status.code, CoreMatchers.equalTo(HttpResponseStatus.OK.code()))
            body.get()
        }
    }

    fun <T : GenericResource<out Any>> assertGetPage(
        resources: List<GenericCreateResource<out Any>>,
        pageable: Pageable,
        responseType: Class<T>,
        uri: String = baseUri
    ): Page<T> {
        resources.forEach {
            assertCreate(it, responseType)
        }
        return getPage(pageable = pageable, responseType = responseType, uri = uri)
    }

    fun <T : GenericResource<out Any>> getPage(pageable: Pageable, responseType: Class<T>, uri: String = baseUri): Page<T> {
        return with(
            receiver = client.toBlocking()
                .exchange(
                    HttpRequest.POST(uri, pageable),
                    pageOf(responseType),
                ),
        ) {
            MatcherAssert.assertThat(status.code, CoreMatchers.equalTo(HttpResponseStatus.OK.code()))
            body.get()
        }
    }

    fun <T : GenericResource<out Any>> assertDelete(createPayload: GenericCreateResource<out Any>, responseType: Class<T>, uri: String = baseUri) {
        val newResource = assertCreate(createPayload, responseType)
        delete(id = newResource.id, uri = uri)
    }

    fun delete(id: Long, uri: String = baseUri) {
        with(
            receiver = client.toBlocking()
                .exchange(
                    HttpRequest.DELETE<Void>("$uri/$id"),
                    Argument.of(Void::class.java),
                ),
        ) {
            MatcherAssert.assertThat(status.code, CoreMatchers.equalTo(HttpResponseStatus.OK.code()))
        }
    }
}

===== ./common/common-kotlin/common-api/common-api-test/src/main/kotlin/net/blugrid/api/test/support/BaseGrpcClientIntegTest.kt =====
package net.blugrid.api.test.support

import io.micronaut.test.extensions.junit5.annotation.MicronautTest
import io.micronaut.test.support.TestPropertyProvider
import org.junit.jupiter.api.BeforeAll
import org.junit.jupiter.api.TestInstance
@MicronautTest(environments = ["debug-logging", "json", "security", "db"])
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
abstract class BaseGrpcClientIntegTest :
    BaseIntegTest(),
    ConsulTestSupport,
    PostgresTestSupport,
    GrpcClientTestSupport,
    GrpcServerTestSupport,
    TestPropertyProvider {

    @BeforeAll
    fun ensureGrpcContainerRunning() {
        ConsulTestSupport.ensureStarted()
        GrpcServerTestSupport.ensureStarted()
        log.info("üîç gRPC container is running: ${GrpcServerTestSupport.grpcContainer.isRunning}")
    }

    override fun getProperties(): Map<String, String> = buildMap {
        putAll(PostgresTestSupport.testProperties)
        putAll(ConsulTestSupport.testProperties)
    }
}


===== ./common/common-kotlin/common-api/common-api-test/src/main/kotlin/net/blugrid/api/test/support/TestcontainersBootstrap.kt =====
package net.blugrid.api.test.support

import kotlinx.coroutines.runBlocking

object TestcontainersBootstrap {
    private var bootstrapped = false

    fun ensureStarted() {
        if (bootstrapped) return
        bootstrapped = true

        runBlocking {
            EcrDockerLoginHelper.loginToEcr()
        }
    }
}

===== ./common/common-kotlin/common-api/common-api-test/src/main/kotlin/net/blugrid/api/test/security/TestAuthFilter.kt =====
package net.blugrid.api.test.security

import io.micronaut.context.annotation.Requires
import io.micronaut.context.env.Environment
import io.micronaut.http.HttpResponse
import io.micronaut.http.MutableHttpRequest
import io.micronaut.http.annotation.Filter
import io.micronaut.http.filter.ClientFilterChain
import io.micronaut.http.filter.HttpClientFilter
import io.micronaut.http.filter.ServerFilterPhase
import net.blugrid.api.security.config.SecurityProps
import net.blugrid.api.logging.logger
import net.blugrid.api.security.jwt.applyCookies
import net.blugrid.api.security.jwt.toCookie
import org.reactivestreams.Publisher

@Requires(env = [Environment.TEST])
@Filter("/**")
internal class TestAuthFilter(
    private val cookieSecurityProps: SecurityProps.CookieConfig,
) : HttpClientFilter {

    private val log = logger()

    companion object {
        var JWT_TOKEN: String = ""
    }

    override fun doFilter(request: MutableHttpRequest<*>, chain: ClientFilterChain): Publisher<out HttpResponse<*>>? {
        if (request.isServiceRequest()) {
            log.debug("Adding JWT cookies to request: $request")
            request.applyCookies(
                listOf(
                    JWT_TOKEN.toCookie(cookieSecurityProps.jwt, 3000000),
                ),
            )
        } else {
            log.debug("Skip adding JWT cookies to request: $request")
        }
        return chain.proceed(request)
    }

    override fun getOrder(): Int = ServerFilterPhase.FIRST.order()
}

private fun MutableHttpRequest<*>.isServiceRequest(): Boolean =
    attributes.getValue("micronaut.http.serviceId").let {
        it != null && it !== "consul"
    }

===== ./common/common-kotlin/common-api/common-api-test/src/main/kotlin/net/blugrid/api/test/security/TestApplicationContext.kt =====
package net.blugrid.api.test.security

import net.blugrid.api.security.authentication.model.AuthenticatedBusinessUnitSession
import net.blugrid.api.security.authentication.model.AuthenticatedOrganisation
import net.blugrid.api.security.authentication.model.AuthenticatedUser
import net.blugrid.api.security.authentication.model.AuthenticatedWebApplicationSession
import net.blugrid.api.security.authentication.model.AuthenticationType
import net.blugrid.api.security.jwt.factory.AccessTokenFactory
import net.blugrid.api.security.jwt.model.JwtToken
import net.blugrid.api.test.security.TestAuthFilter.Companion

object TestApplicationContext {

    fun configureTenantApplicationContext(
        tenantId: Long = 1L,
        sessionId: Long = 1L,
        userIdentityId: Long = 1L,
        webApplicationId: Long = 1L,
        operatorId: Long = 1L
    ) {
        val organisation = setupTenantToken(tenantId)
        val session = setupWebApplicationSessionToken(tenantId, sessionId, userIdentityId, webApplicationId, operatorId)
        val user = setupUserToken(userIdentityId)
        setupTenantJwtToken(organisation, session, user)
    }

    fun configureBusinessUnitApplicationContext(
        tenantId: Long = 1L,
        sessionId: Long = 1L,
        userIdentityId: Long = 1L,
        webApplicationId: Long = 1L,
        operatorId: Long = 1L,
        businessUnitId: Long = 1L
    ) {
        val organisation = setupTenantToken(tenantId)
        val session = setupBusinessUnitSessionToken(tenantId, sessionId, userIdentityId, webApplicationId, operatorId, businessUnitId)
        val user = setupUserToken(userIdentityId)
        setupBusinessUnitJwtToken(organisation, session, user)

    }

    private fun setupTenantJwtToken(
        organisation: AuthenticatedOrganisation,
        session: AuthenticatedWebApplicationSession,
        user: AuthenticatedUser,
    ) {
        Companion.JWT_TOKEN = AccessTokenFactory.token(
            JwtToken(
                authenticationType = AuthenticationType.TENANT,
                user = user,
                organisation = organisation,
                session = session
            )
        )
    }

    private fun setupBusinessUnitJwtToken(
        organisation: AuthenticatedOrganisation,
        session: AuthenticatedBusinessUnitSession,
        user: AuthenticatedUser,
    ) {
        Companion.JWT_TOKEN = AccessTokenFactory.token(
            JwtToken(
                authenticationType = AuthenticationType.BUSINESS_UNIT,
                organisation = organisation,
                user = user,
                session = session,
            )
        )
    }


    private fun setupTenantToken(tenantId: Long) = AuthenticatedOrganisation(
        tenantId = tenantId.toString(),
        displayName = "Test Client",
    )

    private fun setupWebApplicationSessionToken(
        tenantId: Long,
        sessionId: Long,
        userIdentityId: Long,
        webApplicationId: Long,
        operatorId: Long
    ) = AuthenticatedWebApplicationSession(
        sessionId = sessionId.toString(),
        tenantId = tenantId.toString(),
        userId = userIdentityId.toString(),
        webApplicationId = webApplicationId.toString(),
        operatorId = operatorId.toString(),
    )

    private fun setupBusinessUnitSessionToken(
        tenantId: Long,
        sessionId: Long,
        userIdentityId: Long,
        webApplicationId: Long,
        operatorId: Long,
        businessUnitId: Long
    ) = AuthenticatedBusinessUnitSession(
        sessionId = sessionId.toString(),
        tenantId = tenantId.toString(),
        userId = userIdentityId.toString(),
        webApplicationId = webApplicationId.toString(),
        operatorId = operatorId.toString(),
        businessUnitId = businessUnitId.toString(),
    )

    private fun setupUserToken(userIdentityId: Long) = AuthenticatedUser(
        userIdentityId = userIdentityId.toString(),
        displayName = "Test User",
        email = "tester@test.com",
        providerId = "52565265423"
    )
}

===== ./common/common-kotlin/common-api/common-api-test/src/main/kotlin/net/blugrid/api/test/controller/CommonControllerIntegTest.kt =====
package net.blugrid.api.test.controller

import io.github.serpro69.kfaker.faker
import io.micronaut.core.type.Argument
import io.micronaut.data.model.Page
import io.micronaut.data.model.Pageable
import io.micronaut.http.HttpRequest
import io.micronaut.http.client.HttpClient
import io.micronaut.http.client.annotation.Client
import io.netty.handler.codec.http.HttpResponseStatus
import net.blugrid.api.common.model.resource.GenericCreateResource
import net.blugrid.api.common.model.resource.GenericResource
import net.blugrid.api.common.model.resource.GenericUpdateResource
import net.blugrid.api.common.organisation.pageOf
import org.hamcrest.CoreMatchers
import org.hamcrest.MatcherAssert

open class CommonControllerIntegTest(
    open val baseUri: String,
    @Client("/") open val client: HttpClient
) {

    protected val faker = faker {}

    fun <T : GenericResource<out Any>> assertCreate(createPayload: GenericCreateResource<out Any>, responseType: Class<T>, uri: String = baseUri): T {
        return create(createPayload = createPayload, responseType = responseType, uri = uri)
    }

    fun <T : GenericResource<out Any>> create(createPayload: GenericCreateResource<out Any>, responseType: Class<T>, uri: String = baseUri): T {
        return with(
            client.toBlocking()
                .exchange(
                    HttpRequest.PUT(uri, createPayload),
                    responseType,
                ),
        ) {
            MatcherAssert.assertThat(status.code, CoreMatchers.equalTo(HttpResponseStatus.OK.code()))
            body.get()
        }
    }

    fun <T : GenericResource<out Any>> assertUpdate(updatePayload: GenericUpdateResource<out Any>, responseType: Class<T>, uri: String = baseUri): T {
        return update(updatePayload = updatePayload, responseType = responseType, uri = uri)
    }

    fun <T : GenericResource<out Any>> update(updatePayload: GenericUpdateResource<out Any>, responseType: Class<T>, uri: String = baseUri): T {
        return with(
            receiver = client.toBlocking()
                .exchange(
                    HttpRequest.POST("$uri/${updatePayload.id}", updatePayload),
                    Argument.of(responseType),
                ),
        ) {
            MatcherAssert.assertThat(status.code, CoreMatchers.equalTo(HttpResponseStatus.OK.code()))
            body.get()
        }
    }

    fun <T : GenericResource<out Any>> assertGetById(
        createPayload: GenericCreateResource<out Any>,
        responseType: Class<T>,
        uri: String = baseUri
    ): T {
        val newResource = create(createPayload, responseType)
        return getById(id = newResource.id, responseType = responseType, uri = uri)
    }

    fun <T : GenericResource<out Any>> getById(id: Long, responseType: Class<T>, uri: String = baseUri): T {
        return with(
            receiver = client.toBlocking()
                .exchange(
                    HttpRequest.GET<Unit>("$uri/${id}"),
                    Argument.of(responseType),
                ),
        ) {
            MatcherAssert.assertThat(status.code, CoreMatchers.equalTo(HttpResponseStatus.OK.code()))
            body.get()
        }
    }

    fun <T : GenericResource<out Any>> assertGetPage(
        resources: List<GenericCreateResource<out Any>>,
        pageable: Pageable,
        responseType: Class<T>,
        uri: String = baseUri
    ): Page<T> {
        resources.forEach {
            assertCreate(it, responseType)
        }
        return getPage(pageable = pageable, responseType = responseType, uri = uri)
    }

    fun <T : GenericResource<out Any>> getPage(pageable: Pageable, responseType: Class<T>, uri: String = baseUri): Page<T> {
        return with(
            receiver = client.toBlocking()
                .exchange(
                    HttpRequest.POST(uri, pageable),
                    pageOf(responseType),
                ),
        ) {
            MatcherAssert.assertThat(status.code, CoreMatchers.equalTo(HttpResponseStatus.OK.code()))
            body.get()
        }
    }

    fun <T : GenericResource<out Any>> assertDelete(createPayload: GenericCreateResource<out Any>, responseType: Class<T>, uri: String = baseUri) {
        val newResource = assertCreate(createPayload, responseType)
        delete(id = newResource.id, uri = uri)
    }

    fun delete(id: Long, uri: String = baseUri) {
        with(
            receiver = client.toBlocking()
                .exchange(
                    HttpRequest.DELETE<Void>("$uri/$id"),
                    Argument.of(Void::class.java),
                ),
        ) {
            MatcherAssert.assertThat(status.code, CoreMatchers.equalTo(HttpResponseStatus.OK.code()))
        }
    }
}

===== ./common/common-kotlin/common-api/common-api-test/src/main/kotlin/net/blugrid/api/test/controller/CommonSearchControllerIntegTest.kt =====
package net.blugrid.api.test.controller

import io.micronaut.http.client.HttpClient
import io.micronaut.http.client.annotation.Client
import net.blugrid.api.common.model.resource.GenericAuditedResource
import net.blugrid.api.common.search.SearchIndex
import net.blugrid.api.test.factory.randomInstance
import java.time.LocalDateTime

open class CommonSearchControllerIntegTest(
    override val baseUri: String,
    @Client("/") override val client: HttpClient
) : CommonControllerIntegTest(baseUri, client) {

    companion object {
        var tenantId: Long = 1L
    }

    fun searchIndex(resource: GenericAuditedResource<*>, searchTerms: String = randomInstance()) = SearchIndex(
        resourceId = faker.random.nextLong(),
        resourceType = resource.resourceType,
        resource = resource as Any,
        tenantId = 1L,
        searchTerms = searchTerms,
        createdTimestamp = LocalDateTime.now(),
        lastChangedTimestamp = LocalDateTime.now()
    )
}

===== ./common/common-kotlin/common-api/common-api-test/src/main/resources/application-test.yml =====
---
env.db.schema: bizkinetics
---
#tag::logging[]
logger:
  levels:
    net.blugrid.api: DEBUG
#end::logging[]
---
#tag::swagger[]
micronaut.openapi.enabled: false
micronaut.openapi.swagger.file.generation.enabled: false
---
#tag::endpoints[]
endpoints:
  all:
    enabled: false
#end::endpoints[]
---
#tag::security[]
#micronaut:
#  security:
#    enabled: true
#    authentication: bearer
#    intercept-url-map:
#      - pattern: "/**"
#        access:
#          - isAuthenticated()
#    token:
#      enabled: true
#      roles-name: "roles"
#      jwt:
#        enabled: true
#        signatures:
#          jwks:
#            auth0:
#              url: "https://bizkinetics.au.auth0.com/.well-known/jwks.json"
#end::security[]
---
#tag::client[]
micronaut:
  http:
    client:
      read-timeout: 300s
  services:
    localhost:
      url: http://localhost
#  security:
#    oauth2:
#      clients:
#        auth0:
#          client-id: '${OAUTH_CLIENT_ID:0hU7HAfkTzcBU7ZlY0vtUHl4dl1c5Gdk}'
#          client-secret: '${OAUTH_CLIENT_SECRET:1-D9zbE6uA7v3AI4iZ6dzlPSSldaqhI20H5N3BjiHmKwYAPtE-5GtyTZLy6NwgMs}'
#          grant-type: 'client_credentials'
#          token:
#            url: '${OAUTH_TOKEN_URL:`https://bizkinetics.au.auth0.com/oauth/token`}'
#            auth-method: 'client_secret_post'
#          client-credentials:
#            service-id-regex: '.*'
#            additional-request-params:
#              audience: '${AUTH0_API_IDENTIFIER:`https://dev.bizkinetics.com.au/api/rest`}'
#end::client[]

===== ./common/common-kotlin/common-api/common-api-test/src/test/kotlin/net/blugrid/api/factory/RandomInstanceFactoryTest.kt =====
package net.blugrid.api.test.factory

import org.junit.jupiter.api.Assertions.assertEquals
import org.junit.jupiter.api.Assertions.assertTrue
import org.junit.jupiter.api.Test
import kotlin.random.Random

@Suppress("USELESS_IS_CHECK")
class MakeRandomInstanceTest {
    class A {
        override fun toString(): String = "A"
    }

    data class B(val a: A)
    data class C(val b1: B, val c: Char, val b2: B, val str: String, val l: Long)
    class D {
        lateinit var a: A

        constructor() {
            throw Error("Do not use this one")
        }

        constructor(a: A) {
            this.a = a
        }

        override fun toString() = "D(a=$a)"
    }

    data class E(val b: B, val map: Map<Long, String>, val l: Long)
    data class F(val l: List<E>, val e: E)
    data class L(val ints: List<Int>)

    class P {
        private constructor()
    }

    @Test
    fun `Creates single instance using an empty constructor`() {
        val a: A = randomInstance()
        assertTrue(a is A)
        assertTrue("A" in a.toString())
    }

    @Test
    fun `Throws NoUsableConstructor error if there is no constructor that could be used`() {
        try {
            randomInstance<P>()
            error("makeRandomInstance should throw NoUsableConstructor error")
        } catch (e: NoUsableConstructor) {
            // no-op
        }
    }

    private fun catchError(function: () -> Unit): Throwable? = try {
        function()
        null
    } catch (throwable: Throwable) {
        throwable
    }

    @Test
    fun `Creates using constructor`() {
        val b: B = randomInstance()
        assertTrue(b is B)
        assertEquals("B(a=A)", b.toString())
    }

    @Test
    fun `Skipps constructors that cannot be used`() {
        val d: D = randomInstance()
        assertTrue(d is D)
        assertEquals("D(a=A)", d.toString())
    }

    @Test
    fun `Creates primitives`() {
        assertTrue(randomInstance<Int>() is Int)
        assertTrue(randomInstance<Long>() is Long)
        assertTrue(randomInstance<Double>() is Double)
        assertTrue(randomInstance<Float>() is Float)
        assertTrue(randomInstance<Char>() is Char)
        assertTrue(randomInstance<String>() is String)
        //... etc. Don't forget about arrays
    }

    @Test
    fun `Creates an instance using constructor with primitives and standard types`() {
        val b: B = randomInstance()
        assertTrue(b is B)
        assertTrue("B(a=A)" in b.toString())

        val c: C = randomInstance()
        assertTrue(c is C)
        assertTrue(c.toString().matches("C\\(b1=B\\(a=A\\), c=[A-z], b2=B\\(a=A\\), str=[A-z]*, l=-?\\d*\\)".toRegex()), "It is $c")
    }

    @Test
    fun `Creates collections`() {
        val ints = randomInstance<List<Int>>()
        assertTrue(ints is List<Int>)
        assertTrue(ints.toString().startsWith("["))
        assertTrue(ints.toString().endsWith("]"))

        val map = randomInstance<Map<Long, String>>()
        assertTrue(map is Map<Long, String>)
        assertTrue(map.toString().startsWith("{"))
        assertTrue(map.toString().endsWith("}"))

        assertTrue(randomInstance<Collection<A>>() is Collection<A>)
    }

    @Test
    fun `Creates an instance using constructor with collections, primitives and standard types`() {
        val b: L = randomInstance()
        assertTrue(b is L)
        assertTrue(b.ints is List<Int>)
        assertTrue(b.ints.firstOrNull() is Int?)

        val e: E = randomInstance()
        assertTrue(e is E)
        assertTrue(e.map.all { (k, v) -> k is Long && v is String })
        assertTrue(e.toString().startsWith("E(b=B(a=A), map={"))
    }

    class GT<T> {
        var t: T? = null
    }

    class GA<T>(var t: T)
    class GAA<T1, T2>(val t1: T1, val t2: T2)
    class GTA<T1, T2>(val t2: T2)

    @Test
    fun `Generic classes are supported`() {
        val gt1 = randomInstance<GT<Int>>()
        gt1.t = 1
        assertEquals(1, gt1.t)
        gt1.t = 10

        val gt2 = randomInstance<GT<Long>>()
        gt2.t = 1L
        assertEquals(1L, gt2.t)
        gt2.t = 10L

        val gtRecursive = randomInstance<GT<GT<Int>>>()
        gtRecursive.t = gt1
        assertEquals(gt1, gtRecursive.t)

        val ga1: GA<Int> = randomInstance()
        assertTrue(ga1.t is Int)

        val ga2: GA<String> = randomInstance()
        assertTrue(ga2.t is String)

        val gaa1: GAA<Int, String> = randomInstance()
        assertTrue(gaa1.t1 is Int)
        assertTrue(gaa1.t2 is String)

        val gaa2: GAA<Long, List<Int>> = randomInstance()
        assertTrue(gaa2.t1 is Long)
        assertTrue(gaa2.t2 is List<Int>)

        val gta: GTA<Long, String> = randomInstance()
        gta.t2.length

        val gaaga: GAA<Long, GA<GT<Int>>> = randomInstance()
        assertTrue(gaaga.t1 is Long)
        assertTrue(gaaga.t2 is GA<GT<Int>>)

        val gggg: GA<GA<GA<Int>>> = randomInstance()
        gggg.t.t.t = 10
        assertEquals(10, gggg.t.t.t)
        gggg.t.t = GA(20)
        assertEquals(20, gggg.t.t.t)
    }

    @Test
    fun `When user expects empty collections, both Map and List are empty`() {
        val config = randomInstanceConfig(possibleCollectionSizes = 0..0)
        repeat(10) {
            assertEquals(emptyList<Int>(), randomInstance<List<Int>>(config = config))
            assertEquals(emptyList<List<Int>>(), randomInstance<List<List<Int>>>(config = config))
            assertEquals(emptyMap<Int, String>(), randomInstance<Map<Int, String>>(config = config))
        }
    }

    @Test
    fun `When user expects concrete collection size, both Map and List are of this size`() {
        val config = randomInstanceConfig(possibleCollectionSizes = 5..5)
        repeat(10) {
            assertEquals(5, randomInstance<List<Int>>(config = config).size)
            assertEquals(5, randomInstance<List<List<Int>>>(config = config).size)
            assertEquals(5, randomInstance<Map<Int, String>>(config = config).size)
        }
    }

    @Test
    fun `When user expects concrete String length, all Strings have this length`() {
        val config = randomInstanceConfig(possibleStringSizes = 5..5, possibleCollectionSizes = 2..2)
        repeat(10) {
            assertEquals(5, randomInstance<String>(config = config).length)
            assertEquals(5, randomInstance<List<String>>(config = config)[0].length)
            assertEquals(5, randomInstance<List<List<String>>>(config = config)[1][1].length)
        }
    }

    @Test
    fun `Object set in config as Any, is always returned when we expect Any`() {
        val any = object {}
        val config = randomInstanceConfig(any = any)
        repeat(10) {
            assertEquals(any, randomInstance<Any>(config = config))
            assertEquals(any, randomInstance<GA<Any>>(config = config).t)
            assertEquals(any, randomInstance<GA<GA<Any>>>(config = config).t.t)
        }
    }

    @Test
    fun `Check expected random values`() {
        val random = Random(12345)
        assertEquals("A", randomInstance<A>(random).toString())
        assertEquals("B(a=A)", randomInstance<B>(random).toString())
        assertEquals("C(b1=B(a=A), c=Y, b2=B(a=A), str=yS, l=-6367288518484839692)", randomInstance<C>(random).toString())
        assertEquals("D(a=A)", randomInstance<D>(random).toString())
        assertEquals(
            "E(b=B(a=A), map={-6428220448289816081=voWGUkC\\, 7288696731122253832=kp]U, -4359497035184897174=Nc`tCa, -8481730907691591520=M}, l=1553348274986458979)",
            randomInstance<E>(random).toString()
        )
        assertEquals(
            "F(l=[E(b=B(a=A), map={-6065142614942521822=t, 416890183638600344=p_JLM]iD^y, 4288163720945964501=z`AGmw}, l=5098165797873145605), E(b=B(a=A), map={-1045531387234036165=SYMlUY, 943176485828979=bkcU, 7917721219055033990=xl^\\dB, -3835092262954011188=lOpa^clPX}, l=870933613633965720), E(b=B(a=A), map={3682447410090233778=LfX[Em, -6203180773228722909=KeloXcypXg, -3662781481041013612=]lILXf, 8884333428377293996=e, 827637008512869092=Zwcu}, l=1759343391314632900), E(b=B(a=A), map={3072701447898829435=GYDLUYDSdn}, l=-6214529434004727598), E(b=B(a=A), map={-5540839068437135337=HTxnLiz, 8783042796281279363=vGYAp`, 5347169406213203755=bOpO_P, -4827221593046365475=vkn}, l=1667205364588981005)], e=E(b=B(a=A), map={-826488732485778636=SAv, 398313030478269938=sDFgHE, 7535000932527017313=jboPScOh, 321039882229839452=bg}, l=-2421217787312800394))",
            randomInstance<F>(random).toString()
        )
    }
}

===== ./common/common-kotlin/common-api/common-api-test/build.gradle.kts =====
plugins {
   alias(libs.plugins.jvm)
   alias(libs.plugins.kapt)
   alias(libs.plugins.allopen)
   alias(libs.plugins.jpa)
   alias(libs.plugins.shadow)
   alias(libs.plugins.application)
}

repositories {
    mavenCentral()
}

dependencies {
    api(project(":common:common-kotlin:common-api:common-api-model"))
    api(project(":common:common-kotlin:common-api:common-api-client"))
    api(project(":common:common-kotlin:common-api:common-api-json"))
    api(project(":common:common-kotlin:common-api:common-api-logging"))
    api(project(":common:common-kotlin:common-api:common-api-security"))

    api(platform("io.micronaut.platform:micronaut-platform"))
    api(platform("aws.sdk.kotlin:bom:1.4.92"))
    api("io.micronaut:micronaut-http-client")
    api("aws.sdk.kotlin:ecr")
    api("io.grpc:grpc-kotlin-stub:1.3.0")

    api("io.micronaut.grpc:micronaut-grpc-server-runtime")
    api("io.micronaut.grpc:micronaut-grpc-client-runtime")
    api("io.grpc:grpc-stub:1.62.2")
    api("com.google.protobuf:protobuf-kotlin:4.31.1")

    kapt(annotationProcessorLibs.bundles.commonAnnotationProcessors)

    implementation(libs.bundles.commonLibs)
    implementation(libs.bundles.securityLibs)

    runtimeOnly(runTimeLibs.bundles.securityRuntimeLibs)

    api(testLibs.bundles.testImplementationLibs) {
        exclude(group = "org.slf4j", module = "slf4j-api")
    }
}
java {
    sourceCompatibility = JavaVersion.toVersion("17")
}
kapt {
    arguments {
        arg("micronaut.openapi.project.dir", projectDir.toString())
    }
}
kotlin {
    jvmToolchain {
        languageVersion.set(JavaLanguageVersion.of(17))
    }
}

graalvmNative.toolchainDetection = false
micronaut {
    runtime("netty")
    testRuntime("junit5")
    processing {
        incremental(true)
        annotations("net.blugrid.api.*")
    }
}

application {
    mainClass.set("net.blugrid.api.ApplicationKt")
}

===== ./common/common-kotlin/common-api/common-api-test/gradle.properties =====
micronautVersion=4.4.3
kotlinVersion=1.9.23

===== ./common/common-kotlin/common-api/common-api-audit/src/main/kotlin/net/blugrid/api/audit/event/UpdateAuditLogAuditEventHandler.kt =====
package net.blugrid.api.audit.event

import io.micronaut.runtime.event.annotation.EventListener
import jakarta.inject.Singleton
import net.blugrid.api.audit.service.AuditEventLogService
import net.blugrid.api.logging.logger
import net.blugrid.api.common.model.audit.AuditEvent
import net.blugrid.api.json.objectToJson

@Singleton
open class UpdateAuditLogAuditEventHandler(
    private val auditEventLogService: AuditEventLogService
) {

    private val log = logger()

    @EventListener
    open fun handle(event: AuditEvent) {
        log.debug("received audit ${event.auditEventType} event for ${event.resourceType}")
        log.trace("received audit ${event.auditEventType} event for ${event.resourceType}:  ${objectToJson(event)}")
        auditEventLogService.createAuditEventLog(event)
    }
}

===== ./common/common-kotlin/common-api/common-api-audit/src/main/kotlin/net/blugrid/api/audit/model/AuditEventLogQuery.kt =====
package net.blugrid.api.audit.model

import net.blugrid.api.common.model.audit.AuditEventType
import net.blugrid.api.common.model.resource.ResourceType
import java.time.LocalDateTime

class AuditEventLogQuery(
    val resourceTypes: List<ResourceType>,
    val resourceIds: List<Long>? = null,
    val auditEventTypes: List<AuditEventType>? = null,
    val tenantIds: List<Long>? = null,
    val partyIds: List<Long>? = null,

    val minDateTime: LocalDateTime? = null,

    val maxDateTime: LocalDateTime? = null,
)

===== ./common/common-kotlin/common-api/common-api-audit/src/main/kotlin/net/blugrid/api/audit/mapping/AuditEventLogMapper.kt =====
package net.blugrid.api.audit.mapping

import net.blugrid.api.audit.repository.model.AuditEventLogInsertEntity
import net.blugrid.api.audit.repository.model.AuditEventLogReadEntity
import net.blugrid.api.common.model.audit.AuditEvent
import net.blugrid.api.common.model.audit.AuditEventLog
import net.blugrid.api.common.model.resource.GenericAuditedResource
import java.util.UUID

fun AuditEventLogInsertEntity.toAuditEventLog() =
    AuditEventLog(
        auditEventType = this.auditEventType,
        auditEventTimestamp = this.auditEventTimestamp,
        resourceType = this.resourceType,
        resourceId = this.resourceId,
        resource = this.resource,
        tenantId = this.tenantId,
        sessionId = this.sessionId,
        version = 0 // ToDo add read entity
    )

fun AuditEventLogInsertEntity.toAuditEvent() =
    AuditEvent(
        auditEventType = this.auditEventType,
        auditEventTimestamp = this.auditEventTimestamp,
        resourceType = this.resourceType,
        resourceId = this.resourceId,
        resource = this.resource,
        tenantId = this.tenantId,
        sessionId = this.sessionId,
    )

fun AuditEventLogReadEntity.toAuditEventLog() =
    AuditEventLog(
        auditEventType = this.auditEventType,
        auditEventTimestamp = this.auditEventTimestamp,
        resourceType = this.resourceType,
        resourceId = this.resourceId,
        resource = this.resource,
        tenantId = this.tenantId,
        sessionId = this.sessionId,
        version = 0 // ToDo add read entity
    )

fun AuditEventLogReadEntity.toAuditEvent() =
    AuditEvent(
        auditEventType = this.auditEventType,
        auditEventTimestamp = this.auditEventTimestamp,
        resourceType = this.resourceType,
        resourceId = this.resourceId,
        resource = this.resource as GenericAuditedResource<*>,
        tenantId = this.tenantId,
        sessionId = this.sessionId,
    )

fun AuditEvent.toAuditEventLogUpdateEntity() =
    AuditEventLogInsertEntity(
        id = UUID.randomUUID(),
        auditEventType = this.auditEventType,
        auditEventTimestamp = this.auditEventTimestamp,
        resourceType = this.resourceType,
        resourceId = this.resourceId,
        resource = this.resource,
        tenantId = this.tenantId,
        sessionId = this.sessionId,
    )

===== ./common/common-kotlin/common-api/common-api-audit/src/main/kotlin/net/blugrid/api/audit/service/GenericAuditLoader.kt =====
package net.blugrid.api.audit.service

import net.blugrid.api.common.audit.service.AuditEventEmitterServiceImpl
import net.blugrid.api.common.model.audit.AuditEventType
import net.blugrid.api.common.model.resource.GenericCreateResource
import net.blugrid.api.common.model.resource.GenericUpdateResource
import net.blugrid.api.common.model.resource.ResourceType
import net.blugrid.api.common.model.resource.TenantResource
import net.blugrid.api.common.repository.model.GenericEntity
import net.blugrid.api.common.repository.model.GenericEntityMapper
import net.blugrid.api.common.service.GenericCrudService
import java.time.LocalDateTime

abstract class GenericAuditLoader<
    T : TenantResource<T>,
    U : GenericCreateResource<U>,
    V : GenericUpdateResource<V>,
    X : GenericEntity<X>,
    Y : GenericEntityMapper<T, U, V, X>
    > {
    abstract fun reload(resourceType: ResourceType)
    abstract fun isEmpty(resourceType: ResourceType): Boolean
}

open class GenericAuditLoaderImpl<
    T : TenantResource<T>,
    U : GenericCreateResource<U>,
    V : GenericUpdateResource<V>,
    X : GenericEntity<X>,
    Y : GenericEntityMapper<T, U, V, X>
    >(
    private val auditEventLogService: AuditEventLogService,
    private val auditEventEmitterService: AuditEventEmitterServiceImpl,
    private val stateService: GenericCrudService<T, U, V, X, Y>
) : GenericAuditLoader<T, U, V, X, Y>() {

    override fun reload(resourceType: ResourceType) {
        stateService.getAll().forEach {
            auditEventEmitterService.publishEvent(
                eventType = AuditEventType.CREATE,
                resourceType = it.resourceType,
                resource = it,
                resourceId = it.id,
                tenantId = it.permission?.tenantId!!,
                sessionId = it.audit?.createdBySessionId!!,
                version = 1,
                localDateTime = LocalDateTime.now()
            )
        }
    }

    override fun isEmpty(resourceType: ResourceType): Boolean {
        return this.auditEventLogService.isEmpty(resourceType)
    }
}



===== ./common/common-kotlin/common-api/common-api-audit/src/main/kotlin/net/blugrid/api/audit/service/AuditEventLogService.kt =====
package net.blugrid.api.audit.service

import io.micronaut.data.model.Page
import io.micronaut.data.model.Pageable
import io.micronaut.transaction.annotation.ReadOnly
import jakarta.inject.Singleton
import net.blugrid.api.audit.mapping.toAuditEventLog
import net.blugrid.api.audit.mapping.toAuditEventLogUpdateEntity
import net.blugrid.api.audit.model.AuditEventLogQuery
import net.blugrid.api.audit.repository.AuditEventLogInsertRepository
import net.blugrid.api.audit.repository.AuditEventLogReadRepository
import net.blugrid.api.audit.repository.AuditEventLogReadSpecifications.auditLogEventQueryToSpecification
import net.blugrid.api.audit.repository.AuditEventLogReadSpecifications.hasResourceTypeAndResourceId
import net.blugrid.api.common.model.audit.AuditEvent
import net.blugrid.api.common.model.audit.AuditEventLog
import net.blugrid.api.common.model.resource.ResourceType
import jakarta.transaction.Transactional
import jakarta.transaction.Transactional.TxType.REQUIRES_NEW

interface AuditEventLogService {
    fun createAuditEventLog(auditEventLog: AuditEvent)
    fun findAllByResourceId(resourceType: ResourceType, resourceId: Long): List<AuditEventLog>
    fun searchAuditEventLogs(query: AuditEventLogQuery, pageRequest: Pageable): Page<AuditEventLog?>
    fun isEmpty(resourceType: ResourceType): Boolean
}

@Singleton
open class AuditEventLogServiceImpl(
    private val auditEventLogInsertRepository: AuditEventLogInsertRepository,
    private val auditEventLogReadRepository: AuditEventLogReadRepository,
) : AuditEventLogService {


    @Transactional(value = REQUIRES_NEW)
    override fun createAuditEventLog(auditEventLog: AuditEvent) {
        auditEventLogInsertRepository.save(auditEventLog.toAuditEventLogUpdateEntity())
    }

    @ReadOnly
    override fun findAllByResourceId(resourceType: ResourceType, resourceId: Long): List<AuditEventLog> {
        return auditEventLogReadRepository.findAll(hasResourceTypeAndResourceId(resourceType, resourceId))
            .takeIf { it.isNotEmpty() }
            ?.map { it!!.toAuditEventLog() }
            ?: emptyList()
    }

    @ReadOnly
    override fun searchAuditEventLogs(query: AuditEventLogQuery, pageRequest: Pageable): Page<AuditEventLog?> {
        return auditEventLogReadRepository.findAll(auditLogEventQueryToSpecification(query), pageRequest)
            .map { it!!.toAuditEventLog() }
    }

    @ReadOnly
    override fun isEmpty(resourceType: ResourceType): Boolean {
        return auditEventLogReadRepository.countByResourceType(resourceType) == 0L
    }
}

===== ./common/common-kotlin/common-api/common-api-audit/src/main/kotlin/net/blugrid/api/audit/repository/model/AuditEventLogReadEntity.kt =====
package net.blugrid.api.audit.repository.model

import io.hypersistence.utils.hibernate.type.json.JsonBinaryType
import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.EnumType
import jakarta.persistence.Enumerated
import jakarta.persistence.Id
import jakarta.persistence.Table
import net.blugrid.api.common.model.audit.AuditEventType
import net.blugrid.api.common.model.resource.ResourceType
import net.blugrid.api.util.kotlinEquals
import org.hibernate.annotations.Immutable
import org.hibernate.annotations.Type
import java.time.LocalDateTime
import java.util.Objects
import java.util.UUID

@Entity
@Immutable
@Table(name = "vw_audit_event_log_read")
class AuditEventLogReadEntity(

    @Id
    @Column(name = "uuid", updatable = false, nullable = false)
    val id: UUID,

    @Column(name = "resource_id")
    val resourceId: Long,

    @Enumerated(EnumType.STRING)
    @Column(name = "resource_type")
    val resourceType: ResourceType,

    @Enumerated(EnumType.STRING)
    @Column(name = "audit_event_type")
    val auditEventType: AuditEventType,

    @Type(JsonBinaryType::class)
    @Column(name = "resource")
    val resource: Any,

    @Column(name = "timestamp")
    val auditEventTimestamp: LocalDateTime,

    @Column(name = "session_id")
    val sessionId: Long,

    @Column(name = "tenant_id")
    val tenantId: Long,
) {
    companion object {
        private val equalsProperties = arrayOf(
            AuditEventLogReadEntity::id,
            AuditEventLogReadEntity::resourceId,
            AuditEventLogReadEntity::resourceType,
            AuditEventLogReadEntity::auditEventType,
            AuditEventLogReadEntity::resource,
            AuditEventLogReadEntity::auditEventTimestamp,
            AuditEventLogReadEntity::sessionId,
            AuditEventLogReadEntity::tenantId
        )
    }

    override fun equals(other: Any?) = kotlinEquals(other = other, properties = equalsProperties)

    override fun hashCode() = Objects.hash(
        id,
        resourceId,
        resourceType,
        auditEventType,
        resource,
        auditEventTimestamp,
        sessionId,
        tenantId
    )
}

===== ./common/common-kotlin/common-api/common-api-audit/src/main/kotlin/net/blugrid/api/audit/repository/model/AuditEventLogInsertEntity.kt =====
package net.blugrid.api.audit.repository.model

import io.hypersistence.utils.hibernate.type.json.JsonBinaryType
import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.EnumType
import jakarta.persistence.Enumerated
import jakarta.persistence.Id
import jakarta.persistence.Table
import net.blugrid.api.common.model.audit.AuditEventType
import net.blugrid.api.common.model.resource.GenericAuditedResource
import net.blugrid.api.common.model.resource.ResourceType
import net.blugrid.api.util.kotlinEquals
import org.hibernate.annotations.Immutable
import org.hibernate.annotations.Type
import java.time.LocalDateTime
import java.util.Objects
import java.util.UUID

@Entity
@Immutable
@Table(name = "vw_audit_event_log_insert")
class AuditEventLogInsertEntity(

    @Id
    @Column(name = "uuid", updatable = false, nullable = false)
    val id: UUID,

    @Column(name = "resource_id")
    val resourceId: Long,

    @Enumerated(EnumType.STRING)
    @Column(name = "resource_type")
    val resourceType: ResourceType,

    @Enumerated(EnumType.STRING)
    @Column(name = "audit_event_type")
    val auditEventType: AuditEventType,

    @Type(JsonBinaryType::class)
    @Column(name = "resource")
    val resource: GenericAuditedResource<*>,

    @Column(name = "timestamp")
    val auditEventTimestamp: LocalDateTime,

    @Column(name = "session_id")
    val sessionId: Long,

    @Column(name = "tenant_id")
    val tenantId: Long,
) {
    companion object {
        private val equalsProperties = arrayOf(
            AuditEventLogInsertEntity::id,
            AuditEventLogInsertEntity::resourceId,
            AuditEventLogInsertEntity::resourceType,
            AuditEventLogInsertEntity::auditEventType,
            AuditEventLogInsertEntity::resource,
            AuditEventLogInsertEntity::auditEventTimestamp,
            AuditEventLogInsertEntity::sessionId,
            AuditEventLogInsertEntity::tenantId
        )
    }

    override fun equals(other: Any?) = kotlinEquals(other = other, properties = equalsProperties)

    override fun hashCode() = Objects.hash(
        id,
        resourceId,
        resourceType,
        auditEventType,
        resource,
        auditEventTimestamp,
        sessionId,
        tenantId
    )
}

===== ./common/common-kotlin/common-api/common-api-audit/src/main/kotlin/net/blugrid/api/audit/repository/AuditEventLogReadRepository.kt =====
package net.blugrid.api.audit.repository

import io.micronaut.context.annotation.Executable
import io.micronaut.data.annotation.Query
import io.micronaut.data.annotation.Repository
import io.micronaut.data.jpa.repository.JpaRepository
import io.micronaut.data.jpa.repository.JpaSpecificationExecutor
import io.micronaut.data.jpa.repository.criteria.Specification
import io.micronaut.data.jpa.repository.criteria.Specification.where
import net.blugrid.api.audit.model.AuditEventLogQuery
import net.blugrid.api.audit.repository.model.AuditEventLogInsertEntity
import net.blugrid.api.audit.repository.model.AuditEventLogReadEntity
import net.blugrid.api.common.model.audit.AuditEventType
import net.blugrid.api.common.model.resource.ResourceType
import net.blugrid.api.common.repository.equal
import net.blugrid.api.common.repository.`in`
import java.time.LocalDateTime
import java.util.UUID

@Repository
interface AuditEventLogReadRepository : JpaRepository<AuditEventLogReadEntity, UUID>, JpaSpecificationExecutor<AuditEventLogReadEntity?> {
    @Executable
    fun findBySessionId(sessionId: Long): List<AuditEventLogReadEntity>?

    @Executable
    fun findByResourceType(resourceType: ResourceType): List<AuditEventLogReadEntity>?

    @Executable
    @Query(value = "SELECT count(*) from AuditEventLogReadEntity a WHERE a.resourceType = :resourceType")
    fun countByResourceType(resourceType: ResourceType): Long
}

object AuditEventLogReadSpecifications {
    fun auditLogEventQueryToSpecification(auditEventLogQuery: AuditEventLogQuery): Specification<AuditEventLogReadEntity?> {
        return where(hasResourceTypes(auditEventLogQuery.resourceTypes))
            .and(hasResourceIds(auditEventLogQuery.resourceIds))
            .and(hasClientIds(auditEventLogQuery.tenantIds))
            .and(hasAuditEventType(auditEventLogQuery.auditEventTypes))
            .and(hasTimestampBetween(auditEventLogQuery.minDateTime, auditEventLogQuery.maxDateTime))
    }

    fun hasResourceTypeAndResourceId(resourceType: ResourceType?, resourceId: Long?): Specification<AuditEventLogReadEntity?> {
        return where(hasResourceType(resourceType = resourceType))
            .and(hasResourceId(resourceId = resourceId))
    }

    fun hasResourceType(resourceType: ResourceType?): Specification<AuditEventLogReadEntity>? =
        resourceType?.let { AuditEventLogReadEntity::resourceType.equal(it) }

    fun hasResourceId(resourceId: Long?): Specification<AuditEventLogReadEntity>? =
        resourceId?.let { AuditEventLogReadEntity::resourceId.equal(it) }

    fun hasResourceTypes(resourceTypes: List<ResourceType>?): Specification<AuditEventLogReadEntity>? = resourceTypes?.let { AuditEventLogReadEntity::resourceType.`in`(resourceTypes) }
    fun hasResourceIds(resourceIds: List<Long>?): Specification<AuditEventLogReadEntity>? = resourceIds?.let { AuditEventLogReadEntity::resourceId.`in`(it) }
    fun hasClientIds(tenantIds: List<Long>?): Specification<AuditEventLogReadEntity>? = tenantIds?.let { AuditEventLogReadEntity::tenantId.`in`(tenantIds) }
    fun hasAuditEventType(auditEventTypes: List<AuditEventType>?): Specification<AuditEventLogReadEntity>? = auditEventTypes?.let { AuditEventLogReadEntity::auditEventType.`in`(auditEventTypes) }

    fun hasTimestampBetween(minDate: LocalDateTime?, maxDate: LocalDateTime?): Specification<AuditEventLogReadEntity> {
        return Specification<AuditEventLogReadEntity> { root, _, cb ->
            cb.and(
                if (minDate == null) cb.conjunction() else cb.greaterThanOrEqualTo(root.get("timestamp"), minDate),
                if (maxDate == null) cb.conjunction() else cb.lessThanOrEqualTo(root.get("timestamp"), maxDate)
            )
        }
    }

    fun hasTimestampGreaterThan(startDate: LocalDateTime): Specification<AuditEventLogReadEntity> {
        return Specification<AuditEventLogReadEntity> { root, _, cb ->
            cb.and(
                cb.greaterThanOrEqualTo(root.get("timestamp"), startDate)
            )
        }
    }

    fun hasTimestampLessThan(endDate: LocalDateTime): Specification<AuditEventLogReadEntity> {
        return Specification<AuditEventLogReadEntity> { root, _, cb ->
            cb.and(
                cb.lessThanOrEqualTo(root.get("timestamp"), endDate)
            )
        }
    }
}


===== ./common/common-kotlin/common-api/common-api-audit/src/main/kotlin/net/blugrid/api/audit/repository/AuditEventLogInsertRepository.kt =====
package net.blugrid.api.audit.repository

import io.micronaut.data.annotation.Repository
import io.micronaut.data.jpa.repository.JpaRepository
import io.micronaut.data.jpa.repository.JpaSpecificationExecutor
import net.blugrid.api.audit.repository.model.AuditEventLogInsertEntity
import java.util.UUID

@Repository
interface AuditEventLogInsertRepository : JpaRepository<AuditEventLogInsertEntity, UUID>, JpaSpecificationExecutor<AuditEventLogInsertEntity?>


===== ./common/common-kotlin/common-api/common-api-audit/src/main/kotlin/net/blugrid/api/Application.kt =====
package net.blugrid.api

import io.micronaut.runtime.Micronaut.run
import io.swagger.v3.oas.annotations.OpenAPIDefinition
import io.swagger.v3.oas.annotations.info.Info

@OpenAPIDefinition(
    info = Info(
        title = "Audit API",
        version = "0.0",
        description = "Common Audit API",
    )
)
object Application

fun main(args: Array<String>) {
    run(*args)
}

===== ./common/common-kotlin/common-api/common-api-audit/src/main/resources/db/migration/auditEventLog/R__3_vw_audit_event_log_read.sql =====
DROP VIEW IF EXISTS vw_audit_event_log_read;

CREATE OR REPLACE VIEW vw_audit_event_log_read
AS
SELECT *
  FROM audit_event_log s;


===== ./common/common-kotlin/common-api/common-api-audit/src/main/resources/db/migration/auditEventLog/R__3_vw_audit_event_log_insert.sql =====
DROP VIEW IF EXISTS vw_audit_event_log_insert;

CREATE OR REPLACE VIEW vw_audit_event_log_insert
AS
SELECT *
  FROM audit_event_log s;

CREATE OR REPLACE FUNCTION proc_trig_audit_event_log_insert(
) RETURNS TRIGGER AS
$body$
DECLARE
    the_table_name TEXT;
BEGIN
    new.created_timestamp = now();

    SELECT coalesce(MAX(version), 0) + 1
    FROM audit_event_log
    WHERE resource_id = new.resource_id AND resource_type = new.resource_type
    INTO new.version;

    the_table_name = create_audit_event_log_partition_table('audit_event_log', new.resource_type::TEXT, new.timestamp::TIMESTAMP);

    EXECUTE 'INSERT INTO ' || QUOTE_IDENT(the_table_name) || ' VALUES ($1.*) '
        USING new;

    RETURN new;
END
$body$ LANGUAGE 'plpgsql';

DROP TRIGGER IF EXISTS trig_audit_event_log ON vw_audit_event_log_insert;

CREATE TRIGGER trig_audit_event_log
    INSTEAD OF INSERT
    ON vw_audit_event_log_insert
    FOR EACH ROW
EXECUTE PROCEDURE proc_trig_audit_event_log_insert();



===== ./common/common-kotlin/common-api/common-api-audit/src/main/resources/db/migration/auditEventLog/V2021.01.01.10.08.02__audit_event_log.sql =====
CREATE TABLE IF NOT EXISTS audit_event_log
(
    uuid              uuid      NOT NULL,
    resource_id       BIGINT    NOT NULL,
    resource_type     TEXT      NOT NULL,
    version    INTEGER   NOT NULL DEFAULT 0,
    audit_event_type  TEXT      NOT NULL,
    resource          jsonb,
    tenant_id         BIGINT    NOT NULL,
    session_id        BIGINT    NOT NULL,
    timestamp         TIMESTAMP NOT NULL,
    created_timestamp TIMESTAMP NOT NULL DEFAULT now(),

    CONSTRAINT pk_audit_event_log PRIMARY KEY (uuid),
    CHECK (FALSE) NO INHERIT
)
WITHOUT OIDS;

CREATE INDEX IF NOT EXISTS idx_audit_event_log_tenant_id ON audit_event_log USING btree (tenant_id);

CREATE UNIQUE INDEX IF NOT EXISTS ak_audit_event_log_resource_id_type_version ON audit_event_log USING btree (resource_id, resource_type, version);

CREATE INDEX IF NOT EXISTS idx_audit_event_log_resource_id_resource_type ON audit_event_log USING btree (resource_id, resource_type);

CREATE INDEX IF NOT EXISTS idx_audit_event_log_tenant_id_resource_type ON audit_event_log USING btree (tenant_id, resource_type);

CREATE INDEX IF NOT EXISTS idx_audit_event_log_tenant_id_resource_id ON audit_event_log USING btree (tenant_id, resource_id);

CREATE INDEX IF NOT EXISTS idx_audit_event_log_timestamp ON audit_event_log USING btree (timestamp);

===== ./common/common-kotlin/common-api/common-api-audit/src/main/resources/db/migration/auditEventLog/V2020.01.01.10.08.01__audit_extensions.sql =====
CREATE EXTENSION IF NOT EXISTS fuzzystrmatch SCHEMA pg_catalog;
CREATE EXTENSION IF NOT EXISTS pg_trgm SCHEMA pg_catalog;

===== ./common/common-kotlin/common-api/common-api-audit/src/main/resources/db/migration/auditEventLog/R__2_proc_create_audit_event_log_partition_table.sql =====
DROP FUNCTION IF EXISTS create_audit_event_log_partition_table;
CREATE OR REPLACE FUNCTION create_audit_event_log_partition_table(
    in_table_name    TEXT,
    in_resource_type TEXT,
    in_timestamp     TIMESTAMP
) RETURNS TEXT AS
$body$
DECLARE
    table_name               TEXT;
    the_table_primary_key    TEXT;
    the_year                 INT;
    the_padded_year          TEXT;
    the_min_timestamp        TEXT;
    the_max_timestamp        TEXT;
    resource_type_table_name TEXT;
    table_short_code         TEXT;
    sql_text                 TEXT;
BEGIN
    -- set statement variables
    the_year = EXTRACT(YEAR FROM in_timestamp);
    the_padded_year = lpad((the_year - 2000)::TEXT, 2, '0');
    the_min_timestamp = the_year::text || '-01-01 00:00:00';
    the_max_timestamp = (the_year + 1)::text || '-01-01 00:00:00';

    resource_type_table_name = lower(in_resource_type || '_' || in_table_name);
    table_name = resource_type_table_name || '_' || the_padded_year;
    table_short_code = get_new_table_short_code(resource_type_table_name, table_name);

    -- Create partition table if not exists
    IF (table_exists(table_name :: TEXT) IS FALSE) THEN
        -- lookup primary key
        the_table_primary_key = get_table_primary_key(in_table_name);

        -- create table
        sql_text = 'CREATE TABLE IF NOT EXISTS ' || table_name || ' ( ' || 'CONSTRAINT ' || 'pk_' || table_short_code || ' PRIMARY KEY (' || the_table_primary_key ||
                   ') ' || ') INHERITS (' || in_table_name || ')';
        EXECUTE sql_text;

        --copy indexes
        PERFORM copy_table_index(in_table_name, table_name, table_short_code);

        --create resource_type constraint
        sql_text = 'ALTER TABLE ' || table_name || ' ADD CONSTRAINT CK_' || table_short_code || '_RESOURCE_TYPE CHECK ' || '( RESOURCE_TYPE = ' ||
                   quote_literal(in_resource_type) || ' )';
        EXECUTE sql_text;

        --create year constraint
        sql_text = 'ALTER TABLE ' || table_name || ' ADD CONSTRAINT CK_' || table_short_code || '_YEAR CHECK ' || '( TIMESTAMP >= ' ||
                   quote_literal(the_min_timestamp) || ' AND TIMESTAMP < ' || quote_literal(the_max_timestamp) || ' )';
        EXECUTE sql_text;
    END IF;

    RETURN table_name;
END;
$body$ LANGUAGE 'plpgsql';

===== ./common/common-kotlin/common-api/common-api-audit/src/main/resources/db/migration/auditEventLog/R__2_proc_create_audit_event_log_client_partition_table.sql =====
DROP FUNCTION IF EXISTS create_audit_event_log_tenant_partition_table;
CREATE OR REPLACE FUNCTION create_audit_event_log_tenant_partition_table(
    in_table_name    TEXT,
    in_resource_type TEXT,
    in_tenant_id     BIGINT,
    in_timestamp     TIMESTAMP
)
    RETURNS TABLE (
        table_name TEXT,
        min_id     BIGINT,
        max_id     BIGINT
    )
AS
$body$
DECLARE
    the_table_primary_key TEXT;
    the_shard_length      INT DEFAULT 6;
    in_tenant_id_length   INT DEFAULT 8;
    the_padded_tenant_id  TEXT;
    the_year              INT;
    the_padded_year       TEXT;
    the_min_timestamp     TEXT;
    the_max_timestamp     TEXT;
    resource_type_table_name TEXT;
    table_short_code      TEXT;
    sql_text                 TEXT;
BEGIN
    -- set statement variables
    the_padded_tenant_id = lpad(in_tenant_id :: TEXT, the_shard_length, '0');
    min_id = in_tenant_id * (10 ^ (in_tenant_id_length));
    max_id = ((in_tenant_id + 1) * (10 ^ (in_tenant_id_length))) - 1;

    the_year = EXTRACT(YEAR FROM in_timestamp);
    the_padded_year = lpad((the_year - 2000)::TEXT, 2, '0');
    the_min_timestamp = the_year::text || '-01-01 00:00:00';
    the_max_timestamp = (the_year + 1)::text || '-01-01 00:00:00';

    resource_type_table_name = lower(in_resource_type || '_' || in_table_name);
    table_name = resource_type_table_name || '_' || the_padded_tenant_id || '_' || the_padded_year;
    table_short_code = get_new_table_short_code(resource_type_table_name, table_name);

    -- Create partition table if not exists
    IF (table_exists(table_name :: TEXT) IS FALSE) THEN
        -- lookup primary key
        the_table_primary_key = get_table_primary_key(in_table_name);

        -- create table
        sql_text = 'CREATE TABLE ' || table_name || '( ' || 'CONSTRAINT ' || 'pk_' || table_short_code || ' PRIMARY KEY (' || the_table_primary_key || ') ' ||
                ') INHERITS (' || in_table_name || ')';
        EXECUTE sql_text;

        --copy indexes
        PERFORM copy_table_index(in_table_name, table_name, table_short_code);

        --create scoped id constraint
        sql_text = 'ALTER TABLE ' || table_name || ' ADD CONSTRAINT CK_' || table_short_code || '_RESOURCE_ID CHECK ' || '( RESOURCE_ID >= ' || min_id ||
                ' AND RESOURCE_ID < ' || max_id || ' )';
        EXECUTE sql_text;

        --create tenant_id constraint
        sql_text = 'ALTER TABLE ' || table_name || ' ADD CONSTRAINT CK_' || table_short_code || '_TENANT_ID CHECK ' || '( TENANT_ID = ' || in_tenant_id ||
                ' )';
        EXECUTE sql_text;

        --create resource_type constraint
        sql_text = 'ALTER TABLE ' || table_name || ' ADD CONSTRAINT CK_' || table_short_code || '_RESOURCE_TYPE CHECK ' || '( RESOURCE_TYPE = ' ||
                quote_literal(in_resource_type) || ' )';
        EXECUTE sql_text;

        --create year constraint
        sql_text = 'ALTER TABLE ' || table_name || ' ADD CONSTRAINT CK_' || table_short_code || '_YEAR CHECK ' || '( TIMESTAMP >= ' ||
                quote_literal(the_min_timestamp) || ' AND TIMESTAMP < ' || quote_literal(the_max_timestamp) || ' )';
        EXECUTE sql_text;
    END IF;

    RETURN QUERY (
        SELECT table_name, min_id, max_id
    );
END;
$body$ LANGUAGE 'plpgsql';

===== ./common/common-kotlin/common-api/common-api-audit/build.gradle.kts =====
plugins {
   alias(libs.plugins.jvm)
   alias(libs.plugins.kapt)
   alias(libs.plugins.allopen)
   alias(libs.plugins.jpa)
   alias(libs.plugins.shadow)
   alias(libs.plugins.application)
}

repositories {
    mavenCentral()
}

dependencies {
    api(project(":common:common-kotlin:common-api:common-api-db"))
    api(project(":common:common-kotlin:common-api:common-api-model"))
    api(project(":common:common-kotlin:common-api:common-api-multitenant"))
    testImplementation(project(":common:common-kotlin:common-api:common-api-test"))

    annotationProcessor("io.micronaut:micronaut-inject-java")
    compileOnly("io.micronaut:micronaut-aop")

    implementation(platform("io.micronaut.platform:micronaut-platform"))
    implementation(platform("aws.sdk.kotlin:bom:1.4.92"))
    kapt(annotationProcessorLibs.bundles.commonAnnotationProcessors)
    implementation(libs.bundles.commonLibs)
    implementation(libs.bundles.dbLibs)
    implementation(libs.bundles.webServiceLibs)
    implementation(libs.bundles.securityLibs)

    compileOnly(libs.bundles.compileOnlyLibs)
}

application {
    mainClass.set("net.blugrid.api.ApplicationKt")
}
java {
    sourceCompatibility = JavaVersion.toVersion("17")
}
kapt {
    arguments {
        arg("micronaut.openapi.project.dir", projectDir.toString())
    }
}
kotlin {
    jvmToolchain {
        languageVersion.set(JavaLanguageVersion.of(17))
    }
}

graalvmNative.toolchainDetection = false
micronaut {
    runtime("netty")
    testRuntime("junit5")
    processing {
        incremental(true)
        annotations("net.blugrid.api.*")
    }
}

===== ./common/common-kotlin/common-api/common-api-audit/gradle.properties =====
micronautVersion=4.4.3
kotlinVersion=1.9.23

===== ./common/common-kotlin/common-api/common-api-client/src/main/kotlin/net/blugrid/api/common/organisation/HttpClient.kt =====
package net.blugrid.api.common.organisation

import io.micronaut.core.type.Argument
import io.micronaut.data.model.Page
import io.micronaut.http.HttpRequest
import io.micronaut.http.HttpResponse
import io.micronaut.http.MutableHttpRequest
import io.micronaut.http.client.HttpClient
import io.micronaut.http.cookie.Cookie
import io.netty.handler.codec.http.cookie.DefaultCookie
import net.blugrid.api.common.search.SearchPage

inline fun <T, reified U> HttpClient.post(
    path: String,
    payload: T,
    responseType: Argument<U>,
): HttpResponse<U> {
    return toBlocking().exchange(HttpRequest.POST(path, payload), responseType)
}

inline fun <T, reified U> HttpClient.put(
    path: String,
    payload: T,
    responseType: Argument<U>,
): HttpResponse<U> {
    return toBlocking().exchange(HttpRequest.PUT(path, payload), responseType)
}

inline fun <reified T> HttpClient.get(
    path: String,
    responseType: Argument<T>,
): HttpResponse<T> {
    return toBlocking().exchange(HttpRequest.GET<Unit>(path), responseType)
}

@Suppress("UNCHECKED_CAST")
fun <T> pageOf(type: Class<T>): Argument<Page<T>> {
    return Argument.of(Page::class.java as Class<Page<T>>, type)
}

@Suppress("UNCHECKED_CAST")
fun <T, S> searchPageOf(contactType: Class<T>, searchResultsType: Class<S>): Argument<SearchPage<T, S>> {
    return Argument.of(SearchPage::class.java as Class<SearchPage<T, S>>, contactType, searchResultsType)
}

@Suppress("UNCHECKED_CAST")
fun <T> listArgumentOf(type: Class<T>): Argument<List<T>> {
    return Argument.of(List::class.java as Class<List<T>>, type)
}

===== ./common/common-kotlin/common-api/common-api-client/build.gradle.kts =====
plugins {
   alias(libs.plugins.jvm)
   alias(libs.plugins.kapt)
   alias(libs.plugins.allopen)
   alias(libs.plugins.jpa)
   alias(libs.plugins.shadow)
   alias(libs.plugins.application)
}

repositories {
    mavenCentral()
}

dependencies {
    api(project(":common:common-kotlin:common-api:common-api-model"))

    implementation(libs.bundles.commonLibs)
    implementation(libs.bundles.webServiceLibs)
    implementation(libs.bundles.securityLibs)
}
java {
    sourceCompatibility = JavaVersion.toVersion("17")
}
kapt {
    arguments {
        arg("micronaut.openapi.project.dir", projectDir.toString())
    }
}
kotlin {
    jvmToolchain {
        languageVersion.set(JavaLanguageVersion.of(17))
    }
}

graalvmNative.toolchainDetection = false
micronaut {
    runtime("netty")
    testRuntime("junit5")
    processing {
        incremental(true)
        annotations("net.blugrid.api.*")
    }
}

application {
    mainClass.set("net.blugrid.api.ApplicationKt")
}


===== ./common/common-kotlin/common-api/common-api-client/gradle.properties =====
micronautVersion=4.4.3
kotlinVersion=1.9.23

===== ./common/common-kotlin/common-api/common-api-grpc/src/main/kotlin/net/blugrid/common/grpc/util/GrpcValidator.kt =====
package net.blugrid.common.grpc.util

import io.micronaut.validation.validator.Validator
import jakarta.validation.ConstraintViolationException

object GrpcValidator {
    inline fun <reified T> validate(validator: Validator, block: () -> T): T {
        val model = block()
        val violations = validator.validate(model)
        if (violations.isNotEmpty()) {
            throw ConstraintViolationException(violations)
        }
        return model
    }
}

===== ./common/common-kotlin/common-api/common-api-grpc/src/main/kotlin/net/blugrid/common/grpc/model/exception/NotFoundException.kt =====
package net.blugrid.common.grpc.model.exception

class NotFoundException(
    val resourceType: String,
    val resourceId: String,
    message: String? = "$resourceType with ID $resourceId not found"
) : RuntimeException(message)

===== ./common/common-kotlin/common-api/common-api-grpc/src/main/kotlin/net/blugrid/common/grpc/model/exception/InvalidRequestException.kt =====
package net.blugrid.common.grpc.model.exception

import jakarta.validation.ConstraintViolation

data class ConstraintViolationDetail(val field: String, val description: String)

class InvalidRequestException(val violations: List<ConstraintViolationDetail>) : RuntimeException()

fun Set<ConstraintViolation<*>>.throwIfInvalid() {
    if (this.isNotEmpty()) {
        throw InvalidRequestException(map {
            ConstraintViolationDetail(it.propertyPath.toString(), it.message)
        })
    }
}

===== ./common/common-kotlin/common-api/common-api-grpc/src/main/kotlin/net/blugrid/common/grpc/mapper/SortProtoMapper.kt =====
package net.blugrid.common.grpc.mapper

import net.blugrid.api.common.grpc.Sort
import net.blugrid.api.common.grpc.Order
import net.blugrid.api.common.grpc.Direction
import io.micronaut.data.model.Sort as MnSort

/**
 * Convert from gRPC proto Sort to Micronaut Data Sort.
 */
fun Sort.toMicronautSort(): MnSort {
    if (!this.sorted || this.orderByList.isEmpty()) {
        return MnSort.unsorted()
    }

    val orders = this.orderByList.map {
        val direction = when (it.direction) {
            Direction.DESC -> MnSort.Order.Direction.DESC
            Direction.ASC, Direction.UNRECOGNIZED, null -> MnSort.Order.Direction.ASC
        }

        MnSort.Order(it.property, direction, it.ignoreCase)
    }

    return MnSort.of(orders)
}

/**
 * Convert from Micronaut Data Sort to gRPC proto Sort.
 */
fun MnSort.toProto(): Sort {
    if (!this.isSorted || this.orderBy.isEmpty()) {
        return Sort.newBuilder()
            .setSorted(false)
            .build()
    }

    val orders = this.orderBy.map {
        val direction = when (it.direction) {
            MnSort.Order.Direction.DESC -> Direction.DESC
            MnSort.Order.Direction.ASC -> Direction.ASC
        }

        Order.newBuilder()
            .setProperty(it.property)
            .setDirection(direction)
            .setIgnoreCase(it.isIgnoreCase)
            .build()
    }

    return Sort.newBuilder()
        .addAllOrderBy(orders)
        .setSorted(true)
        .build()
}

===== ./common/common-kotlin/common-api/common-api-grpc/src/main/kotlin/net/blugrid/common/grpc/service/GrpcServiceBase.kt =====
package net.blugrid.common.grpc.service

import com.google.protobuf.Any
import com.google.rpc.BadRequest
import com.google.rpc.Code
import com.google.rpc.Status
import io.grpc.protobuf.StatusProto
import net.blugrid.common.grpc.model.exception.ConstraintViolationDetail
import net.blugrid.common.grpc.model.exception.InvalidRequestException
import net.blugrid.common.grpc.model.exception.NotFoundException

abstract class GrpcServiceBase {

    protected suspend fun <T> safe(call: suspend () -> T): T =
        try {
            call()
        } catch (ex: InvalidRequestException) {
            throw StatusProto.toStatusRuntimeException(
                buildBadRequestStatus("Validation failed", ex.violations)
            )
        } catch (ex: NotFoundException) {
            throw StatusProto.toStatusRuntimeException(
                Status.newBuilder()
                    .setCode(Code.NOT_FOUND_VALUE)
                    .setMessage(ex.message)
                    .build()
            )
        } catch (ex: Exception) {
            throw StatusProto.toStatusRuntimeException(
                Status.newBuilder()
                    .setCode(Code.INTERNAL_VALUE)
                    .setMessage("Unexpected error occurred")
                    .build()
            )
        }
}

fun buildBadRequestStatus(message: String, violations: List<ConstraintViolationDetail>): Status {
    val badRequest = BadRequest.newBuilder().apply {
        violations.forEach {
            addFieldViolations(
                BadRequest.FieldViolation.newBuilder()
                    .setField(it.field)
                    .setDescription(it.description)
                    .build()
            )
        }
    }.build()

    return Status.newBuilder()
        .setCode(Code.INVALID_ARGUMENT_VALUE)
        .setMessage(message)
        .addDetails(Any.pack(badRequest))
        .build()
}

===== ./common/common-kotlin/common-api/common-api-grpc/build.gradle.kts =====
plugins {
   alias(libs.plugins.jvm)
   alias(libs.plugins.kapt)
}

version = "0.1.0"
group = "net.blugrid.api"

repositories {
    mavenCentral()
}

dependencies {
    api(project(":common:common-kotlin:common-api:common-api-model"))
    implementation(project(":common:common-kotlin:common-api:common-api-grpc-proto"))

    implementation(platform("io.micronaut.platform:micronaut-platform"))

    implementation(libs.bundles.grpcCommonLibs)
    implementation(libs.bundles.grpcServerLibs)
}

java {
    sourceCompatibility = JavaVersion.toVersion("17")
}

kotlin {
    jvmToolchain {
        languageVersion.set(JavaLanguageVersion.of(17))
    }
}


===== ./common/common-kotlin/common-api/common-api-grpc/gradle.properties =====
micronautVersion=4.4.3
kotlinVersion=1.9.23

===== ./common/common-kotlin/common-api/common-api-grpc-proto/src/main/proto/common/Status.proto =====
syntax = "proto3";

package net.blugrid.api.common.grpc;

option java_multiple_files = true;


message Status {
  google.rpc.ErrorInfo error_info = 1;
}

===== ./common/common-kotlin/common-api/common-api-grpc-proto/src/main/proto/common/PageRequest.proto =====
syntax = "proto3";

package net.blugrid.api.common.grpc;

option java_multiple_files = true;

// Used in paged queries, maps to Micronaut's Sort
message Sort {
  repeated Order orderBy = 1;

  // If no orderBy entries exist, it's UNSORTED
  bool sorted = 2;
}

// Matches Micronaut's Sort.Order
message Order {
  string property = 1;
  Direction direction = 2;
  bool ignoreCase = 3;
}

// Enum for ASC/DESC
enum Direction {
  ASC = 0;
  DESC = 1;
}

===== ./common/common-kotlin/common-api/common-api-grpc-proto/build.gradle.kts =====
import com.google.protobuf.gradle.id

plugins {
   alias(libs.plugins.jvm)
    id("com.google.protobuf") version "0.9.4"
}

version = "0.1.0"
group = "net.blugrid.api"

repositories {
    mavenCentral()
}

dependencies {
    implementation("io.grpc:grpc-kotlin-stub:1.3.0")
    implementation("javax.annotation:javax.annotation-api:1.3.2")

    implementation("io.grpc:grpc-stub:1.62.2")
    implementation("io.grpc:grpc-netty-shaded:1.62.2")
    implementation("io.grpc:grpc-protobuf:1.62.2")
    implementation("com.google.api.grpc:proto-google-common-protos:2.59.0")
    implementation("com.google.protobuf:protobuf-java:4.31.1")
    implementation("com.google.protobuf:protobuf-kotlin:4.31.1")
}

java {
    sourceCompatibility = JavaVersion.toVersion("17")
}

kotlin {
    jvmToolchain {
        languageVersion.set(JavaLanguageVersion.of(17))
    }
}

protobuf {
    protoc {
        artifact = "com.google.protobuf:protoc:4.31.1"
    }
    plugins {
        id("grpc") {
            artifact = "io.grpc:protoc-gen-grpc-java:1.62.2"
        }
        id("grpckt") {
            artifact = "io.grpc:protoc-gen-grpc-kotlin:1.3.0:jdk8@jar"
        }
    }
    generateProtoTasks {
        all().forEach {
            it.builtins {
                id("kotlin")
            }
            it.plugins {
                id("grpc")
                id("grpckt")
            }
        }
    }
}

sourceSets["main"].java.srcDirs(
    "build/generated/source/proto/main/java",
    "build/generated/source/proto/main/grpc",
    "build/generated/source/proto/main/grpckt"
)

sourceSets["main"].proto.srcDir("src/main/proto")


===== ./common/common-kotlin/common-api/common-api-grpc-proto/gradle.properties =====
micronautVersion=4.4.3
kotlinVersion=1.9.23

===== ./common/common-kotlin/common-api/common-api-json/src/main/kotlin/net/blugrid/api/json/config/ObjectMapperBeanListener.kt =====
//package net.blugrid.api.json.config
//
//import com.fasterxml.jackson.databind.ObjectMapper
//import io.micronaut.context.event.BeanCreatedEvent
//import io.micronaut.context.event.BeanCreatedEventListener
//import jakarta.inject.Singleton
//
//@Singleton
//open class ObjectMapperBeanEventListener(
//    private val objectMapperFactory: CustomObjectMapperFactory
//) : BeanCreatedEventListener<ObjectMapper> {
//
//    override fun onCreated(event: BeanCreatedEvent<ObjectMapper>): ObjectMapper {
//        return objectMapperFactory.objectMapper(null, null)
//    }
//}

===== ./common/common-kotlin/common-api/common-api-json/src/main/kotlin/net/blugrid/api/json/config/CustomObjectMapperFactory.kt =====
package net.blugrid.api.json.config

import com.fasterxml.jackson.annotation.JsonInclude
import com.fasterxml.jackson.core.JsonFactory
import com.fasterxml.jackson.core.JsonGenerator
import com.fasterxml.jackson.core.StreamReadFeature
import com.fasterxml.jackson.databind.DeserializationFeature
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.databind.SerializationFeature
import com.fasterxml.jackson.databind.SerializerProvider
import com.fasterxml.jackson.databind.module.SimpleModule
import com.fasterxml.jackson.databind.ser.std.StdSerializer
import com.fasterxml.jackson.datatype.jdk8.Jdk8Module
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer
import com.fasterxml.jackson.module.kotlin.KotlinModule
import io.micronaut.context.annotation.Replaces
import io.micronaut.jackson.JacksonConfiguration
import io.micronaut.jackson.ObjectMapperFactory
import jakarta.inject.Singleton
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

@Singleton
@Replaces(ObjectMapperFactory::class)
open class CustomObjectMapperFactory : ObjectMapperFactory() {

    companion object {
        lateinit var objectMapper: ObjectMapper

        private const val LOCAL_DATE_TIME_FORMAT = "yyyy-MM-dd'T'HH:mm:ss.SSS"
    }

    @Singleton
    @Replaces(ObjectMapper::class)
    override fun objectMapper(jacksonConfiguration: JacksonConfiguration?, jsonFactory: JsonFactory?): ObjectMapper {
        val factory = JsonFactory.builder()
            .enable(StreamReadFeature.INCLUDE_SOURCE_IN_LOCATION)
            .build()

        objectMapper = super.objectMapper(jacksonConfiguration, factory)

        // JsonGenerator
        objectMapper.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true)

        // Serialization
        objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false)
        objectMapper.configure(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS, false)
        objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false)
        objectMapper.configure(SerializationFeature.WRITE_ENUMS_USING_TO_STRING, true)
        // configure(WRITE_NUMBERS_AS_STRINGS.mappedFeature(), true)
        // NB: Consul registration fail if port number (Integer) is string. Replaced with custom serializer for Longs only.

        // Deserialization
        objectMapper.configure(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT, true)
        objectMapper.configure(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true)
        objectMapper.configure(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY, true)
        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)
        objectMapper.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, false)
        objectMapper.configure(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS, false)
        objectMapper.configure(DeserializationFeature.READ_ENUMS_USING_TO_STRING, true)
        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL)
        objectMapper.registerModule(Jdk8Module())
        objectMapper.registerModule(KotlinModule.Builder().build())
        objectMapper.registerModule(
            SimpleModule()
                .addSerializer(
                    Long::class.java,
                    LongToStringSerializer()
                )
        )
        objectMapper.registerModule(
            JavaTimeModule()
                .addSerializer(LocalDateTimeSerializer(DateTimeFormatter.ofPattern(LOCAL_DATE_TIME_FORMAT))) // .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(LOCAL_DATE_TIME_FORMAT)))
                .addDeserializer(
                    LocalDateTime::class.java,
                    LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(LOCAL_DATE_TIME_FORMAT)),
                ),
        )
        return objectMapper
    }
}

class LongToStringSerializer : StdSerializer<Long>(Long::class.java) {
    override fun serialize(value: Long?, generator: JsonGenerator, provider: SerializerProvider) {
        value?.let {
            generator.writeString(it.toString())
        }
            ?: generator.writeNull()
    }
}




===== ./common/common-kotlin/common-api/common-api-json/src/main/kotlin/net/blugrid/api/json/config/DbLocalDateTimeDeserializer.kt =====
// package net.blugrid.api.json.config
//
// import net.blugrid.api.common.logging.logger
// import io.jsonwebtoken.io.Deserializer
// import io.micronaut.context.annotation.Primary
// import io.micronaut.core.type.Argument
// import io.micronaut.serde.Decoder
// import io.micronaut.serde.Deserializer
// import io.micronaut.serde.Deserializer.DecoderContext
// import jakarta.inject.Singleton
// import java.time.LocalDateTime
// import java.time.format.DateTimeFormatter
// import java.time.format.DateTimeParseException
//
// @Singleton
// @Primary
// class DbLocalDateTimeDeserializer : Deserializer<LocalDateTime> {
//
//    private val log = logger()
//
//    companion object {
//        private val FORMATTERS = listOf(
//            DateTimeFormatter.ISO_DATE_TIME,
//            DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSSSSSxxx"),
//        )
//    }
//
//    override fun deserialize(decoder: Decoder, context: DecoderContext, type: Argument<in LocalDateTime>): LocalDateTime? {
//        val str = decoder.decodeString()
//        return FORMATTERS.firstNotNullOf { it.tryDeserialize(str) }
//    }
//
//    private fun DateTimeFormatter.tryDeserialize(date: String): LocalDateTime? {
//        return try {
//            LocalDateTime.parse(date, this)
//        } catch (e: DateTimeParseException) {
//            log.warn("Cannot deserialize date ($date) with Format (${this}): ${e.cause}")
//            null
//        }
//    }
// }

===== ./common/common-kotlin/common-api/common-api-json/src/main/kotlin/net/blugrid/api/json/Json.kt =====
package net.blugrid.api.json

import com.fasterxml.jackson.core.JsonProcessingException
import com.fasterxml.jackson.core.type.TypeReference
import com.fasterxml.jackson.databind.JsonNode
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.module.kotlin.readValue
import net.blugrid.api.json.config.CustomObjectMapperFactory
import net.blugrid.api.json.exception.JsonException
import java.io.IOException
import java.io.InputStream


val objectMapper: ObjectMapper = CustomObjectMapperFactory.objectMapper

inline fun <reified T : Any> String.fromJson() = objectMapper.readValue<T>(this)

inline fun <reified R : Any> R.toJson() = objectToJson(this)

fun <T> readValue(json: String?, valueType: Class<T>?): T =
    try {
        objectMapper.readValue(json, valueType)
    } catch (e: JsonProcessingException) {
        throw JsonException(e)
    }

fun <T> fromJson(bytes: ByteArray?, typeRef: TypeReference<T>?): T =
    try {
        objectMapper.readValue(bytes, typeRef)
    } catch (e: IOException) {
        throw JsonException(e)
    }

fun <T> fromJson(json: String?, typeRef: TypeReference<T>?): T {
    return try {
        objectMapper.readValue(json, typeRef)
    } catch (e: IOException) {
        throw JsonException(e)
    }
}

fun <T> fromNode(node: JsonNode, typeRef: TypeReference<T>?): T = try {
    objectMapper.readValue(node.toString(), typeRef)
} catch (e: IOException) {
    throw JsonException(e)
}

fun <T> fromObject(obj: Any?, typeRef: TypeReference<T>?): T = try {
    objectMapper.readValue(objectToJson(obj), typeRef)
} catch (e: IOException) {
    throw JsonException(e)
}

fun <T> fromInputStream(`is`: InputStream?, typeRef: TypeReference<T>?): T = try {
    objectMapper.readValue(`is`, typeRef)
} catch (e: IOException) {
    throw JsonException(e)
}

fun objectToJson(obj: Any?): String {
    return try {
        objectMapper.writeValueAsString(obj)
    } catch (e: IOException) {
        throw JsonException(e)
    }
}

fun toPrettyJson(obj: Any?): String = try {
    objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(obj)
} catch (e: IOException) {
    throw JsonException(e)
}

fun toByteArray(obj: Any?): ByteArray = try {
    objectMapper.writeValueAsBytes(obj)
} catch (e: IOException) {
    throw JsonException(e)
}

fun mapFromJson(bytes: ByteArray?): Map<String, Any> = try {
    objectMapper.readValue(bytes, object : TypeReference<Map<String, Any>>() {})
} catch (e: IOException) {
    throw JsonException(e)
}

fun mapFromJson(json: String?): Map<String, Any> = try {
    objectMapper.readValue(json, object : TypeReference<Map<String, Any>>() {})
} catch (e: IOException) {
    throw JsonException(e)
}

fun <T> deserializeListFromJson(json: String?, type: Class<T>?): List<T> = try {
    objectMapper.readValue(json, objectMapper.typeFactory.constructCollectionType(MutableList::class.java, type))
} catch (e: IOException) {
    throw JsonException(e)
}

fun <T> deserializeFromJson(json: String?, type: Class<T>?): T = try {
    objectMapper.readValue(json, objectMapper.typeFactory.constructType(type))
} catch (e: IOException) {
    throw JsonException(e)
}

fun <T> deserializeFromObject(`object`: Any?, type: Class<T>?): T = try {
    val json = objectToJson(`object`)
    objectMapper.readValue(json, objectMapper.typeFactory.constructType(type))
} catch (e: IOException) {
    throw JsonException(e)
}

fun <T> deserializeFromObjectList(input: List<Any?>?, type: Class<T>?): List<T> {
    val content: MutableList<T> = ArrayList()
    input?.stream()?.forEach { item: Any? -> content.add(deserializeFromObject(item, type)) }
    return content
}

fun nodeFromJson(json: String?): JsonNode = try {
    objectMapper.readTree(json)
} catch (e: IOException) {
    throw JsonException(e)
}

fun nodeFromObject(obj: Any?): JsonNode = try {
    objectMapper.readTree(objectToJson(obj))
} catch (e: IOException) {
    throw JsonException(e)
}

===== ./common/common-kotlin/common-api/common-api-json/src/main/kotlin/net/blugrid/api/json/exception/JsonException.kt =====
package net.blugrid.api.json.exception

class JsonException(ex: Exception) : RuntimeException(ex)

===== ./common/common-kotlin/common-api/common-api-json/src/main/kotlin/net/blugrid/api/json/JsonPath.kt =====
package net.blugrid.api.json

import com.nfeld.jsonpathkt.JsonPath
import com.nfeld.jsonpathkt.extension.read

inline fun <reified T : Any> String.readAs(path: String): T? =
    JsonPath.parse(this)?.read(path)

fun String.read(path: String): String? =
    JsonPath.parse(this)?.read(path)

===== ./common/common-kotlin/common-api/common-api-json/src/main/resources/application-json.yml =====
jackson:
  serialization:
    write-bigdecimal-as-plain: true
    write-date-timestamps-as-nanoseconds: false
    write-dates-as-timestamps: false
    write-enums-using-to-string: true
    write_numbers_as_strings: true

  deserialization:
    read-date-timestamps-as-nanoseconds: false
    read-enums-using-to-string: true

===== ./common/common-kotlin/common-api/common-api-json/src/test/kotlin/net/blugrid/api/json/DeserialisationTests.kt =====
package net.blugrid.api.json

import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.databind.exc.MismatchedInputException
import io.micronaut.test.extensions.junit5.annotation.MicronautTest
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertThrows
import java.math.BigDecimal

@MicronautTest
class SerdeTests {

    val ServiceEntryJson = "{\n" +
        "      \"ID\": \"rest-api:8080\",\n" +
        "      \"Service\": \"rest-api\",\n" +
        "      \"Tags\": [],\n" +
        "      \"Address\": \"fedora\",\n" +
        "      \"Meta\": null,\n" +
        "      \"Port\": 8080,\n" +
        "      \"Weights\": {\n" +
        "        \"Passing\": 1,\n" +
        "        \"Warning\": 1\n" +
        "      },\n" +
        "      \"EnableTagOverride\": false,\n" +
        "      \"Proxy\": {\n" +
        "        \"MeshGateway\": {},\n" +
        "        \"Expose\": {}\n" +
        "      },\n" +
        "      \"Connect\": {},\n" +
        "      \"CreateIndex\": 177,\n" +
        "      \"ModifyIndex\": 177\n" +
        "    }"

    data class testSalesReportPeriod(
        val qty: BigDecimal = BigDecimal.ZERO,
        val reportPeriodId: Long
    )

    data class testSalesOptionalReportPeriod(
        val qty: BigDecimal = BigDecimal.ZERO,
        val reportPeriodId: Long? = null
    )

//    @Test
//    fun `Test Consul Service Entry`(objectMapper: ObjectMapper) {
//        val consulServiceEntry = objectMapper.readValue(ServiceEntryJson, ServiceEntry::class.java)
//        Assertions.assertNotNull(consulServiceEntry)
//    }

    @Test
    fun `Test Sales Entry`(objectMapper: ObjectMapper) {
        assertThrows<MismatchedInputException> { objectMapper.readValue("{\"qty\":2}", testSalesReportPeriod::class.java) }
    }

    @Test
    fun `Test Sales Optional Entry`(objectMapper: ObjectMapper) {
        val testSalesReportPeriod = objectMapper.readValue("{\"qty\":2}", testSalesOptionalReportPeriod::class.java)
        Assertions.assertNotNull(testSalesReportPeriod)
        Assertions.assertNull(testSalesReportPeriod.reportPeriodId)
    }
}

===== ./common/common-kotlin/common-api/common-api-json/build.gradle.kts =====
plugins {
   alias(libs.plugins.jvm)
   alias(libs.plugins.kapt)
   alias(libs.plugins.allopen)
   alias(libs.plugins.jpa)
   alias(libs.plugins.shadow)
   alias(libs.plugins.application)
}

repositories {
    mavenCentral()
}

dependencies {
    api(project(":common:common-kotlin:common-api:common-api-model"))

    implementation(libs.bundles.commonLibs)
    implementation(libs.bundles.webServiceLibs)
}
java {
    sourceCompatibility = JavaVersion.toVersion("17")
}
kapt {
    arguments {
        arg("micronaut.openapi.project.dir", projectDir.toString())
    }
}
kotlin {
    jvmToolchain {
        languageVersion.set(JavaLanguageVersion.of(17))
    }
}

graalvmNative.toolchainDetection = false
micronaut {
    runtime("netty")
    testRuntime("junit5")
    processing {
        incremental(true)
        annotations("net.blugrid.api.*")
    }
}

application {
    mainClass.set("net.blugrid.api.ApplicationKt")
}


===== ./common/common-kotlin/common-api/common-api-json/gradle.properties =====
micronautVersion=4.4.3
kotlinVersion=1.9.23

===== ./common/common-kotlin/common-api/common-api-logging/src/main/kotlin/net/blugrid/api/logging/Logger.kt =====
package net.blugrid.api.logging

import org.slf4j.LoggerFactory
import kotlin.reflect.full.companionObject

inline fun <reified R : Any> R.logger() = logger(R::class.java)

fun logger(clazz: Class<*>) = LoggerFactory.getLogger(unwrapCompanionClass(clazz))

// unwrap companion class to enclosing class given a Java Class
private fun <T : Any> unwrapCompanionClass(ofClass: Class<T>): Class<*> {
    return if (ofClass.enclosingClass != null && ofClass.enclosingClass.kotlin.companionObject?.java == ofClass) {
        ofClass.enclosingClass
    } else {
        ofClass
    }
}

===== ./common/common-kotlin/common-api/common-api-logging/src/main/resources/application-logging.yml =====
logger:
  levels:
    net.blugrid.api: DEBUG

===== ./common/common-kotlin/common-api/common-api-logging/src/main/resources/application-test-logging.yml =====

logger:
  levels:
    net.blugrid.api: DEBUG
    org.hibernate.SQL: DEBUG
    org.hibernate.orm.jdbc.extract: TRACE
    org.hibernate.orm.jdbc.bind: TRACE

===== ./common/common-kotlin/common-api/common-api-logging/src/main/resources/application-debug-logging.yml =====

logger:
  levels:
    net.blugrid.api: DEBUG
#    org.hibernate: TRACE
    org.hibernate.SQL: DEBUG
    org.hibernate.orm.jdbc.extract: TRACE
    org.hibernate.orm.jdbc.bind: TRACE
    org.hibernate.engine.transaction.internal.TransactionImpl: DEBUG
    io.micronaut.http.client: TRACE
    io.micronaut.discovery: INFO
    io.micronaut.http.server: TRACE
    io.micronaut.json: INFO
    io.micronaut.security: DEBUG

===== ./common/common-kotlin/common-api/common-api-logging/build.gradle.kts =====
plugins {
   alias(libs.plugins.jvm)
   alias(libs.plugins.kapt)
   alias(libs.plugins.allopen)
   alias(libs.plugins.jpa)
   alias(libs.plugins.shadow)
   alias(libs.plugins.application)
}

repositories {
    mavenCentral()
}

dependencies {
    api(project(":common:common-kotlin:common-api:common-api-model"))

    implementation(libs.bundles.commonLibs)
    implementation(libs.bundles.webServiceLibs)
}
java {
    sourceCompatibility = JavaVersion.toVersion("17")
}
kapt {
    arguments {
        arg("micronaut.openapi.project.dir", projectDir.toString())
    }
}
kotlin {
    jvmToolchain {
        languageVersion.set(JavaLanguageVersion.of(17))
    }
}

graalvmNative.toolchainDetection = false
micronaut {
    runtime("netty")
    testRuntime("junit5")
    processing {
        incremental(true)
        annotations("net.blugrid.api.*")
    }
}

application {
    mainClass.set("net.blugrid.api.ApplicationKt")
}


===== ./common/common-kotlin/common-api/common-api-logging/gradle.properties =====
micronautVersion=4.4.3
kotlinVersion=1.9.23

===== ./common/common-kotlin/common-api/common-api-persistence/src/main/kotlin/net/blugrid/api/common/repository/model/TenantScopeEmbeddable.kt =====
package net.blugrid.api.common.repository.model

import io.micronaut.data.annotation.Embeddable

@Embeddable
data class TenantScopeEmbeddable(
    override var tenantId: Long? = null
) : TenantScoped

===== ./common/common-kotlin/common-api/common-api-persistence/build.gradle.kts =====
plugins {
    alias(libs.plugins.jvm)
    alias(libs.plugins.jpa)
}

version = "0.1"
group = "net.blugrid.api"

repositories {
    mavenCentral()
}

dependencies {
    // core JPA + Hibernate types
    implementation(libs.bundles.dbLibs)

    // depends on domain primitives and scope interfaces only
    api(project(":common:common-kotlin:common-api:common-api-domain"))
    api(project(":common:common-kotlin:common-api:common-api-multitenant"))

    // optional ‚Äî for validation annotations
    implementation("jakarta.validation:jakarta.validation-api:3.0.2")
}

java {
    sourceCompatibility = JavaVersion.toVersion("17")
}

kotlin {
    jvmToolchain {
        languageVersion.set(JavaLanguageVersion.of(17))
    }
}

===== ./common/common-kotlin/common-api/common-api-persistence/gradle.properties =====
micronautVersion=4.4.3
kotlinVersion=1.9.23

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/db/TenantSequence.kt =====
package net.blugrid.api.db

import jakarta.inject.Singleton
import net.blugrid.api.config.DbProps
import net.blugrid.api.db.service.DatabaseService
import org.hibernate.engine.jdbc.spi.JdbcCoordinator
import org.hibernate.engine.spi.SharedSessionContractImplementor
import java.sql.SQLException

interface TenantSequence {
    fun tenantNextVal(session: SharedSessionContractImplementor, inputName: String, tenantId: Long): Long
}

@Singleton
class TenantSequenceImpl(
    private val DbProps: DbProps,
    private val databaseService: DatabaseService,
) : TenantSequence {

    override fun tenantNextVal(session: SharedSessionContractImplementor, inputName: String, tenantId: Long): Long {
        val jdbcCoordinator = session.jdbcCoordinator
        val defaultSchemaName = DbProps.schema
        val (schemaName, tableName) = parseInputName(inputName, defaultSchemaName)

        // 4. Check if the input_name (including schema) refers to an existing sequence
        if (sequenceExists(jdbcCoordinator, schemaName, tableName)) {
            // If table_name already refers to a sequence, call nextval directly
            return executeNextVal(jdbcCoordinator, inputName)
                .also { jdbcCoordinator.afterStatementExecution() }
        } else {
            // 5. Generate the sequence name based on table and tenant_id
            val isTenantTable = isTenantTable(jdbcCoordinator, tableName)
            val seqName = generateSequenceName(tableName, tenantId, isTenantTable)

            // 7. Check if the sequence already exists
            if (!sequenceExists(jdbcCoordinator, schemaName, seqName)) {
                // 8. If the sequence does not exist, create it with the appropriate settings
                createSequence(jdbcCoordinator, seqName, tenantId, isTenantTable)
            }

            // 11. Use the sequence to get the next ID value
            return executeNextVal(jdbcCoordinator, "$schemaName.$seqName")
                .also { jdbcCoordinator.afterStatementExecution() }
        }
    }

    private fun parseInputName(inputName: String, defaultSchemaName: String): Pair<String, String> {
        val schemaName = inputName.substringBefore('.', defaultSchemaName)
        val tableName = inputName.substringAfter('.', inputName)
        return schemaName to tableName
    }

    private fun sequenceExists(jdbcCoordinator: JdbcCoordinator, schemaName: String, sequenceName: String): Boolean {
        val sql = "SELECT EXISTS(SELECT 1 FROM pg_sequences WHERE schemaname = ? AND sequencename = ?)"
        val params = listOf(schemaName, sequenceName)
        return databaseService.executeQuery(jdbcCoordinator, sql, params).use { rs ->
            rs?.next() == true && rs.getBoolean(1)
        }
    }

    private fun isTenantTable(jdbcCoordinator: JdbcCoordinator, tableName: String): Boolean {
        val sql = "SELECT table_column_exists(?, 'tenant_id') AND ? != 'organisation'"
        val params = listOf(tableName, tableName)
        return databaseService.executeQuery(jdbcCoordinator, sql, params).use { rs ->
            rs?.next() == true && rs.getBoolean(1)
        }
    }

    private fun generateSequenceName(tableName: String, tenantId: Long?, isTenantTable: Boolean): String {
        return if (isTenantTable && tenantId != null) {
            "seq_${tableName}_$tenantId"
        } else {
            "seq_$tableName"
        }
    }

    private fun createSequence(jdbcCoordinator: JdbcCoordinator, seqName: String, tenantId: Long?, isTenantTable: Boolean) {
        val sql: String
        val params: List<Any>

        if (isTenantTable && tenantId != null) {
            val tenantDetails = getTenantSequenceDetails(jdbcCoordinator, tenantId)
            sql = "CREATE SEQUENCE $seqName START WITH ? MINVALUE ? MAXVALUE ?"
            params = listOf(tenantDetails.minId + 1, tenantDetails.minId, tenantDetails.maxId)
        } else {
            sql = "CREATE SEQUENCE $seqName START WITH 1"
            params = emptyList()
        }

        return databaseService.executeUpdate(jdbcCoordinator, sql, params)
    }

    private fun getTenantSequenceDetails(jdbcCoordinator: JdbcCoordinator, tenantId: Long): TenantSequenceDetails {
        val sql = "SELECT min_id + 1 AS min_id, max_id FROM tenant_sequence_details(?)"
        val params = listOf(tenantId)
        return databaseService.executeQuery(jdbcCoordinator, sql, params).use { rs ->
            if (rs?.next() == true) {
                TenantSequenceDetails(rs.getLong("min_id"), rs.getLong("max_id"))
            } else {
                throw SQLException("Failed to fetch tenant sequence details for tenantId: $tenantId")
            }
        }
    }

    private fun executeNextVal(jdbcCoordinator: JdbcCoordinator, sequenceName: String): Long {
        val sql = "SELECT nextval(?)"
        val params = listOf(sequenceName)
        return databaseService.executeQuery(jdbcCoordinator, sql, params).use { rs ->
            if (rs?.next() == true) {
                rs.getLong(1)
            } else {
                throw SQLException("Failed to get next value from sequence: $sequenceName")
            }
        }
    }
}

data class TenantSequenceDetails(val minId: Long, val maxId: Long)

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/db/TenantEntityListener.kt =====
//package net.blugrid.api.db
//
//import io.micronaut.context.annotation.Requires
//import io.micronaut.data.annotation.event.PrePersist
//import jakarta.inject.Singleton
//import net.blugrid.api.example.repository.model.BookEntity
//import net.blugrid.api.security.service.SecurityContextService
//
//@Singleton
//@Requires(beans = [SecurityContextService::class])
//open class TenantEntityListener(
//    private val securityContextService: SecurityContextService
//) {
//
//
//    @PrePersist
//    fun prePersist(entity: BookEntity) {
//        val tenantId = securityContextService.currentTenantId
//        if (entity.id == null) {
//            entity.id = generateId(tenantId)
//        }
//    }
//
//    private fun generateId(tenantId: Long?): Long? {
//        // Implement your custom logic to generate the ID based on tenantId
//        return tenantId?.let {
//            // Example logic: generate a unique ID by combining tenantId with some other logic
//            tenantId + System.currentTimeMillis() // Replace with actual logic
//        }
//    }
//}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/db/BaseTenantResourceEntity.kt =====
//package net.blugrid.api.db
//
//import jakarta.persistence.Column
//import jakarta.persistence.EntityListeners
//import jakarta.persistence.Id
//import jakarta.persistence.MappedSuperclass
//import net.blugrid.api.common.repository.model.TenantResourceEntity
//
//@MappedSuperclass
//@EntityListeners(TenantEntityListener::class)
//abstract class BaseTenantResourceEntity<T> : TenantResourceEntity<T> {
//
//    @Id
//    @Column(name = "id")
//    override var id: Long? = null
//}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/db/GlobalTenantSequenceGenerator.kt =====
package net.blugrid.api.db

import net.blugrid.api.logging.logger
import net.blugrid.api.security.context.CurrentRequestContext
import org.hibernate.HibernateException
import org.hibernate.engine.spi.SharedSessionContractImplementor
import org.hibernate.id.IdentifierGenerator
import org.hibernate.id.enhanced.SequenceStyleGenerator
import org.hibernate.service.ServiceRegistry
import org.hibernate.type.Type
import java.io.Serializable
import java.sql.PreparedStatement
import java.sql.SQLException
import java.sql.Types
import java.util.Properties

class GlobalTenantSequenceGenerator : SequenceStyleGenerator(), IdentifierGenerator {

    private val log = logger()

    private lateinit var sequenceName: String

    override fun configure(type: Type, params: Properties, serviceRegistry: ServiceRegistry) {
        super<SequenceStyleGenerator>.configure(type, params, serviceRegistry)
        this.sequenceName = params.getProperty("target_table")
            .removePrefix("vw_")
            .removeSuffix("_##scope_option##")
    }

    override fun generate(session: SharedSessionContractImplementor, entity: Any?): Serializable {
        val tenantId = CurrentRequestContext.currentTenantId
        log.debug("Generating Id sequenceName: $sequenceName for tenantId: $tenantId")

        val jdbcCoordinator = session.jdbcCoordinator
        var nextValue: Long = 1

        val sql = if (tenantId != null) {
            "SELECT tenant_nextval(?,?)"
        } else {
            "SELECT unscoped_nextval(?)"
        }

        try {
            jdbcCoordinator.statementPreparer.prepareStatement(sql).use { preparedStatement ->
                prepareStatement(preparedStatement, tenantId)
                jdbcCoordinator.resultSetReturn.extract(preparedStatement, sql).use { resultSet ->
                    if (resultSet.next()) {
                        nextValue = resultSet.getLong(1)
                        log.trace("Sequence value obtained: $nextValue")
                    } else {
                        throw HibernateException("No value obtained for sequence.")
                    }
                }
            }
            jdbcCoordinator.afterStatementExecution()
        } catch (sqlException: SQLException) {
            throw session.jdbcServices.sqlExceptionHelper.convert(sqlException, "Could not get next sequence value")
        }

        return nextValue
    }

    private fun prepareStatement(preparedStatement: PreparedStatement, tenantId: Long?) {
        if (tenantId != null) {
            preparedStatement.setString(1, sequenceName)
            preparedStatement.setObject(2, tenantId, Types.BIGINT)
        } else {
            preparedStatement.setString(1, sequenceName)
        }
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/common/mapper/CommonMapper.kt =====
package net.blugrid.api.common.mapper

import jakarta.inject.Singleton
import net.blugrid.api.common.model.resource.Audit
import net.blugrid.api.common.model.resource.BusinessUnitPermission
import net.blugrid.api.common.model.resource.TenantPermission
import net.blugrid.api.common.repository.model.EmbeddedAuditEntity
import net.blugrid.api.common.repository.model.EmbeddedBusinessUnitPermissionEntity
import net.blugrid.api.common.repository.model.EmbeddedTenantPermissionEntity
import org.mapstruct.Mapper
import org.mapstruct.MapperConfig
import org.mapstruct.Mapping
import org.mapstruct.MappingConstants

interface HasId {
    var id: Long?
}

@MapperConfig
interface CommonMappings {

    @Mapping(target = "id", source = "id", resultType = Long::class)
    fun mapId(source: HasId): HasId
}

@Mapper(componentModel = MappingConstants.ComponentModel.JAKARTA)
abstract class CommonMapper {

    fun toAudit(source: EmbeddedAuditEntity): Audit = source.toAudit()
    fun toTenantPermission(source: EmbeddedTenantPermissionEntity): TenantPermission = source.toTenantPermission()
    fun toEmbeddedTenantPermissionEntity(): EmbeddedTenantPermissionEntity = newEmbeddedTenantPermission()
    fun toBusinessUnitPermission(source: EmbeddedBusinessUnitPermissionEntity): BusinessUnitPermission = source.toBusinessUnitPermission()
    fun toEmbeddedBusinessUnitPermissionEntity(): EmbeddedBusinessUnitPermissionEntity = newEmbeddedBusinessUnitPermission()
}

@Singleton
class EmbeddedAuditMapper {
    fun mapToEmbeddedAudit(): EmbeddedAuditEntity {
        return EmbeddedAuditEntity()
    }

    fun mapFromEmbeddedAudit(source: EmbeddedAuditEntity): Audit {
        return Audit(
            createdTimestamp = source.createdTimestamp,
            createdBySessionId = source.createdBySessionId,
            lastChangedTimestamp = source.lastChangedTimestamp,
            lastChangedBySessionId = source.lastChangedBySessionId,
        )
    }
}

@Singleton
class EmbeddedPermissionMapper {

    fun toEmbeddedTenantPermissionEntity(): EmbeddedTenantPermissionEntity {
        return EmbeddedTenantPermissionEntity()
    }

    fun toTenantPermission(source: EmbeddedTenantPermissionEntity): TenantPermission {
        return TenantPermission(tenantId = source.tenantId)
    }

    fun toEmbeddedBusinessUnitPermissionEntity(): EmbeddedBusinessUnitPermissionEntity {
        return EmbeddedBusinessUnitPermissionEntity()
    }

    fun toBusinessUnitPermission(source: EmbeddedBusinessUnitPermissionEntity): BusinessUnitPermission {
        return BusinessUnitPermission(
            tenantId = source.tenantId,
            businessUnitId = source.businessUnitId,
        )
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/common/mapper/CommonMappingExtensions.kt =====
package net.blugrid.api.common.mapper

import net.blugrid.api.common.model.resource.Audit
import net.blugrid.api.common.model.resource.BusinessUnitPermission
import net.blugrid.api.common.model.resource.TenantPermission
import net.blugrid.api.common.repository.model.EmbeddedAuditEntity
import net.blugrid.api.common.repository.model.EmbeddedBusinessUnitPermissionEntity
import net.blugrid.api.common.repository.model.EmbeddedTenantPermissionEntity

fun EmbeddedAuditEntity.toAudit(): Audit =
    Audit(
        createdTimestamp = createdTimestamp,
        createdBySessionId = createdBySessionId,
        lastChangedTimestamp = lastChangedTimestamp,
        lastChangedBySessionId = lastChangedBySessionId
    )

fun EmbeddedBusinessUnitPermissionEntity.toBusinessUnitPermission(): BusinessUnitPermission =
    BusinessUnitPermission(
        tenantId = tenantId,
        businessUnitId = businessUnitId
    )

fun EmbeddedTenantPermissionEntity.toTenantPermission() =
    TenantPermission(
        tenantId = this.tenantId,
    )

fun EmbeddedAuditEntity.toCommonAudit() =
    Audit(
        createdTimestamp = this.createdTimestamp,
        createdBySessionId = this.createdBySessionId,
        lastChangedTimestamp = this.lastChangedTimestamp,
        lastChangedBySessionId = this.lastChangedBySessionId,
    )

fun TenantPermission.toTenantPermissionEntity() =
    EmbeddedTenantPermissionEntity(
        tenantId = this.tenantId,
    )

fun Audit.toCommonAuditEntity() =
    EmbeddedAuditEntity(
        createdTimestamp = this.createdTimestamp,
        createdBySessionId = this.createdBySessionId,
        lastChangedTimestamp = this.lastChangedTimestamp,
        lastChangedBySessionId = this.lastChangedBySessionId,
    )


fun newEmbeddedTenantPermission(): EmbeddedTenantPermissionEntity =
    EmbeddedTenantPermissionEntity()

fun newEmbeddedBusinessUnitPermission(): EmbeddedBusinessUnitPermissionEntity =
    EmbeddedBusinessUnitPermissionEntity()

fun newEmbeddedAudit(): EmbeddedAuditEntity =
    EmbeddedAuditEntity()

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/common/repository/model/AuditEmbeddable.kt =====
package net.blugrid.api.common.repository.model

import io.micronaut.data.annotation.Embeddable
import io.micronaut.data.annotation.Version
import io.micronaut.data.annotation.event.PrePersist
import io.micronaut.data.annotation.event.PreUpdate
import jakarta.persistence.Column
import jakarta.persistence.Embedded
import jakarta.persistence.MappedSuperclass
import net.blugrid.api.security.context.CurrentRequestContext
import org.hibernate.annotations.CreationTimestamp
import org.hibernate.annotations.UpdateTimestamp
import java.time.LocalDateTime

@Embeddable
class AuditEmbeddable : AuditableEntityFields {

    @CreationTimestamp
    @Column(name = "created_timestamp", updatable = false)
    override var createdTimestamp: LocalDateTime? = null

    @UpdateTimestamp
    @Column(name = "last_changed_timestamp")
    override var lastChangedTimestamp: LocalDateTime? = null

    @Column(name = "created_by_session_id", updatable = false)
    override var createdBySessionId: Long? = null

    @Column(name = "last_changed_by_session_id")
    override var lastChangedBySessionId: Long? = null

    @Version
    @Column(name = "version")
    override var version: Int = 0

    fun prePersist(sessionId: Long) {
        createdBySessionId = sessionId
        lastChangedBySessionId = sessionId
    }

    fun preUpdate(sessionId: Long) {
        lastChangedBySessionId = sessionId
    }
}

interface AuditableEntityFields {
    var createdTimestamp: LocalDateTime?
    var lastChangedTimestamp: LocalDateTime?
    var createdBySessionId: Long?
    var lastChangedBySessionId: Long?
    var version: Int
}

@MappedSuperclass
abstract class AuditableEntity {

    @Embedded
    abstract var audit: AuditEmbeddable

    @PrePersist
    fun auditCreate() {
        val sessionId = getCurrentSessionId()
        audit.prePersist(sessionId)
    }

    @PreUpdate
    fun auditUpdate() {
        val sessionId = getCurrentSessionId()
        audit.preUpdate(sessionId)
    }

    private fun getCurrentSessionId(): Long =
       CurrentRequestContext.currentSession?.sessionId?.toLong() ?: 0L
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/common/repository/model/AuditableEntity.kt =====
package net.blugrid.api.common.repository.model

import io.micronaut.data.annotation.event.PrePersist
import io.micronaut.data.annotation.event.PreUpdate
import jakarta.persistence.MappedSuperclass
import net.blugrid.api.security.context.CurrentRequestContext

@MappedSuperclass
abstract class AuditableEntity {

    @PrePersist
    fun setAuditCreateFields() {
        audit.createdBySessionId = getCurrentSessionId()
        audit.lastChangedBySessionId = getCurrentSessionId()
    }

    @PreUpdate
    fun setAuditUpdateFields() {
        audit.lastChangedBySessionId = getCurrentSessionId()
    }

    abstract var audit: AuditEmbeddable

    private fun getCurrentSessionId(): Long =
        CurrentRequestContext.currentSession?.sessionId?.toLong() ?: 0L
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/common/repository/model/EmbeddedAuditEntity.kt =====
package net.blugrid.api.common.repository.model

import jakarta.persistence.Column
import jakarta.persistence.Embeddable
import net.blugrid.api.security.context.CurrentRequestContext
import org.hibernate.annotations.CreationTimestamp
import org.hibernate.annotations.UpdateTimestamp
import java.time.LocalDateTime

@Embeddable
class EmbeddedAuditEntity(

    @CreationTimestamp
    override val createdTimestamp: LocalDateTime? = null,

    @UpdateTimestamp
    override val lastChangedTimestamp: LocalDateTime? = null,

    @Column(name = "created_by_session_id", updatable = false)
    override var createdBySessionId: Long? = null,

    @Column(name = "last_changed_by_session_id")
    override var lastChangedBySessionId: Long? = null,
//
//    @GeneratedColumn("version")
//    override val version: Int = 0

) : EmbeddedAuditInterface {

    fun prePersist() {
        createdBySessionId = CurrentRequestContext.currentSession?.sessionId?.toLong() ?: 0L
        lastChangedBySessionId = CurrentRequestContext.currentSession?.sessionId?.toLong() ?: 0L
    }

    fun preUpdate() {
        lastChangedBySessionId = CurrentRequestContext.currentSession?.sessionId?.toLong() ?: 0L
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/common/repository/model/EmbeddedPermissionEntity.kt =====
package net.blugrid.api.common.repository.model

import jakarta.persistence.Column
import jakarta.persistence.Embeddable
import net.blugrid.api.security.authentication.model.AuthenticatedOrganisation
import net.blugrid.api.security.context.CurrentRequestContext

@Embeddable
class EmbeddedTenantPermissionEntity(
    @Column(name = "tenant_id", updatable = false)
    override var tenantId: Long? = null

) : ITenantPermissionEntity {

    fun prePersist() {
        tenantId = CurrentRequestContext.currentTenantId
    }
}

@Embeddable
class EmbeddedBusinessUnitPermissionEntity(
    @Column(name = "business_unit_id", updatable = false)
    override var businessUnitId: Long? = CurrentRequestContext.currentBusinessUnitId,

    @Column(name = "tenant_id", updatable = false)
    override var tenantId: Long? = CurrentRequestContext.currentTenantId
) : IBusinessUnitPermissionEntity {

    fun prePersist() {
        businessUnitId = CurrentRequestContext.currentBusinessUnitId
        tenantId = CurrentRequestContext.currentTenantId
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/config/EnvProps.kt =====
package net.blugrid.api.config

import io.micronaut.context.annotation.ConfigurationProperties
import io.micronaut.core.bind.annotation.Bindable

@ConfigurationProperties("env")
interface EnvProps {

    @get:Bindable(defaultValue = "")
    val name: String
}

@ConfigurationProperties("env.server")
interface ServerProps {

    @get:Bindable(defaultValue = "")
    val baseUri: String
}

@ConfigurationProperties("env.web")
interface WebProps {

    @get:Bindable(defaultValue = "")
    val baseUri: String
}


@ConfigurationProperties("env.db")
interface DbProps {

    @get:Bindable(defaultValue = "")
    val dbname: String

    @get:Bindable(defaultValue = "")
    val schema: String
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/config/GlobalExceptionHandler.kt =====
package net.blugrid.api.config

import io.micronaut.context.annotation.Requires
import io.micronaut.http.HttpRequest
import io.micronaut.http.HttpResponse
import io.micronaut.http.HttpStatus
import io.micronaut.http.annotation.Produces
import io.micronaut.http.server.exceptions.ExceptionHandler
import jakarta.inject.Singleton
import net.blugrid.api.common.exception.APIException
import net.blugrid.api.logging.logger

@Produces
@Singleton
@Requires(classes = [APIException::class, ExceptionHandler::class])
class GlobalExceptionHandler : ExceptionHandler<Throwable, HttpResponse<Map<String, Any>>> {

    private val log = logger()

    override fun handle(request: HttpRequest<*>, exception: Throwable): HttpResponse<Map<String, Any>> {
        log.error("Exception occurred: ${exception.localizedMessage}")

        if (exception is APIException) {
            log.error("Error Code: ${exception.apiError.code}")

            // Log stack trace if required
            if (exception.includeStackTrace) {
                exception.stackTrace.forEach {
                    log.error(it.toString())
                }
            }

            return HttpResponse.status<Map<String, Any>>(exception.status)
                .body(exception.toResponseBody())
        } else {
            // Handle other types of exceptions (e.g., unexpected errors)
            log.error("Unexpected error: ${exception.message}")
            exception.stackTrace.forEach {
                log.error(it.toString())
            }

            // Return a generic internal server error response
            return HttpResponse.status<Map<String, Any>>(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(mapOf(
                    "status" to HttpStatus.INTERNAL_SERVER_ERROR.code,
                    "message" to "An unexpected error occurred",
                    "code" to "INTERNAL_SERVER_ERROR"
                ))
        }
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/config/PostgreSQL10JsonDialect.kt =====
package net.blugrid.api.config

import org.hibernate.dialect.PostgreSQLDialect
import java.sql.Types

/*
New Hibernate Type to handle the JDBC Types.OTHER either globally or on a per-query basis.
This is required to work around hibernates incompatibility with json types and union queries.

When unions for inherited type the 1111 JDBC type corresponds to Types.OTHER which is what the PostgreSQL JDBC Driver uses for jsonb column types.
Hibernate will throw the following MappingException in this case.
*/
//class PostgreSQL10JsonDialect : PostgreSQL10Dialect() {
//    init {
//        registerColumnType(Types.OTHER, "jsonb")
//        registerHibernateType(Types.OTHER, "jsonb")
//    }
//}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/config/ApplicationConfiguration.kt =====
package net.blugrid.api.config

import io.micronaut.context.annotation.ConfigurationProperties

interface ApplicationConfiguration {
    val max: Int
}

@ConfigurationProperties("application")
class ApplicationConfigurationProperties : ApplicationConfiguration {
    private val DEFAULT_MAX = 10
    override var max = DEFAULT_MAX
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/example/model/Book.kt =====
package net.blugrid.api.example.model

import com.fasterxml.jackson.annotation.JsonIgnore
import io.swagger.v3.oas.annotations.media.Schema
import net.blugrid.api.common.model.resource.Audit
import net.blugrid.api.common.model.resource.TenantResource
import net.blugrid.api.common.model.resource.TenantPermission
import net.blugrid.api.common.model.resource.GenericCreateResource
import net.blugrid.api.common.model.resource.GenericUpdateResource
import net.blugrid.api.common.model.resource.ResourceType
import java.util.UUID

@Schema(description = "Base book interface")
interface IBook {
    var name: String?
}

data class BookCreate(
    override var uuid: UUID,
    override var name: String? = null
) : GenericCreateResource<BookCreate>(uuid), IBook

data class BookUpdate(
    override var id: Long,
    override var uuid: UUID,
    override var name: String? = null
) : GenericUpdateResource<BookUpdate>(id, uuid), IBook

data class Book(
    override var id: Long,
    override var uuid: UUID,
    override var name: String? = null,
    override val permission: TenantPermission? = null,
    override val audit: Audit? = null

) : TenantResource<Book>(permission, audit), IBook {

    @get:JsonIgnore
    override val resourceType: ResourceType
        get() = ResourceType.BOOK
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/example/mapping/BookMapper.kt =====
package net.blugrid.api.example.mapping

import net.blugrid.api.common.mapper.CommonMapper
import net.blugrid.api.common.repository.model.GenericEntityMapper
import net.blugrid.api.example.model.Book
import net.blugrid.api.example.model.BookCreate
import net.blugrid.api.example.model.BookUpdate
import net.blugrid.api.example.repository.model.BookEntity
import org.mapstruct.Mapper
import org.mapstruct.MappingConstants.ComponentModel.JAKARTA


@Mapper(componentModel = JAKARTA, uses = [CommonMapper::class])
abstract class BookMapper : GenericEntityMapper<Book, BookCreate, BookUpdate, BookEntity>() {

    abstract override fun createToEntity(source: BookCreate): BookEntity

    abstract override fun updateToEntity(source: BookUpdate): BookEntity

    abstract override fun entityToResource(source: BookEntity): Book

    abstract override fun resourceToUpdate(source: Book): BookUpdate
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/example/service/BookStateService.kt =====
package net.blugrid.api.example.service

import jakarta.inject.Singleton
import net.blugrid.api.common.service.GenericCrudServiceImpl
import net.blugrid.api.common.service.GenericCrudService
import net.blugrid.api.example.mapping.BookMapper
import net.blugrid.api.example.model.Book
import net.blugrid.api.example.model.BookCreate
import net.blugrid.api.example.model.BookUpdate
import net.blugrid.api.example.repository.BookRepository
import net.blugrid.api.example.repository.model.BookEntity
import jakarta.transaction.Transactional
import jakarta.transaction.Transactional.TxType.REQUIRES_NEW

interface BookStateService : GenericCrudService<Book, BookCreate, BookUpdate, BookEntity, BookMapper>

@Singleton
open class BookStateServiceImpl(
    private val repository: BookRepository,
    private val mapper: BookMapper
) : GenericCrudServiceImpl<Book, BookCreate, BookUpdate, BookEntity, BookMapper>(repository, mapper),
    BookStateService {

    @Transactional(value = REQUIRES_NEW)
    override fun create(newResource: BookCreate): Book {
        return repository.saveAndFlush(newResource.toEntity())
            .toResponse()
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/example/controller/BookController.kt =====
package net.blugrid.api.example.controller

import io.micronaut.data.model.Page
import io.micronaut.data.model.Pageable
import io.micronaut.http.annotation.Controller
import io.micronaut.scheduling.TaskExecutors
import io.micronaut.scheduling.annotation.ExecuteOn
import io.micronaut.security.annotation.Secured
import io.micronaut.security.rules.SecurityRule.IS_AUTHENTICATED
import net.blugrid.api.common.controller.GenericCrudResource
import net.blugrid.api.example.model.Book
import net.blugrid.api.example.model.BookCreate
import net.blugrid.api.example.model.BookUpdate
import net.blugrid.api.example.service.BookStateService

interface BookResource : GenericCrudResource<Book, BookCreate, BookUpdate>

@ExecuteOn(TaskExecutors.BLOCKING)
@Controller(BookController.PATH)
@Secured(IS_AUTHENTICATED)
open class BookController(
    private val stateService: BookStateService
) : BookResource {
    companion object {
        const val PATH = "/books"
    }

    override fun create(created: BookCreate): Book {
        return stateService.create(created)
    }

    override fun update(id: Long, updated: BookUpdate): Book {
        return stateService.update(id, updated)
    }

    override fun getById(id: Long): Book {
        return stateService.getById(id)
    }

    override fun getPage(pageable: Pageable): Page<Book> {
        return stateService.getPage(pageable)
    }

    override fun getAll(): List<Book> {
        return stateService.getAll()
    }

    override fun delete(id: Long) {
        return stateService.delete(id)
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/example/repository/model/BookEntity.kt =====
package net.blugrid.api.example.repository.model

import com.thinkinglogic.builder.annotation.Builder
import jakarta.persistence.Column
import jakarta.persistence.Embedded
import jakarta.persistence.Entity
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType.SEQUENCE
import jakarta.persistence.Id
import jakarta.persistence.PrePersist
import jakarta.persistence.PreUpdate
import jakarta.persistence.Table
import net.blugrid.api.common.repository.model.EmbeddedAuditEntity
import net.blugrid.api.common.repository.model.EmbeddedTenantPermissionEntity
import net.blugrid.api.common.repository.model.TenantResourceEntity
import net.blugrid.api.util.kotlinEquals
import org.hibernate.annotations.GenericGenerator
import java.util.Objects
import java.util.UUID

@Entity
@Table(name = "vw_book")
@Builder
class BookEntity(

    @Id
    @GeneratedValue(strategy = SEQUENCE, generator = "tenant-sequence-generator")
    @GenericGenerator(name = "tenant-sequence-generator", strategy = "net.blugrid.api.db.GlobalTenantSequenceGenerator")
    @Column(name = "id", updatable = false)
    override var id: Long? = null,

    @Column(name = "uuid", updatable = false)
    override var uuid: UUID,

    var name: String? = null

) : TenantResourceEntity<BookEntity> {

    @Embedded
    override var audit: EmbeddedAuditEntity = EmbeddedAuditEntity()

    @Embedded
    override var permission: EmbeddedTenantPermissionEntity = EmbeddedTenantPermissionEntity()

    @PrePersist
    fun prePersist() {
        permission.prePersist()
        audit.prePersist()
    }

    @PreUpdate
    fun preUpdate() {
        audit.preUpdate()
    }


    override fun update(update: BookEntity): BookEntity {
        this.name = update.name
        return this
    }

    companion object {
        val equalsProperties = arrayOf(
            BookEntity::id,
            BookEntity::name,
        )
    }

    override fun equals(other: Any?) = kotlinEquals(other = other, properties = equalsProperties)

    override fun hashCode() = Objects.hash(
        id,
        name,
    )
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/example/repository/migration/Book.kt =====
package net.blugrid.api.example.repository.migration

import net.blugrid.api.db.mapping.toTenantScopedTableSQL
import net.blugrid.api.db.mapping.toTenantScopedViewSQL
import net.blugrid.api.db.migration.DbMigration
import net.blugrid.api.db.migration.RepeatableDbMigration
import net.blugrid.api.db.model.DatabaseColumn
import net.blugrid.api.db.model.DatabaseTable
import org.flywaydb.core.api.migration.Context

private val bookTableDefinition: DatabaseTable = DatabaseTable(
    name = "book",
    columns = listOf(
        DatabaseColumn(name = "name", dataType = "T_DESCRIPTION"),
    ),
)

class V2022_12_07_10_00_00__book : DbMigration() {
    override fun migrate(context: Context) {
        runMigration(context, bookTableDefinition.toTenantScopedTableSQL())
    }
}

class R__vw_book : RepeatableDbMigration() {
    override fun migrate(context: Context) {
        this.runMigration(context, bookTableDefinition.toTenantScopedViewSQL())
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/example/repository/BookRepository.kt =====
package net.blugrid.api.example.repository

import io.micronaut.context.annotation.Executable
import io.micronaut.data.annotation.Repository
import net.blugrid.api.common.repository.GenericCrudRepository
import net.blugrid.api.example.repository.model.BookEntity

@Repository
interface BookRepository : GenericCrudRepository<BookEntity> {
    @Executable
    override fun update(update: BookEntity): BookEntity
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/jwt/JwksLoader.kt =====
package net.blugrid.api.security.jwt

import com.nimbusds.jose.jwk.JWKSet
import com.nimbusds.jose.jwk.RSAKey
import java.security.KeyFactory
import java.security.interfaces.RSAPublicKey
import java.security.spec.RSAPublicKeySpec

class JwksLoader(jwksFilePath: String) {
    val publicKey: RSAPublicKey

    init {
        val jwksStream = javaClass.classLoader.getResourceAsStream(jwksFilePath)
            ?: throw IllegalArgumentException("Cannot load file: $jwksFilePath")
        val jwks = jwksStream.bufferedReader().use { it.readText() }
        val jwkSet = JWKSet.parse(jwks)
        val jwk = jwkSet.keys.first() as RSAKey
        val modulus = jwk.modulus.decodeToBigInteger()
        val exponent = jwk.publicExponent.decodeToBigInteger()
        val keySpec = RSAPublicKeySpec(modulus, exponent)
        val keyFactory = KeyFactory.getInstance("RSA")
        publicKey = keyFactory.generatePublic(keySpec) as RSAPublicKey
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/jwt/JwtDecoder.kt =====
@file:Suppress("DEPRECATION")

package net.blugrid.api.security.jwt

import com.nimbusds.jose.JOSEObjectType
import com.nimbusds.jose.JWSAlgorithm
import com.nimbusds.jose.jwk.source.RemoteJWKSet
import com.nimbusds.jose.proc.DefaultJOSEObjectTypeVerifier
import com.nimbusds.jose.proc.JWSVerificationKeySelector
import com.nimbusds.jose.proc.SecurityContext
import com.nimbusds.jwt.JWT
import com.nimbusds.jwt.JWTClaimsSet
import com.nimbusds.jwt.JWTParser
import com.nimbusds.jwt.SignedJWT
import com.nimbusds.jwt.proc.DefaultJWTClaimsVerifier
import com.nimbusds.jwt.proc.DefaultJWTProcessor
import com.nimbusds.jwt.proc.JWTProcessor
import io.micronaut.context.annotation.Requires
import io.micronaut.context.env.Environment
import io.micronaut.security.authentication.AuthorizationException
import io.micronaut.security.oauth2.configuration.OauthClientConfigurationProperties
import jakarta.inject.Singleton
import net.blugrid.api.logging.logger
import net.blugrid.api.security.jwt.model.JwtDecoder
import java.net.URL
import java.nio.charset.StandardCharsets
import java.text.ParseException
import java.util.Base64

// Not used. The Micronuat JwtValidator does this via configuration
@Singleton
@Requires(notEnv = [Environment.TEST])
class JwtDecoderImpl(
    private val oauthClientProps: OauthClientConfigurationProperties
) : JwtDecoder {

    private val log = logger()

    companion object {
        private var exactClaims: JWTClaimsSet? = null
        private var requiredClaims: Set<String>? = null
        private lateinit var processor: JWTProcessor<SecurityContext>
        private lateinit var jwksUri: String

        fun initialize(oauthClientProps: OauthClientConfigurationProperties) {
            jwksUri = oauthClientProps.openid.flatMap { it.jwksUri }.orElseThrow {
                IllegalStateException("jwksUri is not available")
            }
            processor = DefaultJWTProcessor<SecurityContext>().apply {
                jwsTypeVerifier = DefaultJOSEObjectTypeVerifier(JOSEObjectType("jwt"))
                jwsKeySelector = JWSVerificationKeySelector(
                    JWSAlgorithm.RS256,
                    RemoteJWKSet(URL(jwksUri))
                )
                jwtClaimsSetVerifier = DefaultJWTClaimsVerifier(exactClaims, requiredClaims)
            }
        }
    }

    init {
        initialize(oauthClientProps)
    }

    override fun decode(token: String): JWT {
        return try {
            processor.process(token, null)
                .let { JWTParser.parse(token) }
        } catch (e: ParseException) {
            log.error("Parsing error: $e")
            throw AuthorizationException(null)
        }
    }
}

@Singleton
@Requires(env = [Environment.TEST])
class FakeJwtDecoder : JwtDecoder {

    override fun decode(token: String): JWT {
        // Decode the token from Base64
        val decodedToken = String(Base64.getDecoder().decode(token), StandardCharsets.UTF_8)
        val signedJWT = SignedJWT.parse(decodedToken)

        return signedJWT
    }
}


===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/jwt/SelfSignedJwtDecoder.kt =====
package net.blugrid.api.security.jwt

import com.nimbusds.jose.JWSVerifier
import com.nimbusds.jose.crypto.RSASSAVerifier
import com.nimbusds.jwt.JWT
import com.nimbusds.jwt.JWTParser
import com.nimbusds.jwt.SignedJWT
import io.micronaut.context.annotation.Requires
import io.micronaut.context.annotation.Value
import jakarta.inject.Singleton
import net.blugrid.api.logging.logger
import net.blugrid.api.security.jwt.model.SelfSignedJwtDecoder
import java.security.interfaces.RSAPublicKey
import java.util.Optional

@Singleton
@Requires(property = "micronaut.security.token.jwt.signatures.jwks-static.selfSigned.path")
class SelfSignedJwtDecoderImpl(
    @Value("\${micronaut.security.token.jwt.signatures.jwks-static.selfSigned.path}") jwksFilePath: String
) : SelfSignedJwtDecoder {
    private val log = logger()
    private val publicKey: RSAPublicKey

    init {
        val jwksLoader = JwksLoader(jwksFilePath)
        publicKey = jwksLoader.publicKey
    }

    override fun decode(token: String): Optional<JWT> {
        val jwt: SignedJWT = JWTParser.parse(token) as SignedJWT
        val verifier: JWSVerifier = RSASSAVerifier(publicKey)

        return if (jwt.verify(verifier)) {
            Optional.of(jwt)
        } else {
            log.error("JWT verification failed")
            Optional.empty()
        }
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/jwt/SelfSignedJwtEncoder.kt =====
package net.blugrid.api.security.jwt

import jakarta.inject.Singleton
import net.blugrid.api.security.jwt.factory.AccessTokenFactory
import net.blugrid.api.security.jwt.model.JwtToken

@Singleton
class SelfSignedJwtEncoder {
    fun encode(token: JwtToken): String {
        return AccessTokenFactory.token(token)
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/jwt/JwtAuthenticationFetcher.kt =====
package net.blugrid.api.security.jwt

import com.fasterxml.jackson.databind.ObjectMapper
import io.micronaut.context.annotation.Replaces
import io.micronaut.context.event.ApplicationEventPublisher
import io.micronaut.http.HttpRequest
import io.micronaut.http.server.util.HttpHostResolver
import io.micronaut.http.server.util.locale.HttpLocaleResolver
import io.micronaut.security.authentication.Authentication
import io.micronaut.security.event.TokenValidatedEvent
import io.micronaut.security.filters.AuthenticationFetcher
import io.micronaut.security.filters.SecurityFilter
import io.micronaut.security.token.TokenAuthenticationFetcher
import jakarta.inject.Singleton
import net.blugrid.api.logging.logger
import net.blugrid.api.security.authentication.mapping.toMultitenantAuthentication
import net.blugrid.api.security.config.SecurityProps
import net.blugrid.api.security.jwt.mapping.jwtObjectMapper
import net.blugrid.api.security.jwt.model.SelfSignedJwtDecoder
import org.reactivestreams.Publisher
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono

@Replaces(TokenAuthenticationFetcher::class)
@Singleton
class JwtAuthenticationFetcher(
    private val cookieProps: SecurityProps.CookieConfig,
    private val selfSignedJwtDecoder: SelfSignedJwtDecoder,
    private val tokenValidatedEventPublisher: ApplicationEventPublisher<TokenValidatedEvent>,
    private val httpHostResolver: HttpHostResolver,
    private val httpLocaleResolver: HttpLocaleResolver,
) : AuthenticationFetcher<HttpRequest<*>> {

    private val log = logger()

    companion object {
        const val ORDER = 0
        private var objectMapper: ObjectMapper = jwtObjectMapper
    }

    init {
        objectMapper = jwtObjectMapper
    }

    override fun fetchAuthentication(request: HttpRequest<*>): Publisher<Authentication> {
        val jwtCookie = request.cookies.get(cookieProps.jwt)
        return if (jwtCookie == null) {
            Flux.empty()
        } else {
            Flux.fromIterable(listOf(jwtCookie.value))
                .flatMap { tokenValue ->
                    val jwtOpt = selfSignedJwtDecoder.decode(tokenValue)
                    if (jwtOpt.isPresent) {
                        val jwt = jwtOpt.get()

                        jwt.toMultitenantAuthentication(log, objectMapper)
                            ?.let { authentication ->
                                request.setAttribute(SecurityFilter.TOKEN, tokenValue)
                                request.setAttribute("jwt", jwt)

                                tokenValidatedEventPublisher.publishEvent(
                                    TokenValidatedEvent(
                                        tokenValue,
                                        httpHostResolver.resolve(request),
                                        httpLocaleResolver.resolveOrDefault(request)
                                    )
                                )
                                Mono.just(authentication)
                            }
                            ?: Flux.empty()
                    } else {
                        Flux.empty()
                    }
                }
        }
    }

    override fun getOrder(): Int {
        return ORDER
    }
}



===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/pkce/PkceUtil.kt =====
package net.blugrid.api.security.pkce

import java.security.MessageDigest
import java.security.SecureRandom
import java.util.Base64

object PkceUtil {

    fun generateCodeVerifier(): String {
        val secureRandom = SecureRandom()
        val code = ByteArray(32)
        secureRandom.nextBytes(code)
        return Base64.getUrlEncoder().withoutPadding().encodeToString(code)
    }

    fun generateCodeChallenge(verifier: String): String {
        val bytes = verifier.toByteArray(Charsets.US_ASCII)
        val messageDigest = MessageDigest.getInstance("SHA-256")
        messageDigest.update(bytes, 0, bytes.size)
        val digest = messageDigest.digest()
        return Base64.getUrlEncoder().withoutPadding().encodeToString(digest)
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/config/MultiTenantResolver.kt =====
package net.blugrid.api.security.config

import jakarta.inject.Named
import jakarta.inject.Singleton
import org.hibernate.context.spi.CurrentTenantIdentifierResolver

@Singleton
@Named("currentTenantResolver")
class MultiTenantResolver : CurrentTenantIdentifierResolver<String> {

    companion object {
        private const val DEFAULT_REGION_ID = "region_1"
    }

    override fun resolveCurrentTenantIdentifier(): String {
        return DEFAULT_REGION_ID
    }

    override fun validateExistingCurrentSessions(): Boolean {
        return true
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/config/CustomJdbcStatementInspector.kt =====
package net.blugrid.api.security.config

import jakarta.inject.Singleton
import net.blugrid.api.security.context.IsUnscoped
import org.hibernate.resource.jdbc.spi.StatementInspector

@Singleton
open class CustomJdbcStatementInspector : StatementInspector {
    override fun inspect(sql: String): String {
        val modifier = if (isUnscoped) "_unscoped" else ""
        return sql.replace("_##scope_option##", modifier)
    }

    private val isUnscoped: Boolean
        get() = when {
            IsUnscoped.isSet() -> IsUnscoped.value
            else -> false
        }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/config/MultiTenantConnectionProvider.kt =====
package net.blugrid.api.security.config

import jakarta.inject.Singleton
import net.blugrid.api.logging.logger
import net.blugrid.api.security.authentication.model.AuthenticatedBusinessUnitSession
import net.blugrid.api.security.authentication.model.AuthenticatedWebApplicationSession
import net.blugrid.api.security.service.SecurityContextService
import org.hibernate.HibernateException
import org.hibernate.cfg.AvailableSettings
import org.hibernate.engine.config.spi.ConfigurationService
import org.hibernate.engine.jdbc.connections.spi.AbstractDataSourceBasedMultiTenantConnectionProviderImpl
import org.hibernate.service.spi.ServiceRegistryAwareService
import org.hibernate.service.spi.ServiceRegistryImplementor
import org.hibernate.service.spi.Stoppable
import java.sql.Connection
import java.sql.SQLException
import java.sql.Types
import java.util.concurrent.ConcurrentHashMap
import javax.sql.DataSource

@Suppress("UNCHECKED_CAST")
@Singleton
open class MultiTenantConnectionProvider(
    private val securityContextService: SecurityContextService
) : AbstractDataSourceBasedMultiTenantConnectionProviderImpl<String>(),
    ServiceRegistryAwareService,
    Stoppable {

    private val log = logger()

    private var dataSourceMap: Map<String, DataSource>? = null
    private var tenantIdentifierForAny: String? = null

    companion object {
        const val DEFAULT_TENANT_ID = "default"
        const val TENANT_IDENTIFIER_TO_USE_FOR_ANY_KEY = "hibernate.multi_tenant.datasource.identifier_for_any"
    }

    override fun selectAnyDataSource(): DataSource {
        return selectDataSource(tenantIdentifierForAny ?: DEFAULT_TENANT_ID)
    }

    override fun selectDataSource(tenantIdentifier: String): DataSource {
        return dataSourceMap()[tenantIdentifier]
            ?: throw HibernateException("Could not locate datasource for tenantIdentifier: $tenantIdentifier")
    }

    override fun getAnyConnection(): Connection {
        return getConnection("1")
    }

    override fun getConnection(regionId: String): Connection {
        val connection: Connection
        try {
            connection = selectAnyDataSource().connection
            val schema = connection.schema
            val unscoped = securityContextService.currentIsUnscoped
            val currentTenantId = securityContextService.currentTenantId
            val currentBusinessUnitId = securityContextService.currentBusinessUnitId
            val currentSession = securityContextService.currentSession

            when {
                unscoped -> {
                    log.debug("Configuring connection - unscoped override found - no scoping needed")
                    connection.configureUnscoped(schema)
                }

                currentSession is AuthenticatedWebApplicationSession && currentTenantId != null -> {
                    log.debug("Configuring connection - WebApplication session found in SecurityContext - scoping to TenantId: $currentTenantId")
                    connection.configureTenantSessionScope(schema, currentTenantId.toString(), currentSession.sessionId)
                }

                currentSession is AuthenticatedBusinessUnitSession && currentTenantId != null && currentBusinessUnitId != null -> {
                    log.debug("Configuring connection - Business unit session found in SecurityContext - scoping to TenantId: $currentTenantId, BusinessUnitId: $currentBusinessUnitId")
                    connection.configureBusinessUnitSessionScope(schema, currentTenantId.toString(), currentBusinessUnitId.toString(), currentSession.sessionId)
                }

                currentTenantId != null && currentBusinessUnitId != null -> {
                    log.debug("Configuring connection - Business unit session found in SecurityContext - scoping to TenantId: $currentTenantId, BusinessUnitId: $currentBusinessUnitId")
                    connection.configureBusinessUnitIdScope(schema, currentTenantId.toString(), currentBusinessUnitId.toString())
                }

                currentTenantId != null -> {
                    log.debug("Configuring connection - WebApplication session found in SecurityContext - scoping to TenantId: $currentTenantId")
                    connection.configureTenantIdScope(schema, currentTenantId.toString())
                }

                else -> {
                    log.debug("Configuring connection - no scoping needed")
                    connection.configureUnscoped(schema)
                }
            }
        } catch (e: SQLException) {
            throw SQLException("Could not alter JDBC connection: ", e)
        }
        return connection
    }

    override fun releaseAnyConnection(connection: Connection) {
        this.releaseConnection("1", connection)
    }

    override fun releaseConnection(regionId: String, connection: Connection) {
        log.debug("Releasing connection")
        connection.close()
    }

    override fun supportsAggressiveRelease(): Boolean {
        return true
    }

    private fun dataSourceMap(): MutableMap<String, DataSource?> {
        if (dataSourceMap == null) {
            dataSourceMap = ConcurrentHashMap()
        }
        return dataSourceMap as MutableMap<String, DataSource?>
    }

    override fun injectServices(serviceRegistry: ServiceRegistryImplementor) {
        @Suppress("DEPRECATION") val dataSourceConfigValue = serviceRegistry.getService(ConfigurationService::class.java)?.settings?.get(AvailableSettings.DATASOURCE)
        if (dataSourceConfigValue == null) {
            throw HibernateException("Improper set up of DataSourceBasedMultiTenantConnectionProviderImpl")
        }
        log.info("Default data source: $dataSourceConfigValue")
        dataSourceMap = mapOf(DEFAULT_TENANT_ID to dataSourceConfigValue as DataSource)
    }

    override fun stop() {
        if (dataSourceMap != null) {
            dataSourceMap = null
        }
    }
}

private fun Connection.configureUnscoped(schema: String) {
    prepareCall("SELECT pg_catalog.set_config('search_path', ?, false)")
        .use { statement ->
            statement.setString(1, schema)
            statement.execute()
        }
}

private fun Connection.configureTenantIdScope(schema: String, tenantId: String) {
    prepareCall("{? = CALL set_tenant_session(CAST(? AS TEXT), CAST(? AS TEXT)) }")
        .use { statement ->
            statement.registerOutParameter(1, Types.INTEGER)
            statement.setString(2, schema)
            statement.setString(3, tenantId)
            statement.execute()
        }
}

private fun Connection.configureTenantSessionScope(schema: String, tenantId: String, sessionId: String) {
    prepareCall("{? = CALL set_tenant_session(CAST(? AS TEXT), CAST(? AS TEXT), CAST(? AS TEXT)) }")
        .use { statement ->
            statement.registerOutParameter(1, Types.INTEGER)
            statement.setString(2, schema)
            statement.setString(3, tenantId)
            statement.setString(4, sessionId)
            statement.execute()
        }
}


private fun Connection.configureBusinessUnitIdScope(schema: String, tenantId: String, businessUnitId: String) {
    prepareCall("{? = CALL set_business_unit_session(CAST(? AS TEXT), CAST(? AS TEXT), CAST(? AS TEXT)) }")
        .use { statement ->
            statement.registerOutParameter(1, Types.INTEGER)
            statement.setString(2, schema)
            statement.setString(3, tenantId)
            statement.setString(4, businessUnitId)
            statement.execute()
        }
}

private fun Connection.configureBusinessUnitSessionScope(schema: String, tenantId: String, businessUnitId: String, sessionId: String) {
    prepareCall("{? = CALL set_business_unit_session(CAST(? AS TEXT), CAST(? AS TEXT), CAST(? AS TEXT), CAST(? AS TEXT)) }")
        .use { statement ->
            statement.registerOutParameter(1, Types.INTEGER)
            statement.setString(2, schema)
            statement.setString(3, tenantId)
            statement.setString(4, businessUnitId)
            statement.setString(5, sessionId)
            statement.execute()
        }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/config/JpaConfigurationCreatedEventListener.kt =====
package net.blugrid.api.security.config

import io.micronaut.configuration.hibernate.jpa.JpaConfiguration
import io.micronaut.context.event.BeanCreatedEvent
import io.micronaut.context.event.BeanCreatedEventListener
import jakarta.inject.Inject
import jakarta.inject.Singleton
//import org.hibernate.MultiTenancyStrategy.DATABASE
import org.hibernate.cfg.AvailableSettings

@Singleton
open class JpaConfigurationCreatedEventListener : BeanCreatedEventListener<JpaConfiguration> {

    @Inject
    var connectionProvider: MultiTenantConnectionProvider? = null

    @Inject
    var tenantResolver: MultiTenantResolver? = null

    override fun onCreated(event: BeanCreatedEvent<JpaConfiguration>): JpaConfiguration {
        val jpaConfiguration = event.bean
        jpaConfiguration.properties[AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER] = connectionProvider
        jpaConfiguration.properties[AvailableSettings.MULTI_TENANT_IDENTIFIER_RESOLVER] = tenantResolver
//        jpaConfiguration.properties[AvailableSettings.MULTI_TENANT] = DATABASE
        jpaConfiguration.properties[AvailableSettings.STATEMENT_INSPECTOR] = CustomJdbcStatementInspector::class.java
        return jpaConfiguration
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/service/LoginHandler.kt =====
package net.blugrid.api.security.service

import io.micronaut.context.annotation.Replaces
import io.micronaut.http.MutableHttpResponse
import io.micronaut.security.oauth2.endpoint.token.response.IdTokenLoginHandler
import jakarta.inject.Singleton
import net.blugrid.api.security.authentication.model.DecoratedAuthentication
import java.util.UUID

@Singleton
@Replaces(IdTokenLoginHandler::class)
class EnhancedIdTokenLoginHandler(
    private val cookieService: CookieService,
    private val redirectService: RedirectService,
) {

    fun tenantLoginSuccess(multitenantAuthentication: DecoratedAuthentication): MutableHttpResponse<*> {
        return cookieService.applyJwtCookie(
            response = redirectService.redirectToLoginSuccess(),
            authentication = multitenantAuthentication
        )
    }

    fun invitationLoginSuccess(multitenantAuthentication: DecoratedAuthentication, partyRegistrationInvitationUuid: UUID): MutableHttpResponse<*> {
        return cookieService.applyJwtCookie(
            response = redirectService.redirectToLoginRegistration(partyRegistrationInvitationUuid),
            authentication = multitenantAuthentication
        )
    }

    fun loginFailed(): MutableHttpResponse<*> {
        return cookieService.clearCookies(
            response = redirectService.redirectToLoginFailure()
        )
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/service/CookieService.kt =====
package net.blugrid.api.security.service

import io.micronaut.http.MutableHttpResponse
import jakarta.inject.Singleton
import net.blugrid.api.logging.logger
import net.blugrid.api.security.authentication.model.DecoratedAuthentication
import net.blugrid.api.security.config.SecurityProps
import net.blugrid.api.security.jwt.SelfSignedJwtEncoder
import net.blugrid.api.security.jwt.clearCookies
import net.blugrid.api.security.jwt.mapping.toJwtToken
import net.blugrid.api.security.jwt.setCookie
import java.time.Duration
import java.time.Instant

interface CookieService {
    fun applyJwtCookie(response: MutableHttpResponse<*>, authentication: DecoratedAuthentication): MutableHttpResponse<*>
    fun applyStateCookie(response: MutableHttpResponse<*>, state: String): MutableHttpResponse<*>
    fun clearCookies(response: MutableHttpResponse<*>): MutableHttpResponse<*>
    fun applyNonceCookie(response: MutableHttpResponse<*>, nonce: String): MutableHttpResponse<*>
}

@Singleton
class CookieServiceImpl(
    private val cookieSecurityProps: SecurityProps.CookieConfig,
    private val selfSignedJwtEncoder: SelfSignedJwtEncoder
) : CookieService {
    private val log = logger()

    override fun applyJwtCookie(response: MutableHttpResponse<*>, authentication: DecoratedAuthentication): MutableHttpResponse<*> {
        val ttl = authentication.toCookieExpiration().toMillis()
        val jwt = authentication.toJwtToken()
        val accessToken = selfSignedJwtEncoder.encode(jwt)
        return response.setCookie(cookieSecurityProps.jwt, accessToken, ttl)
    }

    override fun applyNonceCookie(response: MutableHttpResponse<*>, nonce: String): MutableHttpResponse<*> {
        return response.setCookie(cookieSecurityProps.oathNonce, nonce)
    }

    override fun applyStateCookie(response: MutableHttpResponse<*>, state: String): MutableHttpResponse<*> {
        return response.setCookie(cookieSecurityProps.oathState, state)
    }

    override fun clearCookies(response: MutableHttpResponse<*>): MutableHttpResponse<*> {
        return response.clearCookies(listOf(
            cookieSecurityProps.jwt,
            cookieSecurityProps.oauthPkce,
            cookieSecurityProps.oathState,
            cookieSecurityProps.oathNonce
        ))
    }

    private fun DecoratedAuthentication.toCookieExpiration(): Duration =
        expirationTime?.let {
            Duration.between(Instant.now(), it.toInstant())
        } ?: Duration.ofDays(1)
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/service/RedirectService.kt =====
package net.blugrid.api.security.service

import io.micronaut.context.annotation.Value
import io.micronaut.http.HttpRequest
import io.micronaut.http.HttpResponse
import io.micronaut.http.MutableHttpResponse
import io.micronaut.http.uri.UriBuilder
import jakarta.inject.Singleton
import net.blugrid.api.config.WebProps
import net.blugrid.api.logging.logger
import net.blugrid.api.security.config.RedirectProps
import net.blugrid.api.security.config.SecurityProps
import net.blugrid.api.security.pkce.PkceUtil
import java.net.URI
import java.util.UUID

@Singleton
class RedirectService(
    private val auth0Config: SecurityProps.Auth0Config,
    private val webProps: WebProps,
    private val redirectProps: RedirectProps,
    @Value("\${micronaut.security.endpoints.logout.path:/logout}")
    private val logoutPath: String,
) {

    private val log = logger()

    val getAuth0AuthorizeCallback: URI
        get() = URI(redirectProps.loginCallbackUrl)

    fun getAuth0LoginAndRegisterUri(state: String, nonce: String): URI {
        return UriBuilder.of(auth0Config.auth0Domain)
            .path("/authorize")
            .queryParam("audience", auth0Config.audience)
            .queryParam("scope", "openid profile email")
            .queryParam("response_type", "code")
            .queryParam("client_id", auth0Config.clientId)
            .queryParam("redirect_uri", redirectProps.registrationCallbackUrl)
            .queryParam("state", state)
            .queryParam("nonce", nonce)
            .build()
    }

    val auth0LoginUri: URI
        get() {
            val codeVerifier = PkceUtil.generateCodeVerifier()
            val codeChallenge = PkceUtil.generateCodeChallenge(codeVerifier)

            return UriBuilder.of(auth0Config.auth0Domain)
                .path("/authorize")
                .queryParam("audience", auth0Config.audience)
                .queryParam("scope", "openid profile email")
                .queryParam("response_type", "code")
                .queryParam("client_id", auth0Config.clientId)
                .queryParam("redirect_uri", redirectProps.loginCallbackUrl)
                .queryParam("code_challenge", codeChallenge)
                .queryParam("code_challenge_method", "S256")
                .build()
        }

    val auth0LogoutUri: URI
        get() = UriBuilder.of(auth0Config.auth0Domain)
            .path("/v2/logout")
            .queryParam("client_id", auth0Config.clientId)
            .queryParam("returnTo", redirectProps.logoutCallbackUrl)
            .build()

    fun redirectToAuth0Login(request: HttpRequest<*>): MutableHttpResponse<*> {
        log.debug("redirectToAuth0Login: ${request.cookies}")
        return HttpResponse.seeOther<Any>(auth0LoginUri)
    }

    fun redirectToLoginSuccess(): MutableHttpResponse<*> {
        return HttpResponse.seeOther<Any>(URI(redirectProps.loginSuccessUrl))
    }

    fun getRegistrationUrl(partyRegistrationInvitationUuid: UUID): String {
        val baseUri = redirectProps.registrationUrl.trimEnd('/')
        return "$baseUri?invitationUuid=$partyRegistrationInvitationUuid"
    }

    fun redirectToLoginRegistration(partyRegistrationInvitationUuid: UUID): MutableHttpResponse<*> {
        return HttpResponse.seeOther<Any>(UriBuilder.of(webProps.baseUri)
            .path("/#/signup")
            .queryParam("invitationUuid", partyRegistrationInvitationUuid)
            .build()
        )
    }

    fun redirectToLoginFailure(): MutableHttpResponse<*> {
        return HttpResponse.seeOther<Any>(URI(redirectProps.loginFailureUrl))
    }

    fun redirectToLogout(): MutableHttpResponse<*> {
        return HttpResponse.seeOther<Any>(URI(logoutPath))
    }

    fun redirectToAuth0Logout(request: HttpRequest<*>): MutableHttpResponse<*> {
        log.debug("getLogoutRedirect: ${request.cookies}")
        return HttpResponse.seeOther<Any>(auth0LogoutUri)
    }

    fun redirectToLogoutSuccess(): MutableHttpResponse<*> {
        return HttpResponse.seeOther<Any>(URI(redirectProps.logoutUrl))
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/service/SecurityContextService.kt =====
package net.blugrid.api.security.service

import jakarta.inject.Singleton
import net.blugrid.api.logging.logger
import net.blugrid.api.security.authentication.model.AuthenticatedOrganisation
import net.blugrid.api.security.authentication.model.AuthenticatedSession
import net.blugrid.api.security.authentication.model.AuthenticatedUser
import net.blugrid.api.security.context.BusinessUnitIdOverride
import net.blugrid.api.security.context.CurrentRequestContext
import net.blugrid.api.security.context.IsUnscoped
import net.blugrid.api.security.context.TenantIdOverride
import net.blugrid.api.security.repository.RequestScopeRepository
import java.util.concurrent.Callable

interface SecurityContextService {
    fun <T> runWithTenantId(tenantId: Long, original: Callable<T>): T
    fun <T> runWithBusinessUnitId(tenantId: Long, businessUnitId: Long, original: Callable<T>): T
    fun <T> runUnscoped(original: Callable<T>): T

    val currentTenant: AuthenticatedOrganisation?
    val currentUser: AuthenticatedUser?
    val currentSession: AuthenticatedSession?

    val currentBusinessUnitId: Long?
    val currentTenantId: Long?

    val currentIsUnscoped: Boolean
}

@Singleton
open class SecurityContextServiceImpl(
    private val requestScopeRepository: RequestScopeRepository,
) : SecurityContextService {

    val log = logger()

    override val currentSession: AuthenticatedSession?
        get() = CurrentRequestContext.currentSession

    override val currentTenant: AuthenticatedOrganisation?
        get() = CurrentRequestContext.currentOrganisation

    override val currentUser: AuthenticatedUser?
        get() = CurrentRequestContext.currentUser

    override val currentBusinessUnitId: Long?
        get() = CurrentRequestContext.currentBusinessUnitId

    override val currentTenantId: Long?
        get() = CurrentRequestContext.currentTenantId

    override val currentIsUnscoped: Boolean
        get() = CurrentRequestContext.currentIsUnscoped

    override fun <T> runWithTenantId(tenantId: Long, original: Callable<T>): T {
        log.debug("Running with tenantId: $tenantId")
        val previousTenantId = if (TenantIdOverride.hasOverride()) {
            TenantIdOverride.value
        } else {
            null
        }
        try {
            TenantIdOverride.use {
                TenantIdOverride.value = tenantId.toString()
                requestScopeRepository.setTenantId(tenantId.toString())
                return original.call()
            }
        } finally {
            if (previousTenantId != null) {
                TenantIdOverride.value = previousTenantId
                requestScopeRepository.setTenantId(previousTenantId)
            }
        }
    }

    override fun <T> runWithBusinessUnitId(tenantId: Long, businessUnitId: Long, original: Callable<T>): T {
        log.debug("Running with tenantId: $tenantId businessUnitId: $businessUnitId")
        val previousBusinessId = if (BusinessUnitIdOverride.hasOverride()) {
            BusinessUnitIdOverride.value
        } else {
            null
        }
        val previousTenantId = if (TenantIdOverride.hasOverride()) {
            TenantIdOverride.value
        } else {
            null
        }
        try {
            TenantIdOverride.use {
                TenantIdOverride.value = tenantId.toString()
                requestScopeRepository.setTenantId(tenantId.toString())
                BusinessUnitIdOverride.use {
                    BusinessUnitIdOverride.value = businessUnitId.toString()
                    requestScopeRepository.setBusinessUnitId(businessUnitId.toString())
                    return original.call()
                }
            }
        } finally {
            if (previousBusinessId != null) {
                BusinessUnitIdOverride.value = previousBusinessId
                requestScopeRepository.setBusinessUnitId(previousBusinessId)
            }
            if (previousTenantId != null) {
                TenantIdOverride.value = previousTenantId
                requestScopeRepository.setTenantId(previousTenantId)
            }
        }
    }

    override fun <T> runUnscoped(original: Callable<T>): T {
        log.debug("Running unscoped")
        val previousToken = if (IsUnscoped.isSet()) {
            IsUnscoped.value
        } else {
            null
        }
        try {
            IsUnscoped.use {
                IsUnscoped.value = true
                return original.call()
            }
        } finally {
            if (previousToken != null) {
                IsUnscoped.value = previousToken
            }
        }
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/service/CustomOauthRouteUrlBuilder.kt =====
package net.blugrid.api.security.service

import io.micronaut.context.annotation.Replaces
import io.micronaut.context.annotation.Value
import io.micronaut.http.HttpRequest
import io.micronaut.http.uri.UriBuilder
import io.micronaut.security.oauth2.configuration.OauthConfiguration
import io.micronaut.security.oauth2.url.OauthRouteUrlBuilder
import jakarta.inject.Singleton
import net.blugrid.api.config.ServerProps
import java.net.MalformedURLException
import java.net.URI
import java.net.URISyntaxException
import java.net.URL

@Singleton
@Replaces(bean = OauthRouteUrlBuilder::class)
class CustomOauthRouteUrlBuilder(
    private val serverProps: ServerProps,
    private val oauthConfiguration: OauthConfiguration,
    @Value("\${micronaut.server.context-path:/}") private val contextPath: String
) : OauthRouteUrlBuilder<HttpRequest<*>> {

    private val loginUriTemplate: String = oauthConfiguration.loginUri
    private val callbackUriTemplate: String = oauthConfiguration.callbackUri

    override fun buildLoginUrl(originating: HttpRequest<*>, providerName: String): URL {
        return buildUrl(originating, getPath(loginUriTemplate, providerName))
    }

    override fun buildCallbackUrl(originating: HttpRequest<*>, providerName: String): URL {
        return buildUrl(originating, getPath(callbackUriTemplate, providerName))
    }

    override fun buildLoginUri(providerName: String?): URI {
        return try {
            URI(getPath(loginUriTemplate, providerName ?: DEFAULT_PROVIDER_NAME))
        } catch (e: URISyntaxException) {
            throw IllegalArgumentException("Error building URI for path [$loginUriTemplate]", e)
        }
    }

    override fun buildCallbackUri(providerName: String?): URI {
        return try {
            URI(getPath(callbackUriTemplate, providerName ?: DEFAULT_PROVIDER_NAME))
        } catch (e: URISyntaxException) {
            throw IllegalArgumentException("Error building URI for path [$callbackUriTemplate]", e)
        }
    }

    private fun getPath(uriTemplate: String, providerName: String): String {
        val uriParams = mutableMapOf<String, Any>("provider" to providerName)
        return UriBuilder.of(contextPath)
            .path(uriTemplate)
            .expand(uriParams)
            .toString()
    }

    override fun buildUrl(originating: HttpRequest<*>, path: String): URL {
        return try {
            UriBuilder.of(serverProps.baseUri)
                .path(path)
                .build()
                .toURL()
        } catch (e: MalformedURLException) {
            throw IllegalArgumentException("Error building URL for path [$path]", e)
        }
    }

    companion object {
        private val DEFAULT_PROVIDER_NAME = "" // This will build a route like Registering default login route [GET: /oauth/login/]
    }
}


===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/controller/LogoutController.kt =====
package net.blugrid.api.security.controller

import io.micronaut.context.annotation.Replaces
import io.micronaut.context.event.ApplicationEventPublisher
import io.micronaut.http.HttpRequest
import io.micronaut.http.MediaType
import io.micronaut.http.MutableHttpResponse
import io.micronaut.http.annotation.Controller
import io.micronaut.http.annotation.Get
import io.micronaut.http.annotation.Produces
import io.micronaut.http.server.util.HttpHostResolver
import io.micronaut.http.server.util.locale.HttpLocaleResolver
import io.micronaut.scheduling.TaskExecutors
import io.micronaut.scheduling.annotation.ExecuteOn
import io.micronaut.security.annotation.Secured
import io.micronaut.security.authentication.Authentication
import io.micronaut.security.endpoints.LogoutController
import io.micronaut.security.event.LogoutEvent
import io.micronaut.security.rules.SecurityRule
import net.blugrid.api.security.service.CookieService
import net.blugrid.api.security.service.RedirectService

@Replaces(LogoutController::class)
@Controller("\${micronaut.security.endpoints.logout.path:/logout}")
@ExecuteOn(TaskExecutors.BLOCKING)
@Secured(SecurityRule.IS_ANONYMOUS)
class EnhancedLogoutController(
    private val cookieService: CookieService,
    private val httpHostResolver: HttpHostResolver,
    private val httpLocaleResolver: HttpLocaleResolver,
    private val logoutEventPublisher: ApplicationEventPublisher<LogoutEvent>,
    private val redirectService: RedirectService,
) {

    @Get
    @Produces(MediaType.APPLICATION_JSON)
    fun startLogout(request: HttpRequest<*>): MutableHttpResponse<*> {
        return redirectService.redirectToAuth0Logout(request)
    }

    @Get("/callback")
    fun handleCallback(request: HttpRequest<*>, authentication: Authentication?): MutableHttpResponse<*> {
        if (authentication != null) {
            logoutEventPublisher.publishEvent(LogoutEvent(authentication, httpHostResolver.resolve(request), httpLocaleResolver.resolveOrDefault(request)))
        }
        return cookieService.clearCookies(
            response = redirectService.redirectToLogoutSuccess()
        )
    }
}



===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/controller/RedirectController.kt =====
package net.blugrid.api.security.controller

import io.micronaut.http.HttpRequest
import io.micronaut.http.HttpResponse
import io.micronaut.http.annotation.Controller
import io.micronaut.http.annotation.Get
import io.micronaut.scheduling.TaskExecutors
import io.micronaut.scheduling.annotation.ExecuteOn
import io.micronaut.security.annotation.Secured
import io.micronaut.security.rules.SecurityRule
import net.blugrid.api.security.service.RedirectService

@Controller("/redirect")
@ExecuteOn(TaskExecutors.BLOCKING)
@Secured(SecurityRule.IS_ANONYMOUS)
class RedirectController(
    private val redirectService: RedirectService,
) {

    @Get("/login")
    fun login(request: HttpRequest<*>): HttpResponse<*> {
        return redirectService.redirectToAuth0Login(request)
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/controller/CheckSessionController.kt =====
package net.blugrid.api.security.controller

import io.micronaut.http.HttpRequest
import io.micronaut.http.HttpResponse
import io.micronaut.http.MediaType
import io.micronaut.http.annotation.Controller
import io.micronaut.http.annotation.Get
import io.micronaut.http.annotation.Produces
import io.micronaut.scheduling.TaskExecutors
import io.micronaut.scheduling.annotation.ExecuteOn
import io.micronaut.security.annotation.Secured
import io.micronaut.security.rules.SecurityRule
import net.blugrid.api.security.authentication.mapping.toMultitenantAuthentication
import net.blugrid.api.security.service.RedirectService

@Controller("/check-session")
@ExecuteOn(TaskExecutors.BLOCKING)
@Secured(SecurityRule.IS_ANONYMOUS)
class CheckSessionController(
    private val redirectService: RedirectService
) {

    @Get("/")
    @Produces(MediaType.APPLICATION_JSON)
    fun checkSession(request: HttpRequest<*>): HttpResponse<*> {
        val authenticationOpt = request.toMultitenantAuthentication()
        return if (authenticationOpt.isPresent) {
            return if (authenticationOpt.get().isExpired) {
                sendFailedResponse()
            } else {
                HttpResponse.ok<Any>()
            }
        } else {
            sendFailedResponse()
        }
    }

    private fun sendFailedResponse() = HttpResponse.unauthorized<Map<String, String>>()
        .body(mapOf("redirectUri" to redirectService.getAuth0AuthorizeCallback.toString()))
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/repository/model/RequestScopeEntity.kt =====
package net.blugrid.api.security.repository.model

import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.Id
import jakarta.persistence.Table

@Entity
@Table(name = "vw_request_scope")
class RequestScopeEntity(

    @Id
    @Column(name = "tenant_id")
    val tenantId: Long? = null,
)

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/repository/RequestScopeRepository.kt =====
package net.blugrid.api.security.repository

import io.micronaut.data.annotation.Query
import io.micronaut.data.annotation.Repository
import io.micronaut.data.jpa.repository.JpaRepository
import net.blugrid.api.security.repository.model.RequestScopeEntity

@Repository
interface RequestScopeRepository : JpaRepository<RequestScopeEntity?, Long?> {

    @Query(value = "SELECT set_tenant_scope(CAST(:tenantId AS TEXT))", nativeQuery = true)
    fun setTenantId(tenantId: String): Int

    @Query(value = "SELECT set_business_unit_scope(CAST(:businessUnitId AS TEXT))", nativeQuery = true)
    fun setBusinessUnitId(
        businessUnitId: String,
    ): Int

    @Query(value = "SELECT reset_request_scope()", nativeQuery = true)
    fun resetRequestScope(): Int
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/organisation/mapper/OrganisationMapper.kt =====
package net.blugrid.api.organisation.mapper

import net.blugrid.api.common.mapper.CommonMapper
import net.blugrid.api.common.model.organisation.Organisation
import net.blugrid.api.common.model.organisation.OrganisationCreate
import net.blugrid.api.common.model.organisation.OrganisationUpdate
import net.blugrid.api.common.repository.model.GenericEntityMapper
import net.blugrid.api.organisation.repository.model.OrganisationEntityOld
import org.mapstruct.Mapper
import org.mapstruct.MappingConstants.ComponentModel

@Mapper(componentModel = ComponentModel.JAKARTA, uses = [CommonMapper::class])
abstract class OrganisationMapper : GenericEntityMapper<Organisation, OrganisationCreate, OrganisationUpdate, OrganisationEntityOld>() {

    abstract override fun createToEntity(source: OrganisationCreate): OrganisationEntityOld
    abstract override fun updateToEntity(source: OrganisationUpdate): OrganisationEntityOld
    abstract override fun entityToResource(source: OrganisationEntityOld): Organisation
    abstract override fun resourceToUpdate(source: Organisation): OrganisationUpdate

    fun toOrganisationEntity(source: Organisation): OrganisationEntityOld {
        return OrganisationEntityOld(
            id = source.id,
            uuid = source.uuid,
            parentOrganisationId = source.parentOrganisationId,
            primaryPartyId = source.primaryPartyId,
            organisationMembershipId = source.organisationMembershipId,
            effectiveTimestamp = source.effectiveTimestamp
        )
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/organisation/service/OrganisationStateService.kt =====
package net.blugrid.api.organisation.service

import jakarta.inject.Singleton
import net.blugrid.api.organisation.mapper.OrganisationMapper
import net.blugrid.api.organisation.repository.OrganisationRepository
import net.blugrid.api.organisation.repository.model.OrganisationEntityOld
import net.blugrid.api.common.model.organisation.Organisation
import net.blugrid.api.common.model.organisation.OrganisationCreate
import net.blugrid.api.common.model.organisation.OrganisationUpdate
import net.blugrid.api.common.service.GenericCrudServiceImpl
import net.blugrid.api.common.service.GenericCrudService
import jakarta.transaction.Transactional
import jakarta.transaction.Transactional.TxType.REQUIRES_NEW

interface OrganisationStateService : GenericCrudService<Organisation, OrganisationCreate, OrganisationUpdate, OrganisationEntityOld, OrganisationMapper>

@Singleton
open class OrganisationStateServiceImpl(
    private val repository: OrganisationRepository,
    private val mapper: OrganisationMapper
) : GenericCrudServiceImpl<Organisation, OrganisationCreate, OrganisationUpdate, OrganisationEntityOld, OrganisationMapper>(repository, mapper),
    OrganisationStateService {

    @Transactional(value = REQUIRES_NEW)
    override fun create(newResource: OrganisationCreate): Organisation {
        return repository.saveAndFlush(newResource.toEntity())
            .toResponse()
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/organisation/service/DefaultOrganisationLoader.kt =====
package net.blugrid.api.organisation.service

import io.micronaut.context.annotation.Requires
import io.micronaut.context.env.Environment
import io.micronaut.discovery.event.ServiceReadyEvent
import io.micronaut.runtime.event.annotation.EventListener
import io.micronaut.scheduling.annotation.Async
import jakarta.inject.Singleton
import net.blugrid.api.common.model.organisation.OrganisationCreate
import net.blugrid.api.logging.logger
import net.blugrid.api.security.context.doInRequestContext
import net.blugrid.api.security.service.SecurityContextService
import java.time.LocalDateTime
import java.util.UUID

@Singleton
@Requires(notEnv = [Environment.TEST])
open class DefaultOrganisationLoader(
    private val applicationContextService: SecurityContextService,
    private val organisationService: OrganisationStateService
) {

    private val log = logger()

    companion object {
        const val TEST_TENANT_ID = 1L
    }

    @Async
    @EventListener
    open fun onServiceStarted(event: ServiceReadyEvent) {
        try {
            doInRequestContext {
                applicationContextService.runWithTenantId(TEST_TENANT_ID) {
                    val organisationOpt = organisationService.getByIdOptional(TEST_TENANT_ID)

                    if (!organisationOpt.isPresent) {
                        organisationService.create(
                            OrganisationCreate(
                                uuid = UUID.randomUUID(),
                                parentOrganisationId = -1,
                                effectiveTimestamp = LocalDateTime.now(),
                            )
                        )
                    }
                }
            }
        } catch (ex: Exception) {
            log.error("Failed to add default organisation in onServiceStarted: ${ex.message}", ex)
        }
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/organisation/controller/OrganisationController.kt =====
package net.blugrid.api.organisation.controller

import io.micronaut.data.model.Page
import io.micronaut.data.model.Pageable
import io.micronaut.http.annotation.Controller
import io.micronaut.scheduling.TaskExecutors
import io.micronaut.scheduling.annotation.ExecuteOn
import io.micronaut.security.annotation.Secured
import io.micronaut.security.rules.SecurityRule
import net.blugrid.api.organisation.service.OrganisationStateService
import net.blugrid.api.common.model.organisation.Organisation
import net.blugrid.api.common.model.organisation.OrganisationCreate
import net.blugrid.api.common.model.organisation.OrganisationUpdate
import net.blugrid.api.common.controller.GenericCrudResource

interface OrganisationResource : GenericCrudResource<Organisation, OrganisationCreate, OrganisationUpdate>

@ExecuteOn(TaskExecutors.BLOCKING)
@Controller(OrganisationController.PATH)
@Secured(SecurityRule.IS_AUTHENTICATED)
open class OrganisationController(
    private val stateService: OrganisationStateService
) : OrganisationResource {

    companion object {
        const val PATH = "/organisation"
    }

    override fun create(created: OrganisationCreate): Organisation {
        return stateService.create(created)
    }

    override fun update(id: Long, updated: OrganisationUpdate): Organisation {
        return stateService.update(id, updated)
    }

    override fun getById(id: Long): Organisation {
        return stateService.getById(id)
    }

    override fun getPage(pageable: Pageable): Page<Organisation> {
        return stateService.getPage(pageable)
    }

    override fun getAll(): List<Organisation> {
        return stateService.getAll()
    }

    override fun delete(id: Long) {
        return stateService.delete(id)
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/organisation/repository/model/OrganisationEntityOld.kt =====
package net.blugrid.api.organisation.repository.model

import jakarta.persistence.Column
import jakarta.persistence.Embedded
import jakarta.persistence.Entity
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType.SEQUENCE
import jakarta.persistence.Id
import jakarta.persistence.PrePersist
import jakarta.persistence.PreUpdate
import jakarta.persistence.Table
import net.blugrid.api.common.repository.model.EmbeddedAuditEntity
import net.blugrid.api.common.repository.model.UnscopedResourceEntity
import net.blugrid.api.util.kotlinEquals
import org.hibernate.annotations.Formula
import org.hibernate.annotations.Generated
import org.hibernate.annotations.GenericGenerator
import org.hibernate.generator.EventType
import java.time.LocalDateTime
import java.util.Objects
import java.util.UUID

@Entity
@Table(name = "vw_organisation_old")
class OrganisationEntityOld(

    @Id
    @GeneratedValue(strategy = SEQUENCE, generator = "organisation-old-sequence")
    @GenericGenerator(name = "organisation-old-sequence", strategy = "net.blugrid.api.db.GlobalTenantSequenceGenerator")
    @Column(name = "id", unique = true, nullable = false, updatable = false)
    override var id: Long? = null,

    @Column(name = "uuid", updatable = false)
    override var uuid: UUID,

    @Column(name = "parent_tenant_id")
    var parentOrganisationId: Long? = null,

    @Column(name = "primary_party_id")
    var primaryPartyId: Long? = null,

    @Column(name = "organisation_membership_id")
    var organisationMembershipId: Long? = null,

    @Column(name = "effective_timestamp")
    var effectiveTimestamp: LocalDateTime? = null,

) : UnscopedResourceEntity<OrganisationEntityOld> {

    @Embedded
    override var audit: EmbeddedAuditEntity = EmbeddedAuditEntity()

    @PrePersist
    fun prePersist() {
        audit.prePersist()
    }

    @PreUpdate
    fun preUpdate() {
        audit.preUpdate()
    }

    val tenantId: Long?
        get() = id

    @Generated(event = [EventType.INSERT, EventType.UPDATE])
    @Formula("(select party_id_by_role(organisation_membership_id))")
    val partyId: Long? = null

    @Generated(event = [EventType.INSERT, EventType.UPDATE])
    @Formula("(SELECT party_display_name_by_role(organisation_membership_id))")
    val displayName: String? = null

    companion object {
        private val equalsProperties = arrayOf(
            OrganisationEntityOld::uuid,
            OrganisationEntityOld::parentOrganisationId,
            OrganisationEntityOld::primaryPartyId,
            OrganisationEntityOld::organisationMembershipId,
            OrganisationEntityOld::effectiveTimestamp
        )
    }

    override fun update(update: OrganisationEntityOld): OrganisationEntityOld {
        this.parentOrganisationId = update.parentOrganisationId
        this.primaryPartyId = update.primaryPartyId
        this.organisationMembershipId = update.organisationMembershipId
        this.effectiveTimestamp = update.effectiveTimestamp
        return this
    }

    override fun equals(other: Any?) = kotlinEquals(other = other, properties = equalsProperties)

    override fun hashCode() = Objects.hash(
        uuid,
        parentOrganisationId,
        primaryPartyId,
        organisationMembershipId,
        effectiveTimestamp
    )
}


===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/organisation/repository/migration/R__vw_organisation.kt =====
package net.blugrid.api.organisation.repository.migration

import net.blugrid.api.db.mapping.toUnScopedViewSQL
import net.blugrid.api.db.migration.RepeatableDbMigration
import org.flywaydb.core.api.migration.Context

class R__vw_organisation : RepeatableDbMigration() {
    override fun migrate(context: Context) {
        runMigration(context, organisationTableDefinition.toUnScopedViewSQL())
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/organisation/repository/migration/OrganisationTableDefinition.kt =====
package net.blugrid.api.organisation.repository.migration

import net.blugrid.api.db.model.DatabaseColumn
import net.blugrid.api.db.model.DatabaseTable

val organisationTableDefinition: DatabaseTable = DatabaseTable(
    name = "organisation_old",
    columns = listOf(
        DatabaseColumn(name = "parent_tenant_id", dataType = "T_IDENTITY"),
        DatabaseColumn(name = "primary_party_id", dataType = "T_IDENTITY"),
        DatabaseColumn(name = "organisation_membership_id", dataType = "T_IDENTITY"),
        DatabaseColumn(name = "effective_timestamp", dataType = "T_TIMESTAMP"),
    ),
)

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/organisation/repository/migration/V2020_04_01_09_00__organisation.kt =====
package net.blugrid.api.organisation.repository.migration

import net.blugrid.api.db.mapping.toUnScopedTableSQL
import net.blugrid.api.db.migration.DbMigration
import org.flywaydb.core.api.migration.Context

class V2020_04_01_09_00__tenant : DbMigration() {

    override fun migrate(context: Context) {
        runMigration(context, organisationTableDefinition.toUnScopedTableSQL())
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/organisation/repository/OrganisationRepository.kt =====
package net.blugrid.api.organisation.repository

import io.micronaut.context.annotation.Executable
import io.micronaut.data.annotation.Repository
import net.blugrid.api.organisation.repository.model.OrganisationEntityOld
import net.blugrid.api.common.repository.GenericCrudRepository

@Repository
interface OrganisationRepository : GenericCrudRepository<OrganisationEntityOld> {
    @Executable
    override fun update(update: OrganisationEntityOld): OrganisationEntityOld
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/Application.kt =====
package net.blugrid.api


import io.micronaut.runtime.Micronaut.run


fun main(args: Array<String>) {
    run(*args)
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/resources/db/migration/R__3_party_id_by_role_id.sql =====
DROP PROCEDURE IF EXISTS party_id_by_role();
CREATE OR REPLACE FUNCTION party_id_by_role(
    IN in_organisation_membership_id t_identity
) RETURNS t_identity AS
$body$
DECLARE
    the_party_id T_IDENTITY;
    table_exists BOOLEAN = FALSE;
BEGIN
    PERFORM 1
    FROM pg_catalog.pg_class c
    JOIN pg_catalog.pg_namespace n
    ON (n.oid = c.relnamespace)
    AND (c.relkind = 'p')
    AND (c.relname = 'organisation_membership')
    AND (n.nspname = '$$$schema$$$');

    IF found THEN
        SELECT pr.party_id from organisation_membership pr
        WHERE pr.id = in_organisation_membership_id
        LIMIT 1
        INTO the_party_id;

        RETURN the_party_id;
    ELSE
        RETURN -1;
    END IF;
END;
$body$ LANGUAGE 'plpgsql';

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/resources/db/migration/R__3_display_name_by_role_id.sql =====
DROP PROCEDURE IF EXISTS party_display_name_by_role();
CREATE OR REPLACE FUNCTION party_display_name_by_role(
    IN in_organisation_membership_id t_identity
) RETURNS TEXT AS
$body$
DECLARE
    the_display_name TEXT;
    table_exists BOOLEAN = FALSE;
BEGIN
    PERFORM 1
    FROM pg_catalog.pg_class c
    JOIN pg_catalog.pg_namespace n
    ON (n.oid = c.relnamespace)
    AND (c.relkind = 'r')
    AND (c.relname = 'person')
    AND (n.nspname = '$$$schema$$$');

    IF found THEN
        SELECT person_display_name(p.salutation, p.first_name, p.middle_names, p.last_name, p.user_name) AS display_name
        FROM organisation_membership pr
                 JOIN person p
                      ON p.id = pr.party_id AND pr.id = in_organisation_membership_id

        UNION DISTINCT

        SELECT p.trading_name AS display_name
        FROM organisation_membership pr
                 JOIN business p
                      ON p.id = pr.party_id AND pr.id = in_organisation_membership_id

        UNION DISTINCT

        SELECT p.user_name AS display_name
        FROM organisation_membership pr
                 JOIN anonymous_party p
                      ON p.id = pr.party_id AND pr.id = in_organisation_membership_id

        LIMIT 1
        INTO the_display_name;

        RETURN the_display_name;
    ELSE
        RETURN 'Unknown';
    END IF;
END;
$body$ LANGUAGE 'plpgsql';

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/resources/logback.xml =====
<configuration>

    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <withJansi>true</withJansi>
        <!-- encoders are assigned the type
             ch.qos.logback.classic.encoder.PatternLayoutEncoder by default -->
        <encoder>
            <pattern>%cyan(%d{HH:mm:ss.SSS}) %gray([%thread]) %highlight(%-5level) %magenta(%logger{36}) - %msg%n</pattern>
        </encoder>
    </appender>

    <root level="info">
        <appender-ref ref="STDOUT"/>
    </root>
</configuration>

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/resources/application-consul.yml =====
micronaut:
  application:
    name: ${SERVICE_NAME:restApi}
  config-client:
    enabled: true

consul:
  client:
    registration:
      enabled: true
    defaultZone: "${CONSUL_HOST:10.200.10.1}:${CONSUL_PORT:8500}"

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/resources/application-security.yml =====
#tag::env[]
env:
  name: ${SERVICE_NAME:restApi}
  server:
    baseUri: ${SERVICE_BASE_URI:`http://localhost:8080`}
  web:
    baseUri: ${WEB_BASE_URI:`http://localhost:4201`}
  consul:
    host: ${CONSUL_HOST:consul}
    port: ${CONSUL_PORT:8500}
  db:
    dbname: bizkinetics
    schema: ${POSTGRES_SCHEMA:common}
    host-1:
      name: ${POSTGRES_HOST_1:localhost}
      port: ${POSTGRES_PORT_1:5432}
      username: ${POSTGRES_USERNAME_1:postgres}
      password: ${POSTGRES_PASSWORD_1:password}
    host-2:
      name: ${POSTGRES_HOST_2:localhost}
      port: ${POSTGRES_PORT_2:5432}
      username: ${POSTGRES_USERNAME_2:postgres}
      password: ${POSTGRES_PASSWORD_2:password}
#end::env[]
---
#tag::security[]
redirect:
  loginCallbackUrl: "${env.server.baseUri}${micronaut.server.context-path}/oauth/callback"
  loginRedirectUri: "${env.server.baseUri}${micronaut.server.context-path}/oauth/login"
  loginSuccessUrl: "${env.web.baseUri}/#/app/dashboard"  # ToDo: This needs to be configured
  loginFailureUrl: "${env.web.baseUri}/#/error/login-failure"
  logoutCallbackUrl: "${env.server.baseUri}${micronaut.server.context-path}/logout/callback"
  logoutUrl: "${env.web.baseUri}/#/logout"  # ToDo: This needs to be configured
  registrationUrl: "${env.server.baseUri}${micronaut.server.context-path}/party-registration/signup"
  registrationCallbackUrl: "${redirect.registrationUrl}/callback"
security:
  auth0:
    audience: "https://dev.bizkinetics.com.au/api/rest"
    auth0Domain: "https://bizkinetics.au.auth0.com"
    clientId: "mR4yoUpZJQ4Ttk9zLcyH7jcMwirQydZG"
  cookies:
    jwt: "JWT"
    oauthPkce: "OAUTH2_PKCE"
    oathState: "OAUTH2_STATE"
    oathNonce: "OPENID_NONCE"
micronaut:
  server:
    context-path: ""
    cors:
      enabled: true
      configurations:
        all:
          allowed-origins:
            - "${env.web.baseUri}"
            - "http://localhost:4201"
            - "http://dev.bizkinetics.com.au"
            - "https://dev.bizkinetics.com.au"
          allowed-methods:
            - HEAD
            - OPTIONS
            - POST
            - PUT
            - GET
          allowed-headers:
            - Content-Type
            - Authorization
          allow-credentials: true
  security:
    enabled: true
    authentication: idtoken
    endpoints:
      logout:
        enabled: true
        get-allowed: true
        path: "/logout"
    intercept-url-map:
      - pattern: "/admin/**"
        http-method: GET
        access:
          - isAnonymous()
      - pattern: "/oauth/**"
        http-method: GET
        access:
          - isAnonymous()
      - pattern: "/swagger/**"
        http-method: GET
        access:
          - isAnonymous()
      - pattern: "/swagger-ui/**"
        http-method: GET
        access:
          - isAnonymous()
      - pattern: "/**"
        http-method: OPTIONS
        access:
          - isAnonymous()
      - pattern: "/**"
        access:
          - isAuthenticated()
    oauth2:
      clients:
        auth0:
          client-id: "${OAUTH_CLIENT_ID:mR4yoUpZJQ4Ttk9zLcyH7jcMwirQydZG}"
          client-secret: "${OAUTH_CLIENT_SECRET:A62x6oAXb556euKq-CcNs131iFSaq71buRE7I8OobXkPAxFOYjXoBT9UJd3L6fIg}"
          openid:
            issuer: "https://bizkinetics.au.auth0.com/"
            jwks-uri: "https://bizkinetics.au.auth0.com/.well-known/jwks.json/"
            scopes: "openid profile email"
            end-session:
              enabled: false
      default-provider: auth0
    redirect:
      login-success: "${env.web.baseUri}/#/app/dashboard"  # ToDo: This needs to be configured
      login-failure: "${env.web.baseUri}/#/error/login-failure"
      logout: "${env.web.baseUri}/#/logout"  # ToDo: This needs to be configured
    token:
      cookie:
        enabled: true
      jwt:
        enabled: true
        signatures:
          jwks-static:
            selfSigned:
              path: "jwks.json"
  multitenancy:
    tenantresolver:
      httpheader:
        header-name: tenantId
        enabled: true
#end::security[]
---
#tag::endpoints[]
endpoints:
  all:
    enabled: true
    path: "/admin/"
    sensitive: false
#end::endpoints[]

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/resources/application-multitenant-test.yml =====
env.db.schema: multitenant

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/resources/application-security-tracing.yml =====

logger:
  levels:
    net.blugrid.api.security: TRACE
    com.fasterxml.jackson: TRACE
    io.micronaut.security: TRACE

===== ./common/common-kotlin/common-api/common-api-multitenant/src/test/kotlin/api/blugrid/net/ApplicationTest.kt =====
package net.blugrid.api

import io.micronaut.runtime.EmbeddedApplication
import io.micronaut.test.extensions.junit5.annotation.MicronautTest
import jakarta.inject.Inject
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test

@MicronautTest
internal class ApplicationTest {
    @Inject
    var application: EmbeddedApplication<*>? = null

    @Test
    fun testItWorks() {
        Assertions.assertTrue(application!!.isRunning)
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/integTest/kotlin/net/blugrid/api/example/factory/BookFactory.kt =====
package net.blugrid.api.example.factory

import io.github.serpro69.kfaker.faker
import net.blugrid.api.example.model.Book
import net.blugrid.api.example.model.BookCreate
import java.util.UUID

val faker = faker {}

fun createBook(
    uuid: UUID? = null
): BookCreate =
    BookCreate(
        uuid = uuid ?: UUID.randomUUID(),
        name = faker.random.randomString(6)
    )

fun Book.update(name: String = faker.random.randomString(6)): Book {
    return this.copy(
        name = name
    )
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/integTest/kotlin/net/blugrid/api/example/controller/BookControllerIntegTest.kt =====
package net.blugrid.api.example.controller

import io.micronaut.data.model.Pageable
import io.micronaut.data.model.Sort
import io.micronaut.data.model.Sort.Order
import io.micronaut.data.model.Sort.Order.Direction.ASC
import io.micronaut.http.client.HttpClient
import io.micronaut.http.client.annotation.Client
import net.blugrid.api.BaseMultitenantIntegTest
import net.blugrid.api.example.factory.createBook
import net.blugrid.api.example.mapping.BookMapper
import net.blugrid.api.example.model.Book
import net.blugrid.api.test.security.TestApplicationContext
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.api.Test

@DisplayName("Book")
class BookControllerIntegTest(
    private val mapper: BookMapper,
    @Client("/") override val client: HttpClient
) : BaseMultitenantIntegTest(
    baseUri = BookController.PATH,
    client = client
) {

    @BeforeEach
    fun setup() {
        TestApplicationContext.configureTenantApplicationContext()
    }

    @Test
    fun `create Book`() {
        assertCreate(
            createPayload = createBook(),
            responseType = Book::class.java
        )
    }

    @Test
    fun `update Book`() {
        val initialBook = assertCreate(createBook(), Book::class.java)
        val update = mapper.resourceToUpdate(initialBook.copy(name = "new name"))

        assertUpdate(
            updatePayload = update,
            responseType = Book::class.java
        )
    }

    @Test
    fun `get Book by Id`() {
        assertGetById(
            createPayload = createBook(),
            responseType = Book::class.java
        )
    }

    @Test
    fun `get Book Page`() {
        assertGetPage(
            resources = listOf(createBook(), createBook(), createBook()),
            pageable = Pageable.from(1, 2, Sort.of(Order("name", ASC, false))),
            responseType = Book::class.java
        )
    }

    @Test
    fun `delete Book`() {
        assertDelete(
            createPayload = createBook(),
            responseType = Book::class.java
        )
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/integTest/kotlin/net/blugrid/api/security/service/SecurityContextServiceTest.kt =====
package net.blugrid.api.security.service

import io.github.serpro69.kfaker.faker
import io.micronaut.test.extensions.junit5.annotation.MicronautTest
import jakarta.inject.Inject
import net.blugrid.api.common.model.organisation.OrganisationCreate
import net.blugrid.api.example.model.BookCreate
import net.blugrid.api.example.service.BookStateServiceImpl
import net.blugrid.api.organisation.service.OrganisationStateServiceImpl
import net.blugrid.api.security.context.doInRequestContext
import org.hamcrest.CoreMatchers.equalTo
import org.hamcrest.MatcherAssert.assertThat
import org.junit.jupiter.api.Test
import java.util.UUID

@MicronautTest(environments = ["logging", "json", "security", "db", "multitenant-test"])
class SecurityContextServiceTest {

    @Inject
    lateinit var securityContextService: SecurityContextServiceImpl

    @Inject
    lateinit var bookStateService: BookStateServiceImpl

    @Inject
    lateinit var organisationStateService: OrganisationStateServiceImpl

    val faker = faker {}

    @Test
    fun `test runWithTenantId saves to the database with the assumed tenantId`() {
        val firstTenantId = 1L
        val secondTenantId = 2L
        doInRequestContext {
            securityContextService.runWithTenantId(firstTenantId) {
                bookStateService.create(book())
                    .also { assertThat("run with first tenantId", it.permission!!.tenantId, equalTo(firstTenantId)) }

                organisationStateService.create(OrganisationCreate(uuid = UUID.randomUUID(), parentOrganisationId = -1))

                securityContextService.runWithTenantId(secondTenantId) {
                    bookStateService.create(book())
                        .also { assertThat("run with second tenantId", it.permission!!.tenantId, equalTo(secondTenantId)) }
                }

                bookStateService.create(book())
                    .also { assertThat("run with first tenantId again", it.permission!!.tenantId, equalTo(firstTenantId)) }
            }
        }
    }

    private fun book() = BookCreate(uuid = UUID.randomUUID(), name = faker.cannabis.strains())
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/integTest/kotlin/net/blugrid/api/organisation/controller/OrganisationControllerIntegTest.kt =====
package net.blugrid.api.organisation.controller

import io.micronaut.data.model.Pageable
import io.micronaut.data.model.Sort
import io.micronaut.data.model.Sort.Order
import io.micronaut.data.model.Sort.Order.Direction.DESC
import io.micronaut.http.client.HttpClient
import io.micronaut.http.client.annotation.Client
import net.blugrid.api.BaseMultitenantIntegTest
import net.blugrid.api.common.model.organisation.Organisation
import net.blugrid.api.common.model.organisation.OrganisationCreate
import net.blugrid.api.common.model.organisation.OrganisationUpdate
import net.blugrid.api.organisation.mapper.OrganisationMapper
import net.blugrid.api.test.security.TestApplicationContext
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.api.Test
import java.time.LocalDateTime
import java.util.UUID

@DisplayName("Organisation")
class OrganisationControllerIntegTest(
    private val mapper: OrganisationMapper,
    @Client("/") override val client: HttpClient
) : BaseMultitenantIntegTest(
    baseUri = OrganisationController.PATH,
    client = client
) {

    @BeforeEach
    fun setup() {
        TestApplicationContext.configureTenantApplicationContext()
    }

    private fun createOrganisation() =
        OrganisationCreate(
            uuid = UUID.randomUUID(),
            parentOrganisationId = -1,
            effectiveTimestamp = LocalDateTime.now()
        )

    @Test
    fun `create Organisation`() {
        assertCreate(
            createPayload = createOrganisation(),
            responseType = Organisation::class.java,
        )
    }

    @Test
    fun `update Organisation`() {
        val initialOrganisation = assertCreate(
            createPayload = createOrganisation(),
            responseType = Organisation::class.java,
        )

        assertUpdate(
            updatePayload = OrganisationUpdate(
                id = initialOrganisation.id,
                uuid = initialOrganisation.uuid,
                parentOrganisationId = initialOrganisation.parentOrganisationId,
                effectiveTimestamp = initialOrganisation.effectiveTimestamp,
                primaryPartyId = 123L,
                organisationMembershipId = 456L
            ),
            responseType = Organisation::class.java,
        )
    }

    @Test
    fun `get Organisation by Id`() {
        assertGetById(
            createPayload = createOrganisation(),
            responseType = Organisation::class.java,
        )
    }

    @Test
    fun `get Organisation Page`() {
        assertGetPage(
            resources = listOf(createOrganisation(), createOrganisation(), createOrganisation()),
            pageable = Pageable.from(0, 25, Sort.of(Order("displayName", DESC, true))),
            responseType = Organisation::class.java,
        )
    }

    @Test
    fun `delete Organisation`() {
        assertDelete(
            createPayload = createOrganisation(),
            responseType = Organisation::class.java,
        )
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/integTest/kotlin/net/blugrid/api/BaseMultitenantIntegTest.kt =====
package net.blugrid.api

import io.micronaut.http.client.HttpClient
import io.micronaut.http.client.annotation.Client
import io.micronaut.test.extensions.junit5.annotation.MicronautTest
import net.blugrid.api.test.controller.CommonControllerIntegTest

@MicronautTest(environments = ["logging", "json", "security", "db", "multitenant-test"])
open class BaseMultitenantIntegTest(
    override val baseUri: String,
    @Client("/") override val client: HttpClient
) : CommonControllerIntegTest(
    baseUri = baseUri,
    client = client
)

===== ./common/common-kotlin/common-api/common-api-multitenant/gradle/wrapper/gradle-wrapper.jar =====
PK
     A            	   META-INF/ PK
     A m±>=@   ?      META-INF/MANIFEST.MFÛMÃÀLK-.—K-*ŒÃœ≥R0‘3‡ÂÚÃ-»IÕMÕ+I,
ÍÜdñ‰§Z)∏%¶‰§*Ñ%§ÒrÒr PK
     A               org/ PK
     A               org/gradle/ PK
     A               org/gradle/wrapper/ PK
     A Pr∫ô´	  -  *   org/gradle/wrapper/GradleWrapperMain.classùXx«˛ù¥ß’¢r¢â"üE;â"L1X¬!	$| @D‡ ã¥íÓn≈ﬁ%N‚tßíFäß'q
Núì∞ƒNwzÔ’ÈΩì‚8˘g˜t∫≤ }˘>4∑ÛÊÕ+ˇ{Ûﬁè>Ò–e k≈"œT±œR°‚Ÿrxéû´‡y*J$πœWpóÇ¯ÒB?^$	/VÒº‘ès~ºL¡ÀUTI∆*ºB.æR≈´p^¡´UÃq…ØQÒZºNäΩ[˜»·ı*Ó≈º—è7˘ÒfoQVuxõäZº]¡;T,ïÓ≈;‹Á«ªTÑnÔ¡˝ÚÎΩrxüﬁÔ«¸∏†¢»˘U|™¯0R*F1¶‚"R0Æ‡#*6·íä;pŸè+r√G˝xX¡#ÚÛcrÒ„*>ÅOñ·S¯¥ÇœHŒG•Hí?ãœ…·Û*æÄ/™¯æ¨‡+*v‚´swÏki∑ÈÌnﬂw§£kW˚ëÆ==ù]ª·„˙)Ω1™«áªm+jòŸj∆∂∑˜Î—§!,ÿﬁ÷ﬁ”“noÀ»©N≥ÏÌÌlÔ…PÊP6ïléƒ#ˆÅ¢P˝~_´9@m·H‹ÿùå3¨˝X‘êFö˝ztønE‰<MÙŸ√ëÑ¿≤∞i5Y˙@‘h<mÈ##Ü’∏√ôpgªÙHúN˘b¸ò:TË≤£]∑Ü(Ø⁄cY@MKﬁ©[Â.Gƒl‹â\-±L.⁄#!)äeöv[Ñº%#∫ï0¯Qómg4“ÿj∆bz|@:ª«·°†“~3~äÇ‰Ü˘∫œ&l#∂'£*K@Îƒ6 PÃ;¬¯y®tÙdÌ#{e"O,!r˝K⁄ëh„$]˙È Í•±få~ñDÕ°!iÏØ(ÑùEÓ´HS⁄œ˝I€$ˇ/˛π\ˆˆ3˝ÜÎéÇØ18˙¿@>D*‰mpnòrg2‚µ°<Z~\´“ñe+´∞˘£LOid&5‚Ü›ÿªØìkÇ(- !vüç€˙ôåc‰	fe‹n≥5™'m∆‡v3h∑,àô›∂ﬁbó>‚$øÇØ¨MﬁS∑Nk”ıb©võI´ﬂpÛ|N¡A[-2<D¥ôß„QS–∞›û[CñÜ£`Fß:æÅoˇ¸”…döN`(»ZÈ≤≠JR‡™aÊ∞Üo·€
æ£·ª¯yN
üLF[`›ˇq˛4|?–C¸H¡è5¸è1ã&ì≥CO3à~äü)¯πÜ_‡ó"xöÜú‘pOW+ø∆oÊ{∏’)Îr4 SÓ.ú¶…k$†øÕEpÇèn∑$FåYcIæﬂ…·˜À=ò∑±h%lN$^L8◊°?‡èZv—%wÁÍ…∫'≈˛I¡ü5¸’7‹ø„™Ü‡*ÎƒÌÃkâ@YŒñ‚_rﬂø<Æ·?xB¡5:$1CE¬ßàbMîpä◊9ADj2'ˆ%„v$fd)_¯5Q*≠“xM®¢L`K´èõvp¿†ì1Ü0ÿ/œ›Ò
öV0çIê?8hô±`?{”1=aó/M,_ùìá]«é˝∂&41S™+WDÖ&*Eï"ö®S©ˆ˙\≥pU≥51GÃeFäyä®—ƒ|I\ ÛÉ"jÆy(•ŒÖ¨çì:≤†—≤Åì45O˜∆Oƒyª&≈íP˝t∫Sâô∫—≥á^GDW¶‘M≈√÷-÷P2fƒÌ©LÀ»ïçs02î¥òúKj\°3≤¸;≠y∫ﬁxˆŒ¨mNq`°2ÏÏv1o¢]vS%›Ï∂M£*gIaiÆœõÃÚR#/ IªEVå@(_1®õ∫”à˘ù–-ÎZË¥˙zÆ√y=¶0ﬁ∂BS5¯√◊U„U^'zîÁjN1u(Ü„Å8‰ïDû*‹
ÓπÊUÄ=ã=]Õ§¡Cd~”Í`>EÂç≠öâZxï «¥0Õú◊-N7J3s¶‡D≤Á^û≤Ï÷Â}Q≥åë®.oVÇ¸õB”äµóÃÂ”€JT*&©NÂu]ß”6ã6´GõÈ>Í&åO0§Vƒ>€òœ”<Q»Ø…·¬#ü1Ó-â/†©ì´î7ÔZk¨ÉîŒ\,3◊N∑îáõsK{òÂÃ6ùü«)/°Û≤¡Í∂Ã”ÚÈ†#√◊›?l8∑y„dRè†ŸŸ¸nwkÆ?HÇòŒ¿›‚Å˛!è=^ëõÌ±WZ‚ˆØ83O∂iÁ∞—î¢!√Èπ.MxòÕL—ÅB*ç∂ÕÙ£Ã…TI ÔB’ñ∏∞Mt$Oã	«f/˙îï<”≥ñMèìÔû~â{]€v‰< ¬¶y"9¬ÀNË`˝~‹˘ü'Ä5cvs6eúweÕ5Œ˜dÕ+8ﬂõ5ØÑüﬂº∑sÏ!•ëøÇø≈£òÒÄ√“À±ƒ!±ü£Ê2‡ ûÃﬂRÙ· π∏YúßQe§=2Ü¢ä1¯vq(ﬁ=éíæQ(Mæ_
˛5æ‚K(Ì+
îu˜˘Zw
3S(ü$WHr•$GwöäkäÂﬁÍ_C
≥öJ∆0ªI©QH-«≤ÃMa^
55\ôﬂ‰Áä’»È¬¶“ïcX‘§÷®„®Ì´)á‡∏!≈ç„®Î#Û(èb…8ñR÷≤ñOzæéÀ	tàæ÷£+0+±´∞´—Å5Ù&b±éÔù0p3Œ`ÓDÓ¬fúcòŒc+F´Éﬁàã·v'|ó˘^:LDKqG¯5É§§√(¢û˚°„πˆ‚$˙1@‘èrn`ê1∏s√P®´ïw…√Â9⁄t'(Ì<mã"∆àƒ=&ø˘I:BYE¸]LTB}+ı£h√
ÇËVd&¡(w∂Ï@›ÆCß„P–„òÁ+‚8$øé:©Ú!òVª!ù_e‰J˜ﬂÖº,geYôÉ("ë—íÊõ+Ì§òU¸[h¨I·¶Q¨Õ∑'K‹‹å8>R”‚#Ä3¯€PSXó¬˙6§pÛm˜afxõ˙Vå‚ñ+T—hNaÛ=ò'âÅ[}ó∞•Ø®°{[GÒ§+Ñ™Â"∂	\ßÕjE˚GrSh#n≈v"◊J¥§mÀ"–≤
ü èR5h!Ràâq+m‹¡dË n“ˆÜØÇ˚í8≈Y5wûfä	Æk¸:ÀØÖL8wı©¸´ÇoüÇçè£T¡¡NÖJU˘M;‹ÁdP€(Ka˚›òÂX,';RËêfè°S¬XîtÉj1üAûÑ≥÷…DWi¯¨QÂC7≠fSZM˘8vRzUç‚∂¸ËD≥ƒïß≈	<√·∫ÛPK
     A €∆.q/   3   #   gradle-wrapper-classpath.properties+( œJM.)∂M/JL…I’MŒ…‘Å2Àã
Rãtã3ãRS∏äJÛJ2sSmπ PK
     A            )   gradle-wrapper-parameter-names.properties PK
     A               org/gradle/cli/ PK
     A ’‹?Æ<  S  1   org/gradle/cli/AbstractCommandLineConverter.classïT]oA=ãÎ⁄"∂µ~C?îèR*O¶“h4!≠“ƒ«aY◊m`óC£¬ﬂ¢/4—ƒ‡è2ﬁêPñ¥ÙaÁﬁ9{ÔπsÊﬁ›?˛PFŸ@;:vD∞c@«Û¿{xY9yÜx’ı\Ycàfsß⁄ëﬂ±VÆg{m[¥xªKH™·[º{ ÖÏ'†&?ªÜb√N…º”µKV◊-’€)∏%è¸^è{ùÄÏ»˜Œm!mQaÿ∏ÃıµˇüØ|¢j´U©õnçÜ√l„åüÛRó{NÈÖ¨ïÏ§}f[≤íC§Öá¥¨-¢†kíÙ⁄ñ¡=,»ç˜πÿÇak^¿Ã¡ﬂ´ä^t Í÷î¬ı•-Jå◊_,ª/]ﬂËÿc∏’tèÀ°†+;Xöç®räÓCµuVQCWà	u¡h˙CaŸo‹†èô´˙∂‘1a‡6C˙∫Î2QƒæâL‹√KÜ¬&Ñ!9Øâa{	Q·23Qu·{∂'ßM°Ü–~r’ê›Ïı3|i153ØmnûDevf®ËŒﬂÜJÖ£ñö~-CÖH˝;"d©9¥ö¥´ìedc˘∞‰Dqá÷∏SX°’`I≤w/!)≤å:∑Fy›7≤ŸÕ_à|º@Ù8_AÀ#ƒˆFàüVX! K`ùˆ™R~ú;©xÎÙÜ)Ô>=äN‚Rnpé¥‚ÿúúcˇhˇò‚üêØÚœîÙ4=c/É-e∑ˇPK
     A ◊Éµ≥X  Ï
  ;   org/gradle/cli/AbstractPropertiesCommandLineConverter.class≠V[WU˛N2…¿0Â	H°∞‘Ñ§ƒKKµIQJ©çÜã¶Çÿ;LÜ0f‚Ã·O¯ÓZæ˚Z_¢t≠∫˙ÏˇÒAó∑}N.i 2Y9ÁÏ}ˆﬁÁ;˚vÚÎﬂO6æQ0å˜e|†`Û|∏£`w,‚'?‰´˚
“¯H¡«»Ù`	À=ò≈
Vªâ>ÌB∂Éx¿âœ¯∞&cùÎ.cC∆¡îiôﬁÉ?]cêÏº¡–ó1-cπº∑i8¥Õ"qB[◊äköcr∫∆îºm”e∏ô±ùB¢‡h˘¢ë–ãfb~”ıM˜Vªd8ûi∏ˆﬁûfÂπŸ€⁄'¶·$
F]Ëp•‰ô∂≈0âfv¥}-Q‘¨B"Î9¶U —ë—ªÜßôE#œ0÷fœ’≥f±[∑≠-≥PvÚT‰4ÿ–V5«%\‹¡íX3LæXû§Ì⁄QgIWëë¥¨W]¿pßç0ô?°ï¨:£Ïô≈ƒíVJFO—πíMA`i
“Æq∏¶À∆‚A…1\W@
µÛ¶\Ï∂A‹äÄA)5"…ì„4Ç°Ê‰8,’‰F≥h™J+gé^»zöæK¬éåáaÒ@7™†e<¢†fÕÇ•y"®ﬂæ¥;D='˛˚ö+õ;ÜÓ%£≠,Ü¸WªíJù/G¨dÌ≤£˜L∂Xg<√m©x#˝ßÌ™x„*&0.„Ko '„+èAì|g∫å<ﬂ° o©(`[Ü©bª*äÿSa¡¶ºæ≠¢ÑØ†¬Å´¬Cô˚î%MóU≈4•‹πz›˘%‹LEu|töög∑1qBuﬁ)î˜Àk$1√¯ã˙
5÷»√÷xE;i1gØ˜Yu[sÎ∞®™ØD:2‹KZMÕu6Ú?Al©ÜT'∂[Ù'\ÌLíz	Ω¢oíBëìEü1]^ÑΩÕÜ.≥ı°&Öz6KÆZ6<Ò∂“S+YÇh~ﬂu.õVﬁ8XŸb∑ªuö˜˘2©øi’Ó∞ïtªeû‘dè£Nß€æ≥·H;æ4AÜ¡?2/y/ï†ôjÅÈü¿~§Ö£43å1∫∏ÑÀÄ$Òæ Êâ⁄<…gíyWjFK$Ìß˘j,æˇt˛ÏÜDìî≠ ∞Ø ∏'RÆ†k˝¯‘$G	Ë}/aäN‰∆´÷™ƒjä~å‰˙®˝DHõÒÊAR¸ÙﬂËÙ Õπ?∑ÇÓ
î#Ù0,_;Ç iqÅ·9|∑§)‘[Aﬂl ¯q"˚è0‡«˙% Të¬ÈqØ‘∂˛˘9˛ÑNêÍÀ‰Rê7¶»3‰Öw»ÛÑoÉê="\¸◊	”bÙç”jäËkDÛ€Ê∑ Q0ﬁæŒ·-˙È#KuÔsŒu‚‹Që˛ƒÄåŸøêê·cøc¯⁄∫) QÇ·=·–[˝ÛtxíV øp¢2ã?«`·'g[©Å:∂È´YM·∂òÁ˛PK
     A }≠ŒyG  K  1   org/gradle/cli/CommandLineArgumentException.classïëÕJ1ÖO˙3£µ∂Zm+Í¬Ó¥U‹V
"
¬‡¬ñÓ”iòFf…Ã®ØÂ™‡¬°ƒ$-U¥fqì{rÔwO»˚«ÎÄ34K(`ÀÑmuÁúûˆÍá˛=}§^DEËıS≈Eÿ=.ÂòT}.ÿmèò–Q§ïö/©‚&üãÖt¬Ç_™–GÃ"Ó] 8¶bl *Ãb&“´ÁÄ=§\ä.Å≥$°°•˛rA–^‚Ìõ2ò(˘dÊ[√≈Äfâ&’óVî˙2SªÊ∆oÎ/cßPFé	ÇŒ?^E∞˚5ˇ.)èŸ‚-‰ı/òï1ttu÷”yNÔNª3y±˜+:ñ¨⁄‘ï;X’ß∆¨JÎkñ‚†åuÕ0¨ úu£g‰ıÓ∂;«S‰~¬ˆt”æÖÃ 0w3ß*6¨≈M€]˚PK
     A ≥ﬂ‚˙  g  )   org/gradle/cli/CommandLineConverter.classçQMK√@}”÷∆‘Ø™'œ"4
F<6• EQ($xﬂ¶Î≤%›»vS˙€<¯¸Q‚6ÖL
]XvÊÕæ˜ÜôüﬂØo ˜8w–upJpíL-∏6Ñ~/ú≤ÛS¶Ñˇb∏f„î%Ïu<Ââ	º*DË<.˛id¶ÊŒn$Öb&◊úpW'<(aë—Râ`ƒq‡ŸKxÓÖôæ–lír?I•ˇ∆ÙúOFŸl∆‘$îjÁŒÆwê⁄¯∫vRm_Uà%J°°Ôù–ƒ˝™Ò∞vJQñÎÑ?…‘Í_î‰FÎ%p}ªb.∑;oæ∫ˇ-7€âZ‰3ÆÃfSm°Å’i∂M¥l∂g≥ñ≈€pl‘¿~Qqk*[9¿aØë#Ô…PK
     A Sf
’  g  &   org/gradle/cli/CommandLineOption.classùV[wU›ì¶ù4ô^à¥i°\‰"iBµ¥†≠‹Z.≈^–÷ä”dL¶ô0ôpÔw¸º¯¶º .ÅUYÀÂìæ˘¸.ó∏œd:ô‹§ÀáúÛùsæ≥ø€˛NÊ˜~˛¿À¯&åm8'„|úkEñZqoÈ¢ﬁâ‡.E
.ãAï±Aöåw√h/› 
iEHzW¬úØäÖ¬™8…â¡C^‹æ&KFAÜ-A6Û∂nÊ
:¶Æ®◊’T—÷ç‘úfèJhù”≥9’.ZöÑ›ïßc••°Ê≤©9€“sŸ—√º°®V∂∏™ÂÏ˘[y^⁄‰”7‘BÅ*õ´˜∆‚f$£“ñÓ8#!Z/!¨Á“≈e’ÊJÇ¥Dˇ≤ñYÃ/ÍˆäÑ°jˇL+õ Zj∆–RiCOçõ´´j.3•Á¥Y«à„o8£Â--≠⁄ZFBÀòû”Ì√bqü˘I[≥‘eCÌ_ê73öHafä´Àö5/ŒÑ√fZ5TKkw≥≈t√	⁄+:3ºÎŸNUÊ«≥-°ª“ ”Î©ÁkÉÍ¥ÕŸj˙Í¥öwÆ ( ∏.!πaëÅpV≥g◊)≥)ﬁ_CöΩ’{úâ¨®Öc.[$«k®“øël™π'Ë¥°´{‚RS|~2‰v∆?·ßÍÊıx+…⁄biÖ¢¡»zkNèu#£Y¢ j>ØÂ2”Z°†fYÀTº°ÚR≠Qéñ˚xu§ùWx8Rã∫±EÎ1√0o¯–ÔgÎmÒé¶•û74üä¢”År_q9ÈÎ\ÖWOïw∏ñ/j›hºäz"#ÒˇÅÂ–zŒ,ZiÌ§.Z™ªFkP†*ÿè$}Ÿ¬iµ∞B+
∂cáåõ
na∑Ç]bË«Ô·∂Ç˜1£‡|(°≥∫2>R1>a— †SzÅ¥â5 ÇÇΩxA¡$>UêDúÈºP~√.*8Ö”
ˆï Ô%>√ÑÇœÒÖ∏˚•ÇØµÇ;¬ÙŒg•®¬ÒŸÂ+Zö˛EkﬂåıM'
g”6-á0Î:˙¶NVÁœü=!!§{ä›LX`©e2zFªI´¡ú3Uˆ\…%—Nµße5CC]ÒZ]A·Å∫m—∏YC∂Y⁄b◊Z.+»Àÿ&%Ù≈«ˇÎb›`Ø)≥s‹4∫"((º·{±j^◊<ˇ∏∑ÒÎ†Q¡*∞>\∏ƒÚ÷{¯#ôÂÊúÛŒ¸%ù˝NÓÌ« ◊É\˝Å&9üI<ÜîxÇ¿˘«hzà`‚G4?DKyGNÆ!$azˇZ%‹≈V
a	ø"2ì¯	¡Å5(,ﬁ{˙Á¢ë‚∏!é€πä°=Ë∆V˙Ω£ÙÈ$•IjºHçùÙaºDˇõÑ/¸i;–ﬂa 
Á“Œ•Éîªx êödÙ…8$Ûã¨´T≈òfä+qΩY¯˙É£êr≤*6˜:^îõ]€%ê◊∏wG\ê788Àâ§HçÄir`¬Œv?/'®ÓíöÜÏñ™ÜÿŸ„Á®cÊGafÑ;B'îàF÷Ì|vÈv Ár»µ#·x=å∂zCƒ8Pc.∆Œ—}Çvr†cäπÎ¸JRÃè∞i1!§hÙπ«ÿÏà]—nä…GàïS≥ÖÜ¿Ø÷´”¡¢Ù0ßªÏ É.ßj»5"GOê•˙Ü ˝çô™Òéπn›ÊJ0∂∑Ô.b4÷Û-¬…Œùè–ªòn=åw≥"`<AÇF%H)$'J ^çz]√Bö$´ét∆°‰Aá“Åh3œ_«îÎ»?:kR<M„3Ë :Urö%∞n¡:ô«ˆﬁwêÉ˜l∫ÔS‚Íõæ¢u∫àﬁ⁄è
»Yr¬ÖÏê—∂Ô .¯;*€ƒ§«™aQN"ZÒÔ\°…©ˆ’áË™Å∏DàÀu!Œzq˘{9zø™ó3uzYbÁ÷ª‹U}y•ŒeëÚzØà\˝ä_ë9ÁqòwA4ó61¬GuüM!&÷∞ïbôΩÌŒcò'sØëBñèJ1œ∑ò˚ßP~YƒN¬{Yﬁ¢¥‡HãˇPK
     A ¸ÌäØ•   Â   (   org/gradle/cli/CommandLineParser$1.classÖåA
¬0Eˇhµµ
vÂ∫àkÉ^°(äÇ'àÌP[“íÍ·\x %¶∏t·ÛáÔˇ◊˚Ò∞∆8DbDàœÊfsﬁVä	≥Ã4ç‘≈æ“|í÷±]÷Ú.	”çŒïqï.‹^M"&Ãç-Eie°X‰™?·≈ä0ŸiÕ6S“9vÑ§ÎJÍR/5Á-!˝Wì§ Ùùæ_x`‡Ä°◊»_ÏÍÄ$˙ PK
     A $f{K  ø	  ;   org/gradle/cli/CommandLineParser$AfterFirstSubCommand.class≈VÎNQ˛N)=∞-PPÔà°-¥∞ÄBïã
AIﬂ∂]ÎBŸ%€E|ü¬W¿DÉJb¸ßÒôåqŒnÅb[∂ˇúÀÃúoæ9;3{~˛˛Ú¿ V$4#“HCTB"bÙb˜8Ü9ÓÕ®é1é„ºòî ·!«#é)è˘J-¢›I›»ErÜúÕ+ëL^ç$Ù≠-YÀ&UMYñçÇbƒ…z\’Tsía∂◊Ÿ¸oKú-±ã˜≠1∏zVahÇ•ù≠¥b<ì”yí¥%ıåú_ìUÏãB∑†ÀpqÍ•©3™Q0Ww“EHﬂº¶)F"/

Yç8rT¬°8ΩôcÀ
WS	CìÆ≠ö≤a¶∂MU◊8≠ˆ⁄vEJì∞^Ù&7‰◊r$/kπ»™i®Z.^.Èsf^ÜMÍd#'.ÆèæúnŸ©í–REŸiﬂﬁ∂íóÃÊ¢ºm}
é«õÁíŒ±∆¨LqΩâä!&ÜAÜ@-Á§U}«»(3™Hüé2õqW>¥·Ç~¥r<Òa≥s>Ã„)Có”’0å9yÆmj˙ÆV!:´©|∏äkÇÿ"%≤£ÉÖ*’˝5&òù@TZ•[AkI)Ü·™±Zb≤=NÌ Ür2¶jä¡≥Âæsùö∂Âôú…(ÖB`4JY:TCaÙŸe∫c™˘Uï®∞*Áúb2ÙîvåTzC…òágKEÀ‘∑NÑˆ∂RØ9ár,m:µÔBM}ØV¥Œ˜{"O.6∏ˇu1·≥†¢ã~Ë-ÙÎg~øhW¥™ÉKt/–Oëvs¥Ø£Ÿ}Ñ+
Ô£Ó=Ì]hß±YËÿ,ÍŸºl$Î Ÿ„Æ ÷ä˙…Æì7ıΩ ‹4O?¿ı	Óg‘ªû•˛Ôh; _ë¶!»ˆ—∏w i˝ ﬁıPò∂æ˛CE”ûEV–h`l≠l	Ì,Ö [±®m'GT&p›DA¨n” Eá¿¬È!iÿ/8<~ÅŸ[$õ"≠¿·VÙÏ8zèÄb3%Æ¯ë+é>g÷*h≈/V!r'Ó∑ﬂ¬¿eöß…m3=≥:IrÉÊõn	wÑøÅNƒ0Òæä!ÒÿäuÒ2ãa⁄Ì¬ÕI∑ÙPK
     A •D£¢  &  3   org/gradle/cli/CommandLineParser$AfterOptions.class≠ïmOA«ˇ{-Ωr-¥® >WÅ+pÄä"∆D!$MêFxa≤¥g9ΩÓôÌ°¯¸.æêD%—ƒ‡á2Œ^œr“ícöÏŒÃŒ˛ffwn˚Û◊∑ fq€ÄéQiåuì4Æ£h âIS∞tLÎòa»Tºzùãj…6√P…ì5´&y’µ≠äÎXOπlÿ’•}üÜ‘G8˛]Üë±x˜Ò2Cr…´<ß+€ıM[>„õ.YNîº
wÀ\:JçIÀi0dÔΩÙm˘‰çÔxB©ÀBÿr…ÂçÜM™u0r$fêÑéÓß¨Ûu˛~”^ıπÙõFÜ˛±“+˛ñ[.5k’óé®-åo0$∏¨©‰⁄z<AËòeËk Õ®¥ËS»b≈—∆VÁÔÖ˘g<±‚â?’d˛ `±SmÒÒ¢ët\cX>¬«cgÇ>–v¶’@]7|î-∆™∑-+ˆCGı≈@õœî™0ã≤j∏ûE77ÊcÈk‚µﬁâW7xÿíä1ß„f∑0œ0y¨dò8ŒŸ3Ãø5ËÛç?UÜ—∂=Ïæ
q~:5˙hòh˛k∫mqÈÛÂ’ÍÉ_Ú2w∑ÌC^Ä2
Ù\¶È•G@ıI]–Tüë•á¥G§i4gL∂Õ,~AbóTΩ4ˆ"A;ü£ã≠√`»ëm†Èé<NÅ§∞å~ß–BÁhV^Z‚cãï"ÿãCk14≤úÉ82”äé‹w$◊ãÊg$TÜ]ü +∞–tms!PIÁI“HæÄK!z1¨ŸP‘‚W§Ã}™°Vÿ“Ãâ§j¥»FìúWÖ_y˜…G≈Oô≈=∞›ÆE2Lµ8)«¶§+2	v^•õL∫'ù∆>Ú:CÛŸ§˙˜3qëÊÇ‰”Ùhb∆oPK
     A åãM¸  u  <   org/gradle/cli/CommandLineParser$BeforeFirstSubCommand.class≈VÎr€T˛é≠‰∏≤“:¶I ‡ßI|âskõÿiKí^â‹úrì’®±•é,”æè¿[îò2–˛É·xˆHnb◊N‰0ù·œπÏŸ≥˚Ìß=´˝Ûü_~0áá2NcÒK2Ü∞»ëì!aYFó√∏Ç´äÕ
«™Pª&C∆ué!‹‰∏%„6>í1Äuéºå(68
w˙ùoåz|Üa,oŸïL≈V∑´zF´ô5´VSÕÌºaÍwUªÆ€9“^6L√π¬ps“_˝uWº›¢óõ⁄dê÷¨mù·îl4je›æßñ´$âÊ-M≠n™∂!ˆM°$‡2≠Í-[øaÿußÿ(7m2(∑MS∑◊™jΩÆì⁄¢/»xWCiX;PÌBNg,ñYtT€)<vÀ‰¯Ña–[{æË–![[ì˘GÍ∑j¶™öïL—±≥íÎîL˘CÔ∞MÇ™]‘uÿ£ogπ˙Dí∑h[h€fzuºox∞Ö™B”«QŸ‰È¬µ∂sG}Ï~\é"√Œ…+ˇf›‹<ù√¨Ê‚Ω‹cêãV√÷(gDBwËLÓú≈àÇaú·∏«ê>ß‚Ú}õ¯î„3%l1ƒ¸¯T ü3,˘z∫oÓò÷≥Kfû=ÏH¡9å	T_1$w∞bW5›tÆ?’Ùfúköå5s$]%ΩòóÄ±âÒ˙ƒ4C‰ YÂG∫Êp|≠@EYx‘.˘Ü¥~H@√›Ñ]*ˇ[qËêÁrÂâjÎÌÄ;ò;˛kßGÊüÆG&éßƒ∞ﬁSEÍıQ…™¶Èız|qÜ◊|Ôy Û’påjÜäÅ(m™j›a8ﬂ
”ÀîWw[EñÇÒ^lqü·6vøÎ∆ (=≠ªWN#Ø#°rN©YSâñ•.8Õ‘~ÈÍrW¯˚√ü¥ˆøÄπˇø®K«*b‘;QÀ≈"QºiD@‘r0ºMª[¥“¨$í?!êH¶v¸ÅˆºC„Iq∆Ê—«f.…ÜÈåÙ1J∂·Æ®ñíå·úoZ˝}4´{êJ…€EﬂF‚Gû£?ı3x / J#“Ôòıƒ'æGtr)I€pÇÙïg{(EOJø‚T)ò.>GdÉ/ˆ-•G§WZo=sPﬂ#ó`K3ãQñ√[Fä]Fé]•∂p’Öæ‡Å⁄áÆbìY¨¶h@ò~R	§»Ê(Æ!çijJ3nêÅøë„ê8Bß# gõ°HW¢ôª‹±Ó˙Öa6Á:Nx*˚é9µ¿g\«Û.{bµÄÓ◊πË⁄∏Ñ˜i^Eàæ`ñ¬ NÛ∏$˙‰,í‘œSëDüº—gq¢üŒ‚c)Ä/h˛RíˇPK
     A ¥*´ZM  Ô  F   org/gradle/cli/CommandLineParser$CaseInsensitiveStringComparator.class•S]OA=w˚±P∑RÀáä"àUhAx1¶Ñ®MLö‘è§Ñ˜°Í‡vóÃnâ≈ˇ¿ã/ò¯`|ˆÒ„ŒÓÉEk‚CÁŒ‹9˜‹{Ng?ˇ¿&6∞Q)`Ã,9‹5À=K&Ωl£fc≈∆*!ø•|m2À’]B∂t%a¢•|˘|–ﬂìzGÏyú)∑ÇévÖVÊú&≥—+Ê"îM?î~®"u$€ëV~ØÙÖQ†	N”˜•nx"%<i∫Áˆ¥Ëz“Ìx el_¯]”ı•–°‘ïîuÇ›âO<∆“rÎ@	◊~œMêı·Lµ…5¡a§√Ëú]o≤≤Æ⁄ﬂ'◊€ëËº~&S—Á∫Ωÿ;êù®>ú©6m‹è¡#•n‘çÛ÷õuBÂ_–ÑÒ∂Í˘"Ò[öf)œ˝Âÿ÷∞‡m¶*¥ÉÅÓ»ß Hõj∑fäp…¡\Îp	•ﬂ©Lb ˚˙ËˇŸsÏâ ¬‘Eäã£›"L¶Ôd'hˆ¸@K”ü0}¡õ1/d¸MXEœnÿ¸ÖqsYX∆'>9|r9«\Ì=¨wº±P‰5oíÙóyÔ$ L†ÃëåÖi±ftñcyeıôÌπ∑»Õõ}ˆò≥ôò©lÙy:EÅæ¡°1k-©LYÕn3qß2ÆÚŒ‚\√uÊôM&:Â‚“cÓ#ÌˇÄÔ2ãµïO»≠ÚÔ˘„øà(&ÌJ`ÊRíá≠‘∫ÿÅôp6k∑0œ˜,ƒ¯€Xå„\âÁ∑ÿÓ*wô≈M/ç˝PK
     A |ÏRŒ–  &  =   org/gradle/cli/CommandLineParser$KnownOptionParserState.classÕXÈwUˇΩ6Õ§”Kë*EqDËítÅÇ;VkE¨¥E≠+.…ê§3uf“ÇÓªàäHQpCq<R¨‡z‹ˇÜÁ¯7x8ÍΩ3ì§mi˘‰ó˜ﬁ‹w˜ı%¸Ûı∑ ZÒÖåz‹%£wK∏GF)6îD„e#/q^ºËå∫IB2Ç	ÜåEÿ,£[¯îä`∞&,FíQã{˘”ñ‡ ®∆p#2bÿ*cÓ„õ˚e‹åÒ¡b»ˆ
‹ÇáyyD¬£|˝_?^Å'∞]¬ìL˙îÑß%<#†XCÆaôΩÆmòI	œdÌ}vö¶nw§4«—Åñ.ÀN∂$m-ë“[‚)£•√‘ÃDóaÍ7i∂£€ã'“_)ˆ%,:©OCÿÒ∞ â'"1ÅêH Wsu	œµØB/öãÎ:üU÷Ri∂≤≤k≥6¨µ§]#’“e8.›ï˜ISs”61^<Âz•ˇù“ÃdK`w≥[iòÜ€&p†~Ü^+Ó©‚éôôÒ}°+A÷ù≈(=È¡ç∫}´∂1Eê™.+Æ•˙4€‡Ô rrUı”1}≠&yˇÚ‚
&%œ…ñŸn'”É∫È
\[üÔﬁÜôÜ6¢e˘UÂ≥òEàÒ-›⁄P`›léÖfª=˙VóTXZ?cô≥ì∫{ÉÊ‰,)≠o∏√3é(áR:{©ÃK9 \À–ÌµA©(C^83üyÈìÌ +$º aáÑ~˚ˇÁ\qÏe^^ñl] À2^ZyYŒÀ
Æ√ip á˜Zi;Æ_op`´Ûpö9\âïºÏòõ´Óv€÷∂qâÛ’K
.≈e
¢hV–Ç•
ñ°U¡r\¢‡F¨àùZùL¨⁄◊É®.ÆõRtØ˙]R≠[‚‘©	KwT”rUW€¢´ö©fí∑ôZS.y◊n‹¨«I≥óÒ
´∑K¡´ÿ-∞≤›Tı¡!w[ñL—u»∂ÜçÑûP7Y∂?ÖËf	Ø)ÿÉQ]ËT∞kºé5ﬁ∏§®∑ª«°\ÚÛÖLZ¡ºÇp÷yqÌ±ŒDQ˚Ò¶Ñ∑ºçwºã›
‡=Ôs$⁄∫”)◊†À≤v‘›÷ßÕ¸ >P![ˇ>û‰uø\|¬ˇüI¯\@-V<
·∞¿•gÿZßYÕìàÊÄ5Õ®-4Œ§¶jß◊™®Á™¨”’mÕµl¯≈Z†n≠ÕÔ‘piS¨5Íøóò$Îª¶ób^°)ƒÃS∫ôt<Yù‘Û'ø¨%S®3bhT—àhO•¨ëÏî†ë*Œ*Æﬂ”¶ïoß¿˙i˜˘3iΩZ<Æ;Œ‚e+ñRÓòÈL)Ë…©FÂe=∂»iô<πªÄ„ãœ™ºa}™ëI«∏èeR(˙Ç˜_U}C˛∞&´Lsô≥àëÕ·ÍIƒô‹&“ÄÊ{ÇDöﬁvv}C~Z∞”â‹£A!±´m+=¥Œ‡4õ3â{ØŒ≥&àƒ÷≠·l•-9]ÿ2˛ÍÉJø8Ë«L™xƒ—©äßú∑”†ÛvöuﬁNsTOt.¡”J„ì Wd'˝¯)£Ω6*é¢$z•˝G:Ç≤hÏ¬—∆#ê¢MGâŒ'`˘aèG≠!b/ ƒTä◊1OºÅ±à˝X"ﬁƒ’Ñ≥¬Áåkp-‡ùXS·ùX◊Ôƒ⁄ñz'÷7D˜∏.–Ó-í¬X=—1»{±‡*˙´î–7ò’_˝·ﬁØ0˚(Œ˙.6Ü Ãıú¸k:ó≈∆QUÇuƒhÓ!‚XÍYQCﬁÄxí8@öøèZqm‚Ctäè<™}ÈYz∞
◊ìn´ÈB…È|:m7x⁄KHû4Ü≥G1ü%èìs0äY«P›œ^>Á–d%f≥˘‚sTãCP≈û`≈g^Ì·
ïÄÙt	§µ“ŒHë@⁄'ŸÿÑNÇrå"#¡ü^h‰€¡N∞oGQ7AUﬂëÁt$ãÂYFRk∫|≤Ùû√yﬁaCË@∆ÁgÇ≤∞pP∆…ÎËn'ªIÏ<:\(=ıƒö∆p—¡ˇÚŸ,ßú ·ùõ¡´ÌaÖµÓ‡ø“±<Á‘V≤‚8ÊäoﬂST¿=‚Gåàü∞K¸åQÒΩí~√qÒ;~‡Wq¬ÛWî|≤ãÚ∂õ‚\ä„‰π TŒœÅ€∞kqSêéù‰'◊Õ'Q.·ñøQsäw8øTh∑·⁄DL)Ÿ GcçMÛCG!O	ÿ+ûm>V6Âd‹çåæ†hd¨äF∆Ì^—©wêå¨˜¯ﬁâ&œaƒ‡†ëÓW–~qàˇ™p–NﬂΩÃæ2BIÓ ˛7ƒ¡≥!˘?PK
     A $ƒæ¢•  Ù  <   org/gradle/cli/CommandLineParser$MissingOptionArgState.classùïmO”P«ˇw›÷*àèLDŸ≤ë!®	Œá'ö`0¡W÷ÃöÓo;¢ÒçoÙ”¯BÖƒ~ ?îÒ‹∂ÃKÀíÓú€s~Á±Ìüøø~ò≈íér:í»'I*(uZG
7’Ÿåíäqî„òe–ú-œrD∑Ü_¯ÚK.]SÆz‹3åßBò≤js◊5]Üπö#≈Ü‰u€,n⁄V±Í4õ\‘kñ0ø…#ê%är◊ñwü°íÌê[càUù:Â3§WZÕSæ‚6ùúÆ9õ‹^„“RzxÛﬁZîÓ»sÀu-—êÀ≤Vµ–;ãÆûTJ∫…?nò§I/∏GQ≤µw|õm.≈UOí€Rnù! eCÂw‰&√†# ÷ª ∫@˚Î~ +éÿï:0ﬂ›rÔÊ`Ä¥#:Lâ:’ûÕ≠≈1«¶Øâ˜ˆ)˚[˘PRó2√‰q\ÙUß%7Õ«ñ⁄í—#63™ÜêVó€tú20è1,∏àKÓ`<éEÜ˘˛ñàa˙$˝eò=y&z∑ÉaÍ√	ù∞‹˝“˝ioŸ¶
S ûx[tø≠¶)<ÜL/gdËÌï§˜=Ij$ià®	—…0iOHã–*œˆ…~"∫CjÑÃAÊQÚ‹¬ {ùIú°≥—¿gIÇ/),£ﬂ9åÖ–≈™Âªà}kÛ4∫∂›¡—⁄Áq¡Á–ñÑúgü2¿`˛¢ª(LÔB˚~˜…«e√6n0ƒ)I')BÚeåá‡{aÇI¶„á°ü;rL∂°…vé\Q_Qî„ÎˇÌ”ï;˚Ç˚Í„å¿0¿•AS∏Bíe4hÿÿŒ°döv6l“oºíÆ„Ü_—îÔô•öÅ	ƒh8%1ı+aÍ˚U¬“' ù¯PK
     A TK>™  ƒ  =   org/gradle/cli/CommandLineParser$OptionAwareParserState.class≠U€n”@=õ§q‚∏$î6\ %§)M›K⁄@)Ωp)E° E*o«”ƒÆ÷ÖO·x·$
àJ| ÖòM›í*A./ﬁùô≥ÁågfÌüøæˇ PƒΩ8»©–0*w◊Tzå©»c\Öé	ì*L+(®àcVAQ¡uÜÑ·4õ‹Æï,€d»ñQ/‘Ø5ÃÇ—∞
OπpÕ⁄ÍÃC‘{iππôË\˚†êËeÀ∂º;Û¡`˘Ò
Cd’©Q≤IÈÿh5´¶x∆´ÚîÉ7*\X“ˆùô.C˙…∂g9ˆ æZŸ„≈µu€6≈jÉªÆI∏Ö¿,sΩôË]SM˛∂jí%º}√PæÙäøÊÖ∑ÎÖ≤',ªæ4˛ú!ÃE]&‹§ñ8ˆÜc$é${ø]p∆G”Ïßç±ıòo˚RÀNKÊö%çt◊Èi©®!âîÜ”ò”–èSnbX¡ºÜ[XP∞®a	ÀsÅô¨ºL±f	◊+∑™~òa∞ó[™›fò:Á~Ω®ÅZß)9hˆÊOÿSÜ…©≠Çªc¡sûõmœqÃr∫ú	|ÍØ’ºÒØFÀ¸ÀdU∫©∫‘©·‹0L◊ÕÕÕ–-=∆Ωîªı_ÓÔqk≥ﬁ•vrÆl0.í°œ•F“Â|©îúxÚÑ°! √≤JÑ”ö“'v¡tˆ!}r·O˛Y–Yä≥,T6Ç$Àaà|iä—ZœÌù‘Á˚ÃãdKTTü¯Ç»áCæ(≈¡Ú<—Cû(.‚≈.#„ÛÏ†Øç*Íü&™>ZŸ7Dﬂ!ΩeSZ2Bô«ﬁ#πá¯¶o™€o+5U…¿¶c”∫≈C›¢Ø{ïˆ
B£è*^Ÿv“#8G´Ni$Ëy6¢òé+˘ˇ—1Eà8≠3$r£]ãÿoPK
     A ò%‡Ãª  ™  7   org/gradle/cli/CommandLineParser$OptionComparator.classïTmO”P~Ó÷—Q:Ø
æÄ›
É2@ä.—,Y¿dÜƒèe4≥§kI€Ü?Ñ/~#â·≥ˇ∆®_çÁ∂N6).]œÀ}ŒsÓ=ÁÙ~˝ı˘ÄEî%d0#°üø˙0+bNÇ U¬J"E,IHs;ç'"V8|UƒSk"÷z6L€Ù7íeèA(;√≠™i;≠Êæ·æ—˜-ÚVù∫nÌÈÆ…Ì»)¯ÔLè!ª{‰õé]vöG∫´˚éÀ Wl€pÀñÓy!ñ™é€PÆ~`j›2U¬6u˚Äßy≠ªû·N_Â–ƒz`Q¢WÖk¬H-°Tà”	Ù√T|¿%|ëŒ⁄4y‘`ıP?÷UK∑jÕwMª°Ök…⁄w˜ç∫Øuzîä- «÷§§Òû$ﬁ/0LﬂÕ–[3∂Ó∑x—™ˇ⁄MÀ7-ıO•7‚±I‘RÕiπu„•…;?⁄ë~ûSÀ»b@∆ûâ†ôZΩa◊√B∂œœh˜ŒüÒ\∆∂iÆˆÇa+6eY˜åäÌ∂g˙Ê±—ô{"!c/&„™∆q„•ˇ˝øvéa∏[Îhä„«ÇZ◊0¸0	}ã•mjÜØ]{ñêÖa§=øe—ûB∫$Õ>ïΩPÌ∂ﬁ}‡4•s2Ø|=—ß’ÈQ*t±eË∫£Kä.@	>rdí•íd$S3gH|$%Å!z˜p'˚Üa“ÂÄ‹!…xã¢‡Dñ"π2{ä‰9Ñ∑Ï©OËπÄ∏SÏp≠ÁHsªwnL8Ötrô≠I"˛é!ˆyˆ3»∫2GYπv˜Çù¨‡>i<2áò†ÿ<lí4!ªMª{ÌnïVàôôŸÙÈ
˘‰ö#f¬dY˛‰"í5íâ®>¨{}FC¿ÂNSò∆#ZO‚qÄœ£H∑INQÕ2(R‘8ÈÙÀ¶…Sƒ<ŸiíÀˇPK
     A ‰fCòß  £  8   org/gradle/cli/CommandLineParser$OptionParserState.classïíﬂJA∆ø≥Y≥∫¶ˇ4’∂÷®£◊JoJ§P•Ö†ÖH.ºõ$√:≤ôïŸâ¯
}Ø/˙ }®“3õÄàÖ4ªﬂô≥ﬂ˘Œú˝˝Á·Ä#‘B∞¬«FÄÕ UBÒXie?
ıΩ¡o¶}IXl)-OáÉÆ4Á¢õpfπïˆD“FπÛ8È€KïñŒÆ≠Jıa2i⁄VX˛T˙Æµ4ÕDdôdÀ«Vj‚(6¢ü»®ó®®ôB˜]üQ]Ì§AXH5á∆û [˚≈ƒ∂ÛO˙÷˜&£üB√T3k8ê⁄NÍ≠+q#¢DË8j[£t‹òö∏K˚MdèTæÃãºW^'“  €Ñ›˙dáÜ[Éw{H®˝èõª¥”°È…Ø m§ÚÃs‡∆+a≈ ;Ñ£È˜@(?^—Y˜Jˆx¬˜”\a{Ú(ÑÍ$ì_Âˇ◊á{ä‹L |äXâufˇﬁfs'È'Ê8.çÒygX u+πÆ‚eÆó/;Á⁄˛â’√Èﬂ »0ÇÁ—:^Áeorˇ[nŒ¯}áy?ƒ"kôıï≥ógˇPK
     A ¢∆˜E´  ∂  3   org/gradle/cli/CommandLineParser$OptionString.classïTˇNA˛ˆzÂ qîZDQã¥GÀQƒü kLå&(ˇ[ÆórxΩkÓ£è‚¯/$â&>ÄÔ§qv[lìBìŒÓÃŒ|ÛÕÃÓ˝˙Û˝'Ä9<ÈE?Lùƒ¥é4äB-•0£„,≥:4Ö(1ó¬m·;Ø·ÆÜ{	÷≤À€¸#∑<Ó◊¨µ8t˝⁄CO–à›¿ßÕ¢ÎªÒ√Tæ›Ø›RXgP+A’aXv}geßæÈÑo¯¶ÁàLÅÕΩu∫Bo’xÀçåUô∞	CÍﬂw¬ä«£»°Sk9kV-‰Uœ±lœµ*AΩŒ˝™HÒöáëÊN∆SÈö?s£Ü«?Ø:Âπò/t*¥-ÊˆáWº!Èh∏œêäÉÊ±Ü/œTww~eŸÂ”¨e!ÊrgâcË„∂ÌDQÆ<?K·ï¸9ª—±p}-ÿ	mÁπ+Ü0‹Ü0#B\@∆@ÉB<40Ä1/ï,`ëa‰‹ß;ÆWuBè∞d‡:∆9_¡òÜ«•sÒf»¸√_›‹vÏ¯îÈ»k¢{ÈÆÁE˚ı(ÊaΩs„-Ü°ì-ºß+œ«Ø›Nm¶VÕ‘“ÒnD0Nœ/MOW°vR/ió-¶5)mÉ†ãJ⁄i	ZÃC$ÃÈ}®fqlOÜ…0`ÙzòÇ^ñ@ö©&˚x3#∏»ùH√‰N$RhO”h•â§,öﬂ†fìË˘Ç±–6ëj/Ÿ-–øbÙË†Ô‘¡.≈'$ßÅ≈4…√h‚∂x\•øeÚ≠F&&ÓEãÄE´pLö0vè´k"'êíM§å®¸F+xïÚ™Ÿú.BŸ;éﬂ2‹l∫7D√D´!n Üà]ìHdR∏Ö©6fTÈnGË#fZA^ FÂ|ı\ÇN3°_&ıPK
     A gAq≤î  x  =   org/gradle/cli/CommandLineParser$OptionStringComparator.classùTœOA˛fv€Öe°*Z@¨–Rd) ÑîHí&ULjHÙ6îMY\v…Óñ¯Ø¿…õó^º@¢â—´ì1æŸÆ(≠Ò–y?Êõ˜æ˜ufø|{ˇ¿"VtÙcFá.y≥:TÃ…ÂëÜyπM÷‘∞†°ƒê\∑];‹`PÚÖ]µ‚Ì[C5€µû∂éˆ,ˇπÿs(3\Û¬Ÿæ-„8©Üv¿êŸ9mœ≠áæÌ6+ﬁ—±EË˘F’u-ø‚à ∞∑VÛ¸¶ŸÙ≈æcô«6	{$‹}ŸÏôÀœ]_©Ã†5¢àöŒ‰ká‚DòépõfYÓŒ™t∆ã™ï$˚.¿Âˆ"âx~H8ˆÚG@ŸT=çWOƒq<Ìï∆;{áV#,wg
Uã∏Á∞•≤îúø^`»˝ö°øn7]∂§Îb”
m«¸)ﬁz˜ÏTJØ{-øam€r¥LWªyy»ÄÅîÅ%,kxÃ∞ŸìcEV’,7∞C˚ƒÍæ=≤„§ÅQd“øÛfX˝œt•XG,ÜëÎ‘bòÍ˝O–%q,∑DœÜn⁄dØ3X†wßÉaÄ^©
.Ö•hê"ì,#õòΩ G«≠Iô‰
“‰ n`Ñ,ìÚƒá?C°<∞U<á¢æÅ¶æÖ™lÃ˝≠®ŸSË£Íºù=ìÓ)j˚‘Ïâ"°ìm*¢Dç«È≥û¿ O"À5LÛ>‰πé¿OEÑñ;McB“ªÖ€…-‹!èπ%å·.’Ã"á{‰©‰ÅN'çMˆÎ¨zzã∆è«Y%ºB65[¸mé~ÁËkˇEìTáBZ∆ìqë5≤<î]/h¶∏‰ü¿}L—æÇ>ááëù∆M≤cîÔG√‰MHx∫è¶)†à±ÔPK
     A `M~U  ∏  2   org/gradle/cli/CommandLineParser$ParserState.classïSﬂo“P˛N)sÄ€‘97’Ωå&ML»fÇŸ√ﬁ.–∞.Â÷‹vFˇ'_|—ƒˇ ˇ(„π-õ› Aö¥ÁGøÛùÔú€˛˛ÛÛÄ¥mdQ≥ëC-è«6Íxba«BÉê{·I/zI»4ö«≥å\¬jœìÓ·˘d‡™b‡s¶“Ü¬? ”Ò4iFß^H(º*tU?'ãÔ§tU◊aËÚÀv/Pcg¨ƒ»wù°Ô9›`2r§;$uıTyáPöà/ó#}åº@÷Ω3ÒI8æêcß)Oé;ÕBﬁ/ °∆ZÂé∞»õÖ&°ú¯WtüÃi2ßÌ‚qf∏YC!êáÅº˚zﬁ<KÔ)ê)»9≤∞Kÿi,Êy÷—Gm|~J®ˇö`˜És5tﬂz˙‘7f0m=MÚ´Ò*lÓ∑[ZEÏ°laü∞∑Ãl<⁄øÌŒ‹aD8X~ÌÑ⁄‚·Æ4KéÇgòàhx™øﬁÍ"≥ øV˙≤`ËÄpÉ#á-±ÕÓ˛ÄÒç6?s:I%ÿ/& ∂´Ä…JPéâ*líWö∫U…|á˘ıÕZL≥ë@öÿªÖ5Æ„NL|õú'‹ªT◊äcæØ+€J)£Ñ≤§)ÔOü≥5¶cÕóRz≤óz≤xÄáqY5∆?¬M∂õ»õm¨ò6Wl„6€-/ÂˇPK
     A pÕX›  k  ?   org/gradle/cli/CommandLineParser$UnknownOptionParserState.classΩUÀRQ=wíI¬0@ÒÖà(IÑó±ê““*
≠BY∞ª$Sqt2CM& /¯/.§äGï?¿ï_7n‹Ë/XvO¶BÑP!.‹tﬂ€∑œÈæßo&Ôø}`
∑5ƒê’–Ü±6Zç≥…±ô‡ÉIçR¶£∏≈5µÏIœà‚Ü@˚#Èñwï˙€6‹%KñÀFY`|Ÿqãπ¢+ñëÀ[fn…)ï§]X6m£äÆÉœ	Ñ§[H,?ì/dŒív1∑Íπ¶]§£ˆ¸V`Ë0≥œS®„'Hdﬁ¥MoA¿HelN–ZÛÈ5ÅíS†Ê∫8e•R⁄0‹«r√2¯FN^Zk“5y√ﬁSìDÍb?∑ùóˆ√MœtÏø‰<A«ÅÈ˙ùE√ª/Àãn±R2lè‘M•◊)Ïÿî·z+∆ñ∑»rO§“≠ŒIsÏ⁄;‘mô1&k|DNŸõñ¡OlV‡’ò^ÛÏI¬ ÷õI6Sl¶ÜO¶k≠:7o‹3yˆ…#9„|G=ËesSG‚:∫ë–°°S«¢ò”1è[Q–õû˝Áß!0’€ ‘› ñmEd˙’6J`$u“a6{≤P∏ªÂπrMZ⁄˜5z´®éîƒ }€ËKBÇB´è»˜4%Ú(<>P⁄ïh&ﬂó˚P2£ªe≤ªg∆v°n”ÅÇ$Ÿ$T@|Ñ*>Aü—%æ†W|≈):ÀT	–è3Äø‚Ç¬_qI≈_q3!äû≈π†tñ<g)·◊µ:éào>Ø^=xŒc @Ê§öŸC‰Õ!˜:∞Z_ e™‡YÚ q‡>8YM®›H≈EˇFÇüw@≥@9\"ûŸ!µv⁄Cîúz¿®1ã¯âvÒ´Æ•xïï&“É·Äkù$}Àåf«ˆ!∂uı¡«œTsj]≈p9–9Ü+ÅŒ1å¯:Û*Ö4Ò*4fE˘!ä¥ìÊøÀú¶./1YúüÕÆáµ?PK
     A £=  l)  &   org/gradle/cli/CommandLineParser.classùYi`\≈ë˛Jöô7zz∂eŸ≤=`l·Îñ1∂∞ÂS> K6ñ±ëÃXzíFœàô∂8B∏¬éé`Å`áÇπdÅŸM∏¬»ÓÿÕ≤aŸÉ=Ä!l ««~˝ﬁõ—ÃËâ¸PwOwUuUu’◊’OØ{ˆÄYÚT:Ò±j˛W5ø◊±üh¯É/>—Ò)˛®s˙3ˇß·O˘¯>◊°„y¯R√a#ÒÁ|¡—|Ï«1’◊ÑWã¯%G«…’ƒ£cºx˝‚Sø5’¯Eûé]¢˚%_Õ™°fF˙euëøå÷§P«t|¬ùeå&cuî‡ø±óq™Ø8&®&†ú§‰û¨öâJOãÔî|</ìÿ‡®&ìu‘H±&ßÍò+S4ô™…4Ûe∫éZ9MQŒ–§D«bzAJu‘©ï)”§\«r%mô‰ó
zE*’Jï_™’.3Us∫.≥‰5ö≠…ú|¨ñøú©…\5úß∂¨ıÀ|•˜ø,Tøi≤XG3ÀÂHÍx ¨fØ…Rø,Sv-◊±UV®—Y~9[yÁ]Íe•.Á *ø4Pûá4Í≤Z÷¯Â<µ∏Vì&ÅQâò±e·`<n∆„Vw%B—HS"ä¥/ãÓË
∆ÇâhLìuÇ…ÀÇq≥>7#ÒP"tâôM$(∞π”˘ŒL8?≤=›±◊cq3÷î&LM÷s«sO∞∂A0⁄e˙AQC(Á÷ˆj]¨›Z¢-um	3fœ∆5iåµfŒ
≈‚â¶Óm‘kG0“JKÕ∂hÃÃö◊dc u;É13cﬂMÇ¸åâÕ‹0›[Ç1´◊¨´_›∏µ±Æa≈÷5uÎ÷≠X€(¨Í^¨ÓNÑ¬’1≥›‹UΩ&ò†Vë˘ÇQQ[Ÿ•=I£“®Ç]§…k
µGÇâÓ-\ëπ∫¿˛F⁄´mÛWEcÌ’Ì±`kÿ¨n	á™€VÖ"¶≠Ï¸Eî9:Gw6Ñvô≠éª ˙1÷|∆yqeÃ41Î◊ÚP<∏-l“âæ°H(±Hê[R sÙ,ã∂öJÓ‘ÿΩcõ[ßÖ´¢-¡˙`,§~;ìûDGàíß|Ö∫∂≥©¨∑Kçgñlloi∂ã≠5M%‰∑¸§9.bàI+vµò…–Ÿ"ò[íFUœÛRäo;√RÿÒ¨`ˆêFNÁî‚3#≠åmL=É öå4ÂPı%$–l¢”…uˆŒ*	c›Late+Ôr"nÍ£ìuUCõóiÿ∏ÃÄËÈJÖõ«]B\
kŸŒ∞X5πP∞jÿÏ√:ƒ…)Bàp(^Hòi%ÉπÖØn	ZÕ¸knªâ›íù…_ù>N∂ß¢Ç
œú&3AÜ32gR4Ï—d´äZî8?lÁy“O§Æ´ãm'·¬àf@Áÿh¨’å%s∆ûU u≈Ã6Îí3i ≠
≈ïæπ€Õ¢ƒ%¡p77ıöëDL˝^a˜Eôê9ÕöV\—ÓÑäEWôpº vX8ù)‚¨‰4iFf(MÂºa˙Ñ}Óé‡.¡‘l?∫FÚ¥,ÉN@6ﬂÕ7¸wÂû3ÙΩ·¬ß…Eö5ŸFºÓåÜpJ“-ãÜ√fã n1ÌR^¢æ:Ìt[Ω≠ìBﬁYãÒ‘ôdÔ¡3âõ©R√∑≠ª≠MŒÑA-µV‘vmÍÇœºÅ.(SûYÏnëZ¶Q_;•Sô©[ZÃx|⁄úô3”KÜFÅR^—9ªfpŒUúgásPYë1Oâ/ õ}õÎM—ÓXk#Ö»„I™Rr‹ä[‹Ä‹¨Fﬂ¡ÌD®Å-Œ	∆;∏ç&-Ü¥äi‡{∏OP<Ïí¡¥1§M⁄πÉt®Ü∑\Õê◊çkuß∏;5ŸnHXvë®!]r1%˚â	√0ß≤“êÑt*á‹1ΩT]Bÿ≠¨‹t·¬-ÂÜÏî∏!ª§«êKÂ2C.ó+%ã„•≈¬™2Cæ!W*¢orï\Mx¥÷’≤Z≈m∏ÖUå3Wπ•™åqü\…ÍlE,çrçRz¸‡¥Ö[U∆Ì∫VÆ3‰[rΩ!7(G‹(Wrì|€êõÂjCn¡ÌÜ‹*∑Ú%*˚‹≈≤!∑ÀwYXπ¿§äç2Œu]Ã4yÆÇ”áY<'îkÔPÕùÜ‹%w'çt∞3≤›luèY9L·ŸèCæ'˜dòRã{23$*äºÉ0d∑\/Ä!{‰^Cæ/˜hrüÅ7ÂÜ‹ü≈ûkCP·Êôü…à:˘°\l»ÉÚ˜ôn—èEÒ‚b≈`»√*≈∆πcù&{˝>Vi%±¨=f	ŸΩÉwb™ºeicõ^<cz|Fq(^«Ã`kOq+Ô⁄àŸZ•¥¯±rÛ#Ü¸D•BÌ≤`$M[[ã£iºAÚFí3-6M<å%äwÜ≈3*gT¯Æ◊‰ßÜ<*èiÚ3ïQ¡¶aJ,éF¬=≈-—H"äP—Æé`ÑÊƒB-≈-<±ÜXúÒ©ˆ≤∫≠3™æ2`Ì√◊‰qCˆ+E&ñl^|˘ÊÆÀÍ¬î{≈¶‘®rÎñ≤RCûê'È‘!câ%˜í!âÜ|>œRƒâ^“√âw˜w∂`÷◊ùÑOFü3<,Ùdn>g?‹_Áy2∞œ|Ùóüòﬁ%ı
Ä¡z¢XÁ>"£Nd1ÏVìfêY72≥pLb  h1s}¡∏Ω6=£JqäÆ“¡≈¥œ*£…9°§ÙDuX‡U†™Î«ª?õπ≤}e –≥°õß[ª÷ÇeN(ÂÛqÊ%œB=ó:ÇÒFsW¬˙Æ¡zÀ±~å-)u+Zv{∂©óp,ë|îï∏îÉ’{˛‚Ó`8ûEê<	‘r–_næ∆€∑•Cùc^º{[‹â’¢íz◊vÑ
Á46∫òó<[]økåt6SN∂æoÃ∆;:ÎÇä¥öª‘É⁄CìÍ’q÷ªõ¶[‡c•°`©€—|›ΩÛù€(~Æzv˙ÇVÜ7\eü†£"öz¸ñ∏™>≤›L∞ûP_∑k°∞©p 6#Ìâ+LÈÄ¸h§1I`ÅEô4cÖ“/∑]AÀin±Áÿπºô<Ì±hw◊Üê⁄ß0=Î’óg3ÜNj'"≥@#yÎYk>nV≤0=têzièŒH_˚ªÖÚ◊r3ﬁ%?~u©'˛\ìáÈﬂv≥«B‰ëãAÂØä7∫›o}m∞h¸‹~Ω˝¬«°ˆWÑÅás˙	»È_&∫%Ó@,y€¬›Òé‰≈ëÂ<ﬁÄ√MÁŸ<ÔkÈö≥Æ‡«÷≠≤0nGRZ’ûÒA<[1ÎQ; hKΩ&¬ßi13|d≥7ÿLÛ]$7$ÂçJì¶˛ŸA»h5„°òŸöz=©ÔÊÇ÷¬Ë¥ûø_ë”.üÛq*:±Ä'©™ó£ıFÜ‡&k¸m˛ÒπlçoU}¡ı≤„Ô§·öÌw˘kr9‚rŸx ˙·m> ﬂ3»y¬‚ºÉ≠ŒòÊ‚Néõw·nˆWÒπ})î¨ÖÏm^Y˘AhΩÔO	ÒYL+,„l"GÄÌ∆ÆﬂÀ±á˝˜˘«7<£–‹7hb>≈x˙ë◊‹ΩπÏi‰Ù!_p ∆åhË«»Ê≤
9ÄQçÂ}(‡¬Ùa¥`∑ºÆFÖÇø¬òZoe¿€ã±ªÂ±Ä∑∞®„v£†„õÎÑ∆}rßΩ8i7N"e¿K‚ì{1±÷ı‚\NÇIAU¿[∞∞ìk|6e)ä≠–¸Âπ»‚=ïLgìiä≈t™EÎÒ:§˙Rtìüƒ‘=("ı4RÔA~?¶Û(N{Å,$™ı)≥æ>Ã»°ª∆)Y>gGK;ºÂ»Æ’,JÕ°º™≤%TZX÷ãrE\ﬁã
’O¨ı¸Ω®‹ç¬Ä?i.U¡Mj∫™—[ìWîß\V˝ Ê“*˛Rv◊Íô"uG§ûY’xmûÏ;˛‚>,¶.íÆÆ≥æ”á“KÈ÷ëÕl‹wlfe/NØÿoEàäß'Q¡ˆ<L`LEÍ∞+q>€ıb∂„Ù†Wb#”`cm3∆<çÒ◊ÿä_„"ºK ˜∞ü£«—*#` x¥…)hóbtH):ÂLló&ÑevH'¢“Ö.πÀMà…^ƒÂQ˛~;Â9Ù»À∏Tﬁƒ7‰C\)¿5ÚÆì?„z9Üsròñ*ˆ≈hÍÂ√p?€ª0‡á=åQ÷úFÕ{ï∫ÿtwõÇÒtâc1~Dé<jµÕZısﬂ<gTäW)È!r|Ë˙iŸßÿÀ9Í‰YÏ„»´≤)ô}Ì∆èôq‰#<Çü07ß ˚¯)5Õ≈c…t∑®~∆—„úYÄÇc(◊êß·j˚è`éÜ1≈≥gå?Çéé¢û≠Ü]G®—a,:Ãh¸ßÊÜè√¥,∑ÅÍ	éüƒSÕ·åB
≠ÃÛrÀˆg°–≠T˛∂4“3Ñ+Æ"dêà;(‚NW16û±Eàó∂kú€¨Ê f5î7V™Ò‰÷xãºEûô EﬁYµæädNûëÉ>ÃŒ¡ÜkΩå˚ﬂUÙaé†±“!åØt0®F!SE/Œ‹w¸É≤ÅXû¬S˝·'ÊM‚©Õd_√∏8èÁºÅÁæëg¶ÙùMÕ'°–9ÕÛ¯◊KÙ(=SX∫-,ı3˙,-Nû°=”œuÜS·9ŒPÙiË‘úÜÁŸ
›Ò¶Q≥˚c"ô·€%πœp;¬∞¸™sõÀ`q∑ñx<øôπ‡ 6V¶ÄπãËã~,¶Ôñ‘z*-w‘¸áºÆFéG|∂ò:%f)≈XJ®Xñ≤úBV4[J^ œë≤^çl◊˙T{¿îÄﬂú˙pÖÌ√‰ÅÂ¢¡À«˜¸Ögƒ9‹Ö*‘+±/#ﬂíΩZ·JNxyΩÁÊ*˙ôåu√¨R6+Ì|*,Ì&©ë£ùV‰U¿V}5^∆ábiÃ“ïbY≠º–á5ªµ˘…ÖÁyû«⁄Ê\µ–$hÍ≈:4Ø"iœ˘4•àhπæpÉmî7ÉºŸ„H¥èﬂÃ8º‡âT^ »RËî«x	0”K%≥∞kòüAÊgÑÈµìr7s‰~∆›!∆Ÿo_ˇåÁû««ú9Ã`9Üüãé_K_îº$≥Ò≤,¡+≤ØJ;~);Òö‹Ü◊Â%º!Ø‚Myùxwßïÿ#){9Ì% q«Gà“œ2wRªü„åﬁ0/r5è{ùÇó,∫5§ŸÀq√BHçª\àóâÉö
÷d^pÙKº∆PŒìÒ7xùYêßÒ+ÚÁbñ‹ã7X:y®ÒÛxìYÁµ≤FÂõ≠…ØSö¸-1Õﬁ·Ô8gÀËO…¯{zSe◊yµNvΩ•aÆï`øaZÅxº˙‡5÷¯mãËC„d"ÊQL¥tLÓq:…õ≈
eÕc%,3wÑÖ«‰]}s⁄ÍÍ≤Sû}∆ﬁ«~e?ö2<ã _ÅØpÂ™≤>lJØõ0›©õjΩßÏA^√iÛÜ
uoQ£‹E˚éø√¯πp √™8–~?ﬁ‚ûoS—w/øÂ-˝Oƒ≥wâgø√ﬁ∂KÒ/¥ˇ˝ûU∞¸G“yï^§}◊B±ïå´á,ÃZJæ˜,;ñêÛñÙ;…¢üΩÚ¯xéb¥Üf9Õrù∂ˆKÍaﬂ2ˇJ|ﬂãs=ƒ≥Sû8TﬁPqhQnçß»s ÉÿYQ‰ôUÎµ@›ÎîOÅ~lm.º»I=o”A`ã2/-…ı÷Ïı'a*oµı¢}èC”ëMs≠áw≈ç˝®iV’ÚÑ*,ÿKø:&U¶@ƒcÈÂ©Hbœ{V5îkyøÜE=!∆‚#ﬁ&≥Pˇ==˜	k†O—Ü?‚rÆ]ç?1À>géA‰˘íy{8u
c—a›*^Æé∞ÚH›*áR∑ !ÁVπïg©Ú-yáh«‡∑.é#®fÄN>å©_¿{EV43$ß¯ÒÔ¯ÁfÆfØNπ8˜—¨∑¡ú¥;ŸÀlÁŒd˛O¸ósNˆ√¬ù˘ø]wñaÏÃ»˚ü‘iâµ
;{±ùÅg<πOaja¯ v<s[©ÄGÚ∏%.«X"ú¸–"˘QkGOa©X«g\üp≥è±üœ>Œ>¡æõ‚.aøì˝.ˆ=ùºù∏åø«≥øú˝ÏøA…#Ÿ_…˛õÏØÚ‰¥;qÈØeÈV)^ÒÂ˝?PK
     A ãÂ>…     &   org/gradle/cli/ParsedCommandLine.classïWiwg~F€»ÚƒãÍ%vìTMc[ñÂí ÒR∑éõê8∂S‚∆∆)-L¨â¨T÷(£ë∑î.PhŸ°liŸ7	êí`rXæ¡·;ﬂ¯∆ü†úúòÁ}g$K÷∏1GÁÃ‹˜Œ}ü˜ﬁÁ.3˙«Ω?˛¿¸.Çvò*Ú¯`÷!âã*¨ÇŒ¢ .∂äbuéfπ∏Tèì∏,.+*ûWÒBM0#hƒ'ÎÒ".©¯T=^¬Àaº¢‚’∑}:Ç|F≈kt¬„≥‚˛π0^˜7Ñ≈Á≈Œ/‘„ã∏$ñ_ _VÒï0æAæVèØ„MaÛq˘¶∏º©‚[
Õºù1sÖ#+3∂ï…•©ôº†/ÎE;ìò“Û√
Íf2Èún-C¡…Íß#Œ2´Á“¿§i•“ñû ŸÃ¿ì∫U0R„Ê“íûKMfr∆)y‚(ëÚñQ0r∂£*T>cÿ4y§Z„q†≤å%sŸHïÅåÀ∂•èYÈ‚Ò©h™¿ôÃÙæM™-∞C#ô\∆U–Ø08añ~.k˜Œ*åõ)Cxœ¶ãKÁÎ)ÒLAt“\–≥≥∫ïkWYÁpŒ#ÑAÕô
¥º‰Ã	FA|ªî“W”›≥wÛ/ÎÄΩò)xÿ÷‡”V5K‘∂x±††≠:‘ï|)‹√ˆ#˜wOPøc∆÷ûcùI(ﬂVÒ√^yÿ¢»Uÿ6K•ﬁÔı§ˇb—¥ç±\j¬Ã˙Ω”Óµ3TpëUG(àåÌ|—V–Q≥·H1ìMñ 7S8ñ±
¥RŒä|{ÖÁYõ#€∂ıÙ∑nQ/î™¨5^k—Koöu∑O;=FÇ∏m,∑R⁄ŸØh§q3õ5$ﬂbwc÷LOÀF∂‹ômﬁ∆
û∂ºﬂ˚LÔ–œn"™›ˆ˚™9mÿG7Mîh©z*gJwçrã vË©îDú’≥Ec˙YÆ¡eÁyÌKÑ?Îa{ˇÚˇ?¬’úqZ:Ø´fy†”◊»åY¥åc—ˆm5˚Ö”„
	› È∏^XdãkË«˛ö˘ﬁè·ÄÇ6ûéYñæ"÷|P√[x[√wÒ=ﬂ«ƒÓÁ1sµ=>4¸?RÒc∂¬f÷U¸D√OÒ3›Ò8Î*$c’/GW˝Ü∫*¿SÁ.∞Ñ5ú¬ì~éUæn∂ò
|…òÜ_‡ó=¶0≠aÁ4¸
WU\”0è≥~çﬂp¥WLˆHZœñº:zy¡pyÿÈ¯ÎÈ*Ùƒr¶KÁ}jø»c¸≠ÜÎ∏™·û—Æ÷í[√ª£v.ïî2}Riõå∆óc9SV¥UıP…PåIŒùir+˜∞©9π®„ë¥é∞gÀSßπ
”˘¥ÿQ•®Z≥yàú€á„µ‡µOBÁMkI'∆†G√>˝ﬁ Ô=ü7r©çëW=¬∂~©ÑÃú≠gDÙ≠1[ºf(O:∫Ω6yÖŸP=∏ü≥J8ûJçe≥ú“«√¸2mÁás Q—ÎP0¿ïÔ„ö-^^‰˙–¶5[ºº˛Íy?åA CÄ2?TjﬁH‹Üí∏ﬂ¸m¯o"@1H1tÍÜ¶XG1rı}k–L%◊∞C¡ú§–†‡ØhúæÉ&⁄4˙o!∫Ü;ÇÆ]LH“∞e(î¯=°é¿Z˝ò[]ˇ◊Í˙;7dê√Ú?Ç∆k'W≠¸æo£‘ŒœÒù˘A˛ÿÖÏÜç=x·5ƒ:I·éC¸a£èb!Z¿cxú(D√Ãp1é' )≈1“Ûa ÔéÊ8•î˜!∞NŒ¸*í*&T˛Ô¿=t´hT—ƒ’–˝_ÈP;…=ú'ºíXú·Ÿ≠/⁄˙⁄Á˝	F´ﬁ∆Œô˘ÄÎ•bXà@«u	#Bw∂v…pß˙\á}b»9π√ªºáx?}ùd¸¡©¿®ìï°Ä‡TÚ}HH.ﬂ¡›o!íåÓ∫Ö›s…ËyÎV¨¸£´ÎOﬁ¬C◊ÀIÿ/Î•a$°q÷aíxêA1c¨æ„§xÇö)R_J@{Ò& (¸+ì}ö?Avòˆ3xä˛G∏˚fôîç´97≠ﬂCTEßB∫Ô"¶¢Â]t∏åîFú◊.„'®ÒÒﬁúËªÖÿú†õt<Ï√µ2Øi  ‚1Èiõ≥°Ï_3„%úÇßﬂ6Ï;Aÿì˜Å˝ûqì˜6ÔA-¡ˆV4Rg©ëZ¶l†GÆ ∏∂∫˛oˇµrN⁄$´gÿ≥dyéE:è˙+ééë…N:$ÙÀÃïúË≈≥¯xU°Õ'\û5¯ÔB%«ª6
ZÁ3æ]^·úêà¢kÈÙ>ùlöJ˛;Ô†k>⁄êeﬁ'*˘6z˛íE‰óGe§)ˆ§A˘<ù],;[Ì¢√S;\Ù¨O∫Ür=l8>Y ä√ﬂÄ‰ä^⁄‹9ŸäŒ	∫NLØÁëvcz¬Õ≠&@S‹áπõ“ög\¨H´VvWc£Úå.∏à97≠{™Xö≈òî„∞óGÙo¯€ )„™»ë∂,œI8Âsˆ»Q¶HI0≠õ$AbÔså÷9˚ä{ˆ`_iñ´*^QUt•	’¢öπËÛâÒ˚œÂå9%ˆ<'ÏtÁEæB^‚K„Âr÷vs?Íñÿ`Ÿ—AÈ^EAEXP	QP
ñd»πˇPK
     A yﬂt⁄  E  ,   org/gradle/cli/ParsedCommandLineOption.classçS]O‘@=›ØÓGÅe˘PaÑeQ™®¯"àhHV1YÉ¡∑awRªÌ¶Ì·ßl‚ãò®I‘gîÒN[`Y$Ò°”ô€{œ=Á‹ÈÔ?ﬂ ò¬ì4≤(™òH#Çb
∏û¶ÂÜä…$Ù4∏ô¡-L%q[æÔ®∏+ﬂ”rπß‚æä
[ÃlpWA∂¥…∂òﬁÑ©óÑÎÕ(HïÖa1Ø·p#-ügÉ≥…,C/{é∞åô9*IÃ
Kxs
¢ÖÒU±EªJ≈%aÒóç⁄:w^≥uì"πí]aÊ*sÑ<á¡ò∑!àI°d;Ün8¨jrΩb
˝s\^]¥k5fU%‘J›∂EÌí˜V• ›ÖÒ≥î¥ï=Vy˜Ç’√©£
jî;*i=z&xé‘´V£Q„ñß†ßp6K:êd«)πÒKn07T@ñΩUê.€ß¬ü	…v‡ÈìICztù∞]p∂-)kËDN√(∆ùt]6Mn0ì,Ò¯“˚
˜±(# ÕWmÓÊ-€Ào∞-ûg÷vﬁøì≤—∞äáf0´†?L'Ê˘Z√ÙD›‰A¶K©è@”œ∂*’Û$°—ˇÔ)îïıM^!€OèÜÓå+vÔñi•· Q,7_Ö†î¨é“¿Z~ìæ´¬]™’Ωm\°(K?L∫HÔ.:E–ç8Ì…rZ/PdQ⁄Ÿ‚>î‚!"k˚à~EÏ≥ü}ëV˘_Ç*bT”G;-»«%Ù˚¯∏bÌÑX”≈oàÔ¢Ìâµú∫è‰œ‚ƒê"°¬p˙(=@&Ç_–ˆ®2ÍwÏ%é†^*ıË$¸AÍP¿PS˜È∞˚ =1D:•ö!‰â©‰°”If≈%˛ﬁ±êÑnÇâá0Å5W(vïæbûRD
◊$»ƒ⁄"x”j 2D¨œßÏÁÜxr7Çk>∫Ω!‚ÛêV.p£]¡.‘ÿG≤‡”±ÙÄ„D«\ì‘8"Ÿy	RâåˇPK
     A \v∆B|    :   org/gradle/cli/ProjectPropertiesCommandLineConverter.classùíKO¬@ÖœD|?P√¢Ï¿öu„#Qå+¢$˜C;ñ1má	ˇJW&.¸˛(„™1ÿD„,ÓÈú9ﬂÙv¶oÔ/Ø ˆ±[@ylÊ±ïG)áÌvŸ
}FHWkwÑLS∫ú∞‹!ø]ÆnY◊7ŒZK:ÃøcJDÛÿÃËûéZRy∂ßòÎs€ÒÖ›VÚÅ;⁄Hü+-¯†)ÉÄÖn¥kSÜ#cruLXı¯gh|”◊BÜÑçj≠ı¿FÃˆYËŸ≠DËôËŒèË%◊L¯‹%î÷éÒéÖé*á_â®ÂΩ?ı÷à:("á<Å⁄ÑbJ’çˆ	Æ≠ÿätÚfÎ^*K˜∏’
ﬂµ¶XUﬁVΩå£‹i01»k¬¡çp8ÉùwZ±ﬂ8T0gÓ?PÙa¶ŒõômîåŒÌ=ÉûÃC
S≥s¶ß£ã|	À1\è·ÙZÍq-}C”_ËJöûEÀâËjöôE+	®˘w'©ıPK
     A 
œ8=|  ¸  9   org/gradle/cli/SystemPropertiesCommandLineConverter.classùíÀJ√@Üœÿ´mµ∂÷j’E‹5BPƒÖêR/PÈ~ö”ë$&”BﬁJWÇ¿á'i©AƒYú3ÛœˇÕúπººæ¿ló ç"l°YÑÕl†E  <&œ	d⁄˙ê@∂À«H†⁄gﬁL›ä{:rîRÔsã:C*X4Nƒ¨ú∞Ä¿Qü€¥;hZ3a —Ω‹G!]Ó∫‘Gãvπ7S"ä5eb
o}…∏G†—÷˚ètFMáz∂9êÇy∂≤∂~X{()spL`7e.∞KV,¯TXx…¢äıøîfDT† E§G†ƒP«WÅ„JmÆh~≤≠∆49AÌjx≠µ—∞≠”s√hˆÃg‘ô¢n8¸«5©€]†.FÅ‘íøs∞9ı‡QÀâŒ¢‚≤ô*ïs˚/@ûUg	J*Êc±e+sÉ +1æ
’Ó$p¶æÙ¥Ä6ø°ô/t-Õ,¢;©h-Õ.¢Z
™>kÏZˇPK
     A               org/gradle/util/ PK
     A               org/gradle/util/internal/ PK
     A ˛° ˙  '  &   org/gradle/util/internal/ZipSlip.classÖT[S”@˛ñJ∏Tƒ® µÒ
*®(‚µÇ3ı2†/KY bö‘d+‚õ?˛Ä/>®»Ë®Ô˛(«≥°B’Œòá=ªÁˆ}Á“˛¯˘˘Ä3òÕ†√Ï¡à◊ƒq'28âl)x˙v ƒi-œò8k‚úæû71™C∆L\»‡".5c⁄rŸƒWö&d ’Ü‘»cÜÙT∏(⁄s23ï“ÇàÚü4v.,pˇ1è§~Wïiµ,cÜ#π0*z≈à/˙¬´(È{2P"
∏ÔÕÀrﬁóÂqÜéò/	zN*Zõ·%
?6ú[·/πÁÛ†ËÂU$É‚¯»ø*¬	ªû≠5Øx·˘}^ÆrÍñÒ£‡_¨=ı∞Êöe¸Dã·jú¥Ä4ô|Xâ
‚¶‘Ÿ¨jYla/ˆY8Ç£TÛn∂;æ/ä‹ø+%®ÈWQV2»ih0rdÏ°r∏£Y9ØeŸöó£ã Rcv3Õ.¨àÇ20i·Æk∏)70»¿<”ó=ch»f-‹ƒ-z]≤0†ÌFgu>∑-‹AøÅªÓ!g·>f»º˙ªFÁ£˙É–v£hKñ¬®ƒ√≈:m|ö˚ªÇ˙S¨;⁄9C∆”•≤Z£÷«äGä¢ñÃB(."›[9µÃ£ºxQAA$#¨Âª+Qbh)
ı 
À"“i∑íjì-¶π6< ÔÏSçÅX∂®0Æähä«5+ZÎSß8¶_Y#Ùó”kBgΩ<íåd£˚	Ï]∞üŒ¶DŸÉtZ€ËE…fD5xFbÎw∑–∞éû/HÕŸÈÙW4Œ•‹¸ö>¡¯Óæ'èTíµç$hRÆ°öÏ˝8á‰·ƒóımqÊë“NcÓ&ÃútÌÊMd60‡⁄-…•◊µ≠M¥n¿vÌ6∫¨£uÌÎ0“oëNΩ€¡?@u«ë¡	t—üL≤ƒƒ√(Èvπå’piBÍtjíØ∑∏JgÑËËØ”ÓÿBÁGÿõË≤ª	V±öˆù•ÛX““°_PK
     A ï%”¶π    /   org/gradle/wrapper/BootstrapMainStarter$1.classçRÀn”@=”∏u1¶ÑÙEyî@_Iik¡6àUë@.,RuÅÿLÏ!ô G„	¸6 ±‡¯(ƒ±	]t1ssŒ’π˜Œœ_ﬂ xäΩ Û∏≥àªÓ·æèM|4ûi£›sÅZ´}.‡Á©∏k£ﬁåá=eœd/c¶ÁâÃŒ•’e<Mzn†Åï1 g≤(√«qn˚Qﬂ 4S—'+G#e£yÓ
«‡Tj”u“:e∑üt(@&â9Å≠V|!? HÁ—Kù©Œ$ §ÈG]gµÈw⁄Ô(3’V`È_(ï9¨T˛G∫˘ÿ&™D
l\&‰®d±ÎìdyA÷©rÉ<ıÒ0ƒ#lÖ±(∞>iÈ0ìcìî=<⁄O¶ı±bªÌ+7.Pˇ£ÙmÔB%ú¿⁄ﬂMï—-∞w≈∫l·É6i<¯Z2≥93÷ˆÏËÍ≥#á“± wπ⁄∫lh¬„‚Ú¯πÊx8F◊ËE¥Çv~ˇƒóÍ9‡ΩP%pùw8–.—R3ÍSÚ	—µ≤‹AcÓ+jügËQEoN SzÈ›B£z˜±åï™ƒj≈\√:≠á€ÿ¿zQ^≈¡oPK
     A i,´  $
  -   org/gradle/wrapper/BootstrapMainStarter.classçV€SWˇsŸ∞,à1*âÇ±BI /µV∞Vç(–-m¥⁄.…!¨nvÈf£–jÔ≠Ω<˜Å∑˛	ˆ%ÿ2µ”óv¶ì„Ù;ªIIbº¿ÃŸ≥ﬂı˜]7ˇ>˝˝1Ä£¯IF 2^√	Còî0%cÔ Aï0#aVFód\∆{2Êê«ºåd\¡UqºBNPÆÖp]¬R2"∏!c7%|ÿâ^|$AaQÿ ã£ .aI∆~ Ü¢Ñee 4πù1¥rôóÇßtSwN3¯…+˛åU‡€U›‰≥ï“"∑ÁµEÉ(a’ k∆Õ÷≈{çËwñu≤ëT-ªò.⁄Z¡‡Èª∂∂≤¬ÌÙ9Àr ΩÃh∫ôu4€·ˆ8C†,ÆâÎÍ-Ìéñ64≥òŒ:∂n«=än•/ËwÒhvë<Ïl#Ã {.'≠aÈnVfË∏”öMËÛñÈU«[µ¥'b‘”0πì^òSXBπD®]√éﬂ.I∏¸Ó,[ÜXÉÄÕóûw“è$w7'nm•ûºH´ŸS√ßIæãrïø=£≠∏btr6±öÁ+énôe	∑®:K∫YPµäô_Ê∂_¢%u≠…På-q
i˚ıgÙ≈Û∫M–-{ç\f≠äùÁÇIâjWÀî0†` É
N„ ¬V8s”—K¸ÿ´b‚¶Âƒ á√„Œ2è_t+ØcãOüùãÎfù\–…ßæX‚CÉÂ°CœñìKã∑≠Ñ€
îÚ≥Á9%• 9
,¨H¯XÅ ©£†Ç;
Óäc ´÷|ÇO‹√} .µw Î¶Tk )¢‡3|N≠*ZÇR€RU_‡K_·kÍ§z“3ÜUÊ¢æ
æ¡`\≠4ãT‰[ﬂ·ÅÇÔÒÄ¶Ïál‡àÇ#√–+*0Ù>ØiÚ∂XÂÏiùFZ$Kñ]“h≤O&ûù’∆ÒıÍVo—Êâﬁ’FW¨ÅÄc-ÃMëﬂD≤qhß∆õÎ:UìTüëTÖÒñ ‘;#R‰Nv≠ÏRÛzH$['tk=ê eÕÊ&≈õ¨o≤∫ßÁhâ8Ú6ølsç‹ïØÿ¬P˝=“‰÷£
eÓd⁄,±X‚Ó:∫◊∂ÿ`ª‘∂Ÿl"¥zÒœº§îûNÚEÎ/®õw¨€º•-j=í∂®ë®®y1/[÷\˚f	ÚU⁄e˜ìvç°S/7,∂ÉxBY|∑öÕôZI,<ÒùJ∂ÏG†x ‚œ&ñùØ”[öûåûÅ·∞_È≤Ct]b	:O I”ìa£$E Ï$˙Óè>¬∂ŸCˇ†wæ\ÿÔˇÅúo4˚¡Hn"î#RGŒw®
πäNb(Utm†{Ãˇ€£˛*z¢˛é*¬cÅh ºì§#9_xW∂ä›c¡hêyGË}œ’®ˇ/ÙÆCé˙CîAÄˆª†SË§s/A›áÙ°ü~8å#éEØR¸7q%äΩB—ﬂ#‹§@-8q;Dvò{K„0¿*é–ÕG∂Œ—¢c‰M% 8Nºõ‰„Mú†ÑΩUKï«;Iº1¢D∞Ì	˙%ƒû‚ÜÑêÑàDvNπòﬁ¶üDÙÌ©’‚g¢˘Ëy|±‹pxÔˆ©#UÙ≠cÄ˝ÎËŸƒ˛‹‚Uò˝]£è˝ø@ı}»∫•iàP8ùT©(’jê@ß	ˆ1*Béì‹ ∫qg)<rÁ
í¶ <ˆ«8…d‹æ8OÈd‚ÔwSÖˇ PK
     A hQ˛}¢   “   #   org/gradle/wrapper/Download$1.class}åM
¬0Öﬂh5µ*v/Ç◊ΩÇ?‡B\xÇÿÜÿííT{7¿Câ)‚÷Êæ˜^Ô«¿C∆0 $g{sô‹Z∆[€mEæ,≈]&;ìiÎ£é≤æ⁄ú!!Ã¨S\9ëk…'™J:˛À-VÑ—¡È6Zx/=!m´∏FÒ”•îYMò˛iHÁ tùnX°~Ñ~–8\jÅ4˛ PK
     A y¥[¿4  ÿ  A   org/gradle/wrapper/Download$DefaultDownloadProgressListener.class•UﬂSU˛n6õÖeRH(Z@€%U+
ik[ J%D´Œ%π€.ª∏Ÿ@ˇÜ>¯‘óæËì”_:#Bu¶}”ô˛#˛z—ù—qF=˜~t
8ì…π7˜‹sæÔªÁÏ›'˝¿+¯»Do4¢√“åHì5…úm¿9ÁÒfí∏ W.ö∏Ñ—&åa‹@Œ¿[&¢x;raÍc"è	i.ò4p≈¿CƒÒ*·3t<øí©¯ºÏàÃ™œóóÖü)(gñ°°,Q·Å`8µ◊∆1o’u<^æÍ{_T´ªWÖ^ˆ≈äÌ’™€{Ñ_n¿¿ÚÑ÷vÌ‡<√Â‘û≤oñ!<Íïâks¡v≈ï⁄“Çg¯ÇC+-ØƒùYÓ€Ú}1,⁄UÜÓ1qÉ◊ú`øÃVﬁ•q‘·’™†ÄsÒ:˛ŸËhíÂ∫Ø†V]‰nEîZSÖõ|Ög\dÆMÁ≥Rì¡ÀeôÄ!ˆ¥õ!ZÚ\JÑ[	Èd'Ã≠‰2cîJ∑&˘r]qRru∑J¡+¢ËÂ8	‘SõXm•öÔìÁŸö…‡Mx€À‰ß∆oóƒr`{.±hßì-’Ííg¬T^*wS‡‹Ÿ¢ﬂ°∏µdΩ≈‰l…2∫ïgPZË¬Um8l°é†”¬)´AÔXòF—¬	ú¥Ëπy’¿åÖkò50'=Ô“±ÓAõ·àZuËË3”57∞óƒ∂S"Œxœ¬˚∏n·\7!CˆTùDÔ‡M-‹%:ù˛Áho-%+‘±Ô”B’fuN◊I°Q{˘EÒqM∏%ëÌ€Â∏®vÀ∆»>EØ¯∂[°∆[·NML›† ßÚª77PPbØdƒ15∫/N˚nj3ãæ∑™RZl«1…eShK¸∂Ï°|^ˆê∂dSŸ:83Ù–mò ÒÖÜŸ1t˝µ»¶°1$˚Ü∆0˘ªpîÏ1˙∑@ÎçâÙ:X∫°Ù¿¥¥∂Ü’M∂:ŸÔ)ˆ4‚Gƒ!˝Lx†üäG/é´Î6°pôöI‰Õ©7Îxü#B_`§ßÒÓß8î˛⁄w0”=m·uËdÔﬁCîC-ëØ`ÃI˜∑àÀ°üú—Åd•)V«`ê˝Ö.˚_	Î7R˜;!˝Å¸âa¸•ÿ•â3°m≥¡KH)v#Ë#oHÕ˙’æöÎ–ÒVZ¶Á´N˘Iùr.n¶ª{◊—7ù≈!=©ﬂ√IbNÍü·®‰ú‘7`Ì¯âáh
a.ù‘ÈÔ£yDˇ—˘}±«¯¥Í2^@Ÿ#G£Êe!±ÜYY¶cúJ "#Ú™#KÔµ”xY&∑-/ßD15ì¢4%™⁄–%VÈ¢¢ÆköT…ËDº¨ıﬁÈæ„%–|Îì⁄@À€•è»lÃ‹ß‘gÍh	º¶–àπä|/™7/]>(êBÛ_PK
     A ûÇ≠€°  ~  4   org/gradle/wrapper/Download$ProxyAuthenticator.classïU›sSEˇÌMËMn74ƒJ©X©1I€$E¸†E†§†`˙aø†¥€õùÙ‚ıﬁxscÈ?‰3:ö¢Ã8>ÈÃ8Ä:>¯W¯‡√Ÿ€¥ì§ù;ÈÓ9ªøsˆúﬂ9ª˜—Ûü~p%G1•·¥Å>º´‘3Qºá˜ïÙÅÅq÷¿∆uú3UÄ(>ä‡ºö/t„"&t\ä†¡§éÀzp≈@+oüË∏™„CóønUìyÜÅ¢ÎïseOîlô€D•"Ω‹§ª·ÿÆ(çúÂX˛yÜ¡TGdzâ!\pKí°ßh9r∫ˆÂöÙƒöM+â¢k
{Ixñ“ãaÌÕzÓΩÕâöø.ﬂ2ÖÔz¸™„HØ`ãjU&ﬂÈË‰^wY˙≥dæ·z•¶=ÀuN¶“≈ª‚kës§ü€DbÂwg[%ÿÿ¬)ÁÊ}œr ä»wM◊fà¯≈™§¯cÛæ0øòï Wü2\ËÃ_«Gzµ{y5å2ú8 Õ`Ãª5œîW,≈tlg+´2‡x«9é°_IEé)ÃËòÂ¯sÛX–±»±ÑÎ:np,„&C_{Êójñ]í«
VÈ∞ÏnÍü+√[∑qá!ﬁn»p8€∆+(ü™¡!∞¶¢59N"…ê˝˝¿pt˜Ñ∂çÅéL2ÑRä˙8u”ú¸™&´d¥∞YQ§∂È©Ê¶j9$ŸÇ§‚$_«phvnÊ∆2√©óı€%QΩ8W§•Ê®hÖPºYgËVe∑â{w≠m~ºKTaö≤ZMéÊ©A≥º€ÓkæeÁË~®F!r3í⁄{Ùﬁh≠ßÓûÔÓ4U¨≈)Uçí"‚öŒ¨›ï¶ﬂ‚∞±D¯na]xû'6ÈaJ•W
‘Ù˚Ñ≥RH/aêﬁ·>z´Y<ÆnI!hÍRQ'øN⁄“4öçÃ––2[}KöÜª<∆4Ú@6po—Vù›/iaökô:¬ﬂ·–7∞HÍ™C/fæáˆ ëáà.o¡™£;¡i®#ˆ#k¯=S√øblXº6=Ú∫G¶"±<<R«+[ËΩO¡æz?HH{äæ(¿Ô‚˙Ä<•o–3ú≈X≈ü∏Éø`‚oTOêLÜ^E/ﬁ&´°o·íŸå#Eí"§÷H5MˇG†=á©£g˚˜xƒ·PÉÅI2)æ2C[`˚Û7∏çh8U“0UÉ“≤ArÅeoByQÂ∆»N£pÈ/°˙0}±ˇPK
     A èpOÃ)  ®&  !   org/gradle/wrapper/Download.class≈Y	x[’ï>«Zﬁ≥Ù€J‚DI≤8^I	ÿ`à+ÒíXvÇBx±ûm%≤$§ß,î%î¶{X
¥,•t°Ñ•––9¡@†-	{ÈltˆÈ¥ù)3ÃævhÎ˛˜æ'Y≤ÖIÁõÔõ|Ò}˜û{ÓπÁûÛüsÓµ_ˇÕs/—*˛Q)’—xË?Èø<Ë˝∑h~©–ˇx»ExËq˙ïó~MøÒ“c4ÅÜIaˆíóK<d∞CÙú^: .È»b∑h—®
ózh{ƒ¿¡¨©\&∏g©\ÆpÖár•á}<€CØÒ—ÃlU¢ôÁ°ûØ∞_·Z¬=t/Ú–[|éò^,ösUxË>O·Û≈˜—,ÕR—,Û–õº‹√’ºB45
◊™\Á°’\Ô"ÒØÇ†7zËuæPÂï^≈âE´eµ¬+º∆CW“*Ø≈ó/Õ•*7âØCHjV¯2°ÈÂ¢iÕ¢πR4ÎD”*ö6Ö◊+‹ÆÚm·f°˚U*wx(¬Aï7™ºIÂNAÌfÌˆ–u‹£Úf˝î∑®‹´pHê˙TÓWy´B'ﬁÊ·´y@ÂÌB∆ÖØQxß ◊™ºKÂÎT÷Uﬁ-tªáU6TRyXÂï#*ÔQyØXUxT·ìå≈åd[TO•å”πÎç!=5◊«˜«¢q=º9N©Tg$e`dÚÅt‡‡∫¥9bƒÃ»†n∆A,ÔÔﬁ‘›≥≠{◊÷ˆﬁP∞ßlù{Ù}zcTè7ÜÃd$6‹ÃT÷è•L=fn’£ihgÚ∂ˆoÿ–ﬁª+‹ﬁŒƒAQ51Õ⁄‹€sUo{(¥´≠≤¬c–Æ≠ßªªΩ≠;ÏÍvµ˜Ù˜ÌÍ
vvCÌòY¬‚ÂL˛ﬁˆuÎã20π£Ò·aqéÖùÒ‰p„pRGç∆˝I=ë0íçùrö*wÎ£ìΩ≠F2â√Zâiˆ®/&Á√Ã…©ÉËèbåfDΩ‹≤U⁄åDªÙòJCë·òn¶ìP‡‚¬ŸÀ¶v:•2‹óEb≥Ö©µzÜ£ûç¥[ôúmÒ∞!TçƒåÓÙËn#ŸßÔé¬—ÒA=∫UOFƒÿ&:ÕëvŒL∂ÅäÛ„±}∞BhöIñWÁùzr¢y≈4Sπ √‰A|€≠Ô‹Bé%í>O"O|UqÈ0º¯éÇcLdè÷\L~æSzvÔ1ÕÊÈ·î≤ê©Ó≈:)M·Ñ¬◊+uù›Åœ⁄˚7œËÙﬂ≤g≥„Ø¿<Úˇ®¿YZI®πä#“¶Ê5éj¡§Üm›êÇl?≈≥±ø7hÀçƒ7D¢Üî®Ë·∞–I¨ê….l§ÃHÃñ=´p- ⁄~`–HàI,Æ»ÓåôF2¶G± ù2íÎÜ;≠ª”CC"	ïÏh≈∆±ÙhØ!îÙöqSèv±as$OíŒíx#B9õÀ⁄‚i±¢∂Ä^ÛÛ’ÓD éΩP
26=or:‹kò}ëQ#û6s ÉœÅq. p¿û¥ôHõ0º°èb∫$À*fÉ±¸I%•˝…Ë˚u¢‡¶6N+ºO·˝
»1GòOqÃä©∆?ßÄ:3ı:ßÖò*xØUOEß"aEQ«O7íÄÄg07xÑ◊Ç±!;m∑û2÷¨nè d∫¨∫HÆ-V7+Ü”ZîÏ2Ãë8\º è/iE±[£5~ÕêÃY^≈&´≤ùï`fAª∏'ŸÆ'£¡57è+ﬂBíqm£[¢
ùyy+‰]¢SN¿e»»ïH§ÉÈ®n˝9Kú_‹[Ö«ññã…*¨& t<â”¯
ƒ…p`öS]TÇG–∂±∞∏§x≠Å] +'ßr4w<e˝“x*ü∏.98"nÉÉó%+/ºê©°hzÀ’∂Èu™‰ VyBÒtr–ÒéZêÂnº›E_P¯ç?∆7jÙezH£{ÈI[QKRáûÅ41Ò¥∆7ÒÕ
ﬂ¢Ò!æU„èÛmÇ3Õ.Rü4˛$÷¯SÙû∆üΩœg5˙}^£#tH£€È*€ZÚ˜B®ƒü”Ë∫S£ßËi`eƒ4	ëSÖõ4˛<AŒ‘‘$vúi”ÈWM±œÌ
ﬂ°Òù|ó∆_‡ª5æGß”ËáÙé∆˜Úë÷≥π•UfH#úüÅê‚Ú3o˛îêˇ%—‹ßÒ˝¸ÄFøO†—/Ë=¯N(\/Ò¶ÒÉ¸e\!g–]„á¯+?,öØÚ◊4˛:C„G¯õ
?™ÒQ~L„«˘∂¨∑DÏ…Ön∞Y1Å˝z*È9ôNòF∏AËˆÑ¬Oj¸-~J„ß˘€Lxö”¯~B„Ô€ü˚	Ò:5VZ”ë®å‰ ÏŒ ÜíÒ—Ä∆ﬂÂgEsâ(0§√b·¶Äi…ÍdêpÚÉY„1Å≥¢9)N˝úËçãÊy4XÒl7C2Fvõ‘Ø≈	{ÂMŒﬁ uòÒ@BO¶åÄÿì~F?«%P‚K„˘”·mÎzªÉ›W˙S‚0}}õ2µ
s{ é;h@è¡Œ)c7Å¿d˙õdÀg ãWIw¬¿}2≤;-xõ£ªXñä¿äÅtn√P‚\lOFn∞+â€RB£wÈ«øƒ/k¸=˛>å+› ∑°U÷	ç¿Ø xìŸ4%—j|öœÿÄŒ_ª$∑bñï˝˚‚ñßÌ}ÚkÄ¬Øj¸ø˚ı˜m®øD„7¯ÕæÏ“ŸE
S@P4ç6Ïéƒ¬ÎuS7qcn≥n˜V	0-’Zq7ıù˘P+b◊T`ƒô¡oëT 7©t"«6· hë`∑v¡Ó>+4Ï–¥ÚMU!q≥]Væﬂ“¯mË≤N4Ï≥´ÜfèÏjPnG')J<’`)zd]÷çÖKSçKSÅÍ•©f˘E^W„Ú;HWE2Ip}Ó“yŒLIr%Æe(-eißü·Îù>ßÿ#æv:ÃrMπ∂¡t≈o<˘9,ñ«ûü:†”7íåÔ∑^Ssãﬁ
±'á8 ¬ _È˘’˘E∂‡ß 7a»¿≈†≤Ä§ÊSI5í3PU{÷p‚V:¢ß∫ç¶|l«]9&Ö˜é‹ï ]7¿∏jÊ¬NÕæ∑;‚z|IıÙ•”)EÂo˙?{\âÎ™cXXaYuän~≈ÃWüô&ó¨îN"i Ôë<)√¥oàõº;büî!·†'A¥@[ëıƒ‰{ =∫7I*.3.1ò„…>)>¶ø‡¸ì¥Çáãòõò≈Ú¡ø`äÃÇ˜íÁÈ5ÆO„ŸgÙ‡‰Ô6>˙ó.ïXnÀ≥k8ÄWîzH…z8Gü{ƒﬂº<Éæ∞ƒsb 3˚ ®ÉêùîœGWıéV1¨(Y9UÜ˙(lû‚ﬂ¢äã§ÇìóÑy±óNQ˚;@R≤ï8Ñ˙íNµç@öê>{ cb„F!€µ?â∏F‰‚4Ai3ˇá∆ç#F]É—xJ<¨≈d¢ÎœÍâfﬂûöß	¢©¸53c!ó)•µJ·∑–‡à!jçÇ~G<eZΩÕ®vOÓπfK⁄U÷ãÓÜ§><*ﬂIâ≥¬ﬁtJ∑LhÌ˛ıhj
≤∂Ÿn)+ìødæ±$±ŸÇvAuOg≥ú0í à-nÈGx/ªÅ0lˆ±|eë5;¶≠…ó2Ì˘=ˇ√Ê`åHl_|/¸wicÏò;π,÷z–îø»,vBÒÀ†E’m3·N†bÚ5Óä'GusäVEˇ°àn¶Û®éb∫Å<‰ß[Ë˙∑Q	}ú–mÙâ‹¯0∆üÃ
„OÁç?ÉÒg∆>ÒTEﬂ'^´Ú{ª˝≈ÉS~Òvˇ›íˇ“–øóæàˆK†Ï 79Ò-Ø©Â∫˙TrÇc‰|F2ﬂá÷É/—E4ãV”˝Ë’XÏÙ =(ˇZT.∑gŸ
î»ûP¡Åµx©ÉÇçÿÅ±Xπyú\c‰Ó¨…êríT¶Æ∫ìT æ”K‰ÌÆ≠?I„·ZÜŒ,¶3x∆%ÕÄzí ¥ÌËƒô⁄cêÈîöVë¯˚’ZRÈZJó“&j¢njñZ∞˚RZF_°Ø¢-ËkÙu|UÍ†oHÛ<"%îÿ\ﬂó5wÊ≈\9M>Öé*Ùÿ≠ ßBè[#ÖºT"ªë	,*úpX¯ˇKÃY>xBz‡IÀ08ç> ™´£äö⁄„TYSú|5~Áqö]„w'Æß9µuc4˜8UÅmûpèC˙|H%jÅ	Æ†R∫nZGs®(i£Â¥ûj©]†≈⁄#Á∂∫ú€Í$NJdÔàtõË	:eO†«%Õ£Ÿ¸w¡(.˚,ﬂ¬œSÙ¥ç&kœäögâ}ÛOíøÆ´î£rtö «i·@û¡ãN–9ìô%7Ó†E¥ë™©S*mm∏¬V˙QÈÈíE^PøM«lÛıìCÆ,ØÀ–‚ùª≠F*0	`KpÏ¥˝-98Ç¯˙é‚Ô“≥Xy\n∆¥˝Lv3«XQ¸±mwsì´ˆùó°Ûõ‹„t¡¿8-¿∆K«hY∑ﬂù°ÂMŒöZøså™·∞Mäﬂ	ó*≠ryEÜÍÌoÉﬂô°∆&We5=Ø6©bt·OÈZoÈ⁄2øÀØfhÂ¿ö“íáiÁ	Zï°ãÓß≤qZ=‡ªxå÷ú™ÚŒ-=¨ØıVï…oYUŸZ;ZzœC§a s¯ûhÅ§kÀ‡Ñ™Z–™º'ÈR7ˆWsK3‘tt‚ALU˙ö3tôﬂuöTø+Có◊ü¶û˙µ•é&El8NW"l◊˘Z3‘&Œ∑ﬁ◊é^Ü6¯ï1∫ÍTSyq!ä‚/?ı,>ãﬁ¶˜ÅS|πˆ}ügÀØÄx¬ù%¥Ë∫\€i1ÌD@ÓÊÆ£U§#òw◊ÉÌ0ım4åôP"4_ô¥ón¢(≤f®N¿gIƒY
>5È{¥˚ﬂHÔÇ„œËf˙	˛sd—˜È ˝#› Mn‰EtüG7Û2:ƒ5t+7–mºŸV`Ê>`c⁄÷)ÿ9M'˘ª\KœÅßöƒh=ÙŸKœ”àˇ!h˜"ze8«:Ö‰Êƒn–À–GH b=ÉËY,·È˚Ùr@∂◊∫∏û^Aπêó@‚´@§åw»;ÅÕ ™S®C°◊z]°7zS°∑d
;— ˇL\,π.®öÄÚJQ>îî	ú±`íÏ)VËä∞BoO 	Uc∞ˇÅÕ˘a{‰E†*~wigòõ`gë´Í«©c %$»h6‚g~DMÈ¬O˜ıÎß-æﬁ⁄1
ùí°@ﬁ\êmnÂ§–;•ÉEˆ?ß~ô~$˘ÎÈ˜‡+Ô∏âu´KƒÔ<ÌÃÛú RdKˆËÎÆ?É≤ÈÎØÖN⁄˙ i2 ∂! Í|Wg£g 1SS?F€≠ÿA:òÃÄã P‹(ŒÏ‡ÖVÛ è @w9ÍËdım…%Æñ\‚j°?@J∞˙˙#ô∆Öﬁ0÷Ø»œŒ…Ÿs5òﬁ•[ˆ‰(6ï·Ã∂#C◊t’˘vfËZﬂ.«t]ÜÙÓ:ﬂn1tb<‡ÖC 69ÎÛFÜÜö\~ßﬂÖIc¿QÎŒ–Ü^¢»1¨‹+VFW˙ù\åª…)›5*2&¸U"”ı8ø°zæñçj`BH´∞˛|îùTÇKëû∑¿ΩõŒ-8Í≠H⁄¬^◊¿Û¡Ò«Ù'ê–Ä¿˚SÙú†ÃG¯sxp6∂h∑¢ﬁ¸˝%zΩH4Öû¿»ëú≠èHª‚ÜâK⁄OËØ°£∞p-ïL`{áÑ1Ëß"ˆL =Œ	I≈íü!ÁXHïS8≥MV«ò¨é∞Dó∆≥√Ó∫”t.ÚËBA®rmMJ‘[:º],á!ÎÙ<R’¿”ãH©ßÄåóÛ∞”ñ;Oõƒ7Éw5˝çºπ-Fí˙€vPgM-÷Âìø†˜lÃTb’ª•™…¨™ùrò*<àô;à¶≥CTG1ﬁóª‰xnÏˆ®P%P0·˛Ÿ°¿-4‡ˆªBäﬂPkCÓ:4J}Ë<ñ+˚V4ΩÇ”ùFˇ¸Ò*¢Ë5ÍB.⁄IoHãtX«∞-Ré‘˝w“√ãë‹ˇ^Z§9ı}iëÀi+˝Éºu—§C0¬NZCˇÑûªB•¶±€àØàHy¢IÖ‹í∏4Ôb„¢ïó–ø…ˆﬂQùƒçŒI˛Å–9®|7ÚÒΩ^:JªKPK
     A yÅL¢°       1   org/gradle/wrapper/DownloadProgressListener.classuç¡
Ç@EÔ+”jDÀˆE–@€ñEêER˚I¶à#3c˛[ã>†èä4⁄váª9ú◊˚Ò∞¬¿ÉÁ°Oòƒ™.r%„–J[ôÕM	«ÑÒ,»‰]äÇ≠8üˆkﬂü_√PU:‚]ö3a∫˝©G≠Õ∆©±\∞^∂&a°t"-„úE≠eY≤ˇ¬ËõÀõº8\3é¨K t–éBN˚–kÿÅ˚PK
     A !9|∂  Ñ  3   org/gradle/wrapper/ExclusiveFileAccessManager.classïW€sWˇY“⁄´u|i™VÕMNZ*;±ïJälB◊NÂKú∆é[óêt-ùÿØv≈j«‹SöB[(∑∂–P`x°3ÌL´$xÜÙ©Ã0√è}·Ö0ø≥+9æ%L=ˆŸsæÛ›øﬂ˜Ì˙Oˇ˝˝ ¡Øt<ägZ†„YµÃjxNG_‘pNGœ®√ó‘ÓºÜÕx^mMEúSKA-EµHõ1Ø∂::`È‘vI√b3lI≈ûDIGé∫quîÒÂfxJ_•~O°™cóu,·JÍßÌƒÒñÒ_’5ÅˆÒ…°±#˘Ò·SgGFÚœ
té_2/õY€tÊ≥Sæg9Û˝≠CÆSÒM«ü1Ì™hÒ≠ít´˛DE@‰vî]€Œ;æÙ.õ∂"∆,«Úè	ƒ2˘|˜å@t»-R∞m‹r‰©jiNz”Êú-ï=∑`⁄3¶g©sùı,j…éªﬁ|vﬁ3ã∂Ã.yfπ,ΩÏïÇ]≠XóÂàeÀ¡BAV*¶cŒKèé∆ÕÄ 0ò	„∞‹¨‚ÎOUﬂ≤≥◊)T=O:~v»¥me±ø{]‘ìsód¡W ‰ï≤Â-3ƒQ∫dªÖEÅ›!£CΩÖ”q§]	0äEï(πﬁ;&f£*2≥B5˚˛è?Õ ^®§£±}“ÚËô´\j˜LßËñ¬¯C∂á÷lùŸtGuZ›€5”["
‰Mn,…rπQñáÔÌı¿Ùtˇ1ïÑ)ﬂ,,NòÂ@L√◊5|C√75|K@g˘dŸ∑à'¬h öwLøÍQ˜ƒ¿tnké}¢2Üts•Û“ü&J',€VXj t≥ä%syNŸnE>]µ§o3ï…;6ÇãƒlK°q∏oF3ÂVΩBΩ÷˚ÓéÃ>%l†Wƒ!Ω8$`¨Õ¿¯∂¿õªÔD’≤ã“3"Æx	ﬂË˝D]AÃıŸÖEﬂU
˙≤ÅW™ÅÔ©Â˚xï¿πcÛL’Q≠ΩV$Å√Cn’.¶◊O<i˙2]6U“”≈”]/≠ öæH€iØÖÜ~``ßº,"ﬁíÅ‚G~åüxg4ºn‡º)êògL⁄ΩòVÅˇîÛ M
≤ò^2-ü…	LØµ\:l˛¥Ôû‰(ˆ3ºe‡:Æj¯πÅ∑qZ√/¸WY–;AØã∂}3ˆ‹rç˚ªµS#ª€å^L/xÓR®íXù	|:»uò¨ˆL˜Êi¢ëÂîY‚ÂŒL˜vÉ;Æ–·âôÃ÷Î≠u∞©Ò„ª!I‡¿∂=∏AΩçóâà∞—ûfßUÒyLXïuc´çŒU\ªÍÀ”¶ø pˇvéQüNŒµv5¢ª«‘“|o9LÍﬁªr◊ßt˚Ü¨Kì˘âUl)ÀÏïÃ®≤æ;ìøWv¢úèˆÊ§ØΩ74O⁄“¨»Ü¶ñ+æ,1±éÈ∏
⁄F[F
˝f∫†>#Ä&§êA7zxä ÅN5@∏ÔT3Ñœ(Ô˙êÂzòßYÚ4©}œàû] “≥˚4Ω?àEπvq›è¿<Ãè ä·”¯L¯•ò¡Näpˇ8>K.öâ¸1¥‚âDg÷[A|ˆ4nõkhÈLp©¡∏Å÷SΩºÕES—v\«cÍŸˆÍŸ~]+Ëò≠ÀvvRà‹˜5dwﬁπò»≈ ˝=Ô#rÕ<™â\K™ÂèT¥§ˆ˙€8∫Ç‰loÁ7`.ñä’ê ≈SÒ
WˇöäﬂƒÆTåU4]ªâ›Ô¨~®TÙÆ7Ωá6ïâˆvÓ„˛‡7›BZ ßßHË
“´@'ºc •øõKlœì∏ù3÷1∑ôˇø„c—∆∂âıDQDDwp>®û‰Pızèp}î’ @8B gmŒ≥*&_$Wô‘
Îˆ+ÙkÙér÷}øFøA?~ã‘(µÇAZ∆«8â√Òü¸:¸∆∞äq¡§–8≠”õì"âºÿÖQ±c‚ Ô?Ö	z5)ìÁqjÖôsDP∑hÌ	hÙ†Fõ9“àãé∏ÎßuÏ>ècƒ—~Í˛iM»àvz5¿HM¸çæù ™ä¯Ü$?bá)n¨IéPÚ$)S–˛É„¢¸›≥äùh—†«ßB¢Ü§Ü<£¿øq¢œ“0∂ .“∂ÂÉ√xΩèd–(ß¯«WWΩßéw@ÛMÏﬂâ•ﬂ≠5S<†üíaÑ<ı¿uı.´ÀüÁ3Ù‰GhÌπÖGﬁAt¸=í£dl•Ÿ¶@]±†Ö˘ﬂÈÁysé˝˘¸:ımåöOï	ë	ç≤º8x4Û?PK
     A êÏÑ,y  Ü  -   org/gradle/wrapper/GradleUserHomeLookup.classçS€N€@=$våÅ‘îK
J)$¥ƒ⁄“E¢`@"\î@§<E&YÉ±#«°¢_’ã®H}ÏCø©™:ÎÑK ‰afˆ‰ÏÃ9Î›?ˇ~˛0ÉQåIx&c\¡‚
BòîÒ\¨_D–Ç)	I
∆dË"øî1-ÚåÑYÜ˛eceq7µì_M/.ßå¸n∆HÁ◊∂6-u`õ∫m:%=„{ñS˙¿0tõóﬂNomÈù\~›»1t,πN≈7?k⁄UN˝ÔçÕlçû∑À_`hç'≤mKnë6t•,áoVèˆ∏∑cÓŸ\Ëp¶ù5=K¨Î`õøoU)◊+È%œ,⁄\ˇÏôÂ2˜Ù’`π[·ﬁö{ƒSÆ{X-ìÙŒRŒç'j-W_±lNúéåo7Ãr0F¬+yæ`◊Ö*∑Í∏‡2ƒöçIä~*z—«0qOi$§∆JV	OÓ”^´xÉ9ı¶@—¯-—oü©äwòSÒ CﬂÌèˆ©jŸEÓ1DÆ⁄´x2+Î…⁄`Û¯H}Ø∑nÌÇﬂ ’∫5B'ü1¥ó∏øÌπd–?aèﬂΩ8âfw©ßënBò⁄qÁò
qhNëaÍ^-ÎNÖ3ﬂΩî˚0ﬁd6û–√à“jELU1tS&>’-ﬁsc-¬ƒg•ÿOàNôQMûÅ}(1ä· Ï¡#äjçÄRé`èÎõøÕÄi≠ımπıﬂP/ Q´WM:á‹â‚;"¢¨+)	Q§g<D∫á)é`£WÉ%L&|√[˛¢[¬àô¨_öò%’‚7p%wÜvM%9ßË–:)ú¢Î"¬ªa≠ó‚h`˜ÈPK
     A ˙‚Ê™   €   "   org/gradle/wrapper/IDownload.classEç¡
¬0ÜˇÃÈÊº
^ıb¡ÎÆ*A—{› ÿ(Ì®”˘l| JÏTf $_ÚÁœÛu X†Ô°Î! ¯âÆî‘<!L¶õú_9S¢dá]~)”lùIŒéÑ`uãEQfZù=Ù,Ôı≈ƒ¢ﬁ—Úg5Ø	cmRñûH¡*√ãB÷h√èΩ‰*e€S.‚í0˙èöO¡A‰Zp-∑-’µc”≥ΩˇPK
     A ˇ%≤V  Ü  "   org/gradle/wrapper/Install$1.classùWy|WˇæÏfgôL ∫@€‘bõ{	-îÑ√ÜÑb4	4BBKôÏõIfg÷ŸYı†⁄Zèz◊+ı>±äJ±ŸÑ¢ç˜Å÷zﬂ¢≠ZÔ´˛a?U‘ﬂofw≥ªYRb>üº7ÔΩﬂ˝˚˛~ÔÌŸˇ<Ù0Äu¯«"¥¬‚!¡√x∞yHÚ‡»hCJ¬aAåK8"CFäG˘Îˆ ^»ÛãxÁ≈<ºÑác<‹!#éó Ë√Àx∏sÓ¬À˘ÎnØ¿+ô‰U2^ç{Çxìæ6à◊±¨◊Àxﬁ»;o™¿Ωx3æÖóo≠@o´@oÁa"à˚x˚2ﬁâw…f+‚x7Ôëﬁ ﬁƒ˚É¯@î—åÒ¡áY⁄q	ë±˜À‰·G%|L¬		®:¨k+¢Cz‚&›–wè™á’∞nÖyΩI†Çi¢z“È‘mÅ•Ÿï≠ß›2˜ÿFé…‘úûæ.b∫Ñ…"ñyHè•lïÈÍ∫-;éŸj‘–¬„∂öHhvx¿õ;ÚIâ?T¨¶D]∑~C*.PÌ)3T3Ó'3FgDOÆY+∞∫îñ.3È®Ü¡tõuSw∂
‹U;aaJ≠≤æ^¥Ss≠Æ€+‡Ô∞¢ı%›∫©ı¶‚√öΩ[Ê<TwsZˆ™∂ŒÎÃ¶üΩP∫Lìƒj2©—Úäy<Y”BN˚Ie©™∂Æ8πäÓëuåhë1	üpeœÓ\ iYŸ˘§$Lv‚âé|QÜã†Øe9•];∑âhâLéÂ∏jèi∂G^ijZ4ŸiçõÜ•Fâqà∞ñTiù≈XS+—≠÷¬#9_ÂIßs#‹M¥$xyaËé&≤·´)¢›\é≠ƒ[ŸÔ®ë±5·≤H¯§Ñì ks¶'%ú∏4L7£;áGµÎ^‘Ø«L’IŸ§Æ}.AûTëîmk¶Ó† ≤∫ˆ»˝V éh^ê≤πif2Õv3bXIÇRèÊåXQ	üR &l«M
6cãÇ≠<<7*h«6ËT∞iíïØJ¡v	¨(ÜË∂înD5[¡4N+xg(ØÕ÷òÇOÛz>£‡aÃ(¯,ü„Ωœ„
æà/)¯2æ"·´
æÜ≥
æéoHxD¡7Ò®ÇoaF¬∑|ﬂ(oN®∂£‡{¯>ï ÈÆaÖ?êC?bÆ„'~™‡g¯πÇs¯ÖÇ_‚1è„W
~Õ˙Éa¶S34áŸ	qÀ>JÇû¿o%¸N¡ÔÒƒü¸!‚¿$DuX)#ZcZNM º]O‘P’8M¢Y ÿß©IÀl#©eáˇÜø+x3+g£◊ó2=ÆÂÑr¨»Öù‰’Û+i/∆å¿ÂÛÇF‡⁄ã,—l“3≠ã⁄va9P”ô›Ër4j\ñùçíkQ^îV^X)°6bk™„÷Æ@k…N[≤GŒÈOæZníï1ÕŸ•≤◊^H¥ÓU„ZqŒﬁ,€§6“T[¢ÌŒŸ ¿úÉéÂm	\][™Ì˜Ô
=Ÿôök.ı≠ÄûÙÏ\Bv∂'-#ÂhªTgÑ£F"Zí.™µtU≈|∫±ÄŒúQ€¬jÁS[»…ﬁdy◊1oÈ\ñÊ-Œe≤˚è&çÆrüf€˘ƒ.ÚÃ!ˇ45ûgıu¨yÀÇ5Bbi	Ñ§Ø¬Û≤RH°¢‹P(ô´J®üΩØ$æ´ˆÿ:›∆µÖÑ∫‚∑Q÷≠Îü1†•s‹m≈b.X¿ùπ`ÊwËÇ¬(Üõ5m=õ∂y·¶ue≤È}n6`¡hÓÛ ¢àáì§⁄ßzﬂm—À≤®,Û!∫·ôÕ.bû˚xÍπ∆∑º6ˇ<€âFQìΩ⁄Ím~”ù≤‹¿4-ƒÄ°“ÌªTwÙ˙I˛{(ÔI7^Ÿñõ/¬ñ|ƒ_LÀÀ*heõ˛Ôg¥+äÍ!Yjå
¨b∂I-4ä|GxWNØ6Œ[®°_:m ˚®™‚ß@Û÷ÃL"w¶7ë;”≥»ùÈ›Dø}Ùøœ%Ó.˙B$öØ©oòÑ®oúDY}”$|ı!ˇ$¸ı°ÚIî◊áì‘OAzÄ(À<ƒ“Ù|ó”I@7z˜ã5—ÉÇütFz|∑°úıî…g¨ei,:yp
ﬁJI£≤z1i,ô¢w/Ì˙“∏d“®û@mﬁÙñN„“û∆i,õ@ê¶Â'OaÕó•"˙ïû–Í˚ ˘è√Ô€Bkˇ4VıÆû¿ÿº&¨Œô–Ê˘3¢ƒ4.œêV_AMi\IDi‘xáW±¯êˇ4ûÂC»ÔIªz kÒ4÷¥πßœh+ïü∆5ÿ¬_◊
z^€EJjII(@nz÷dÖ”®8˛ﬂôå‰Ú4Í”h`}ÙOáçôÉ2Om”ql+/&ëûÖ,ºz≠∑Ùeñ-
Ûÿ÷±E§∫A®<káè‚—@	aÁ‹î¨t≠•ÔÂ”∏ûÚ±~¿]ú<ÉÉ¸uŸnòÅD\$Ë«ºﬂ≈‘›∏ä∆v‘n[	µ›Ñ€~¬“>BÎ0°(F;„Ë¡1¬’ùÑ¨∏ß–áGâÍ1Ï¶ßÔ û¬>±Éb#Üƒ6Ï€q´8ÄÉ"ç4©¬∆∞∏qQÒ=©œaD<]<âQÒOåâÛ0]LÇL⁄VëÜ›Ñ‡ÑÙ=T]~í›ÄΩÙ I˚Iﬂ>¬5°:É˝ZÒ8ÈT`\‹Kµµüxèâ{pU§Oâj‹ä$Â]…Â∏ç∏¢˜ŒR$T⁄iÅ|˚$%Ù=ç≈ï7í]éê0|À$D$DüF«®ÑÊ·ñ#LT–àÕOÇUµSxb^Ÿ!Ïñ!®Ü”ÿx≤dı*A∆ÉúG\z£Ó<√=ãSÑzË´öˆZ·˝ı—n?‰ˇPK
     A —ÂQÍ{    -   org/gradle/wrapper/Install$InstallCheck.classïî]OAÜﬂi∑]∫l÷o¸ •J)•[
ö≈õM@/jö‡›∞eai…n´˛#o∏–D¢—ƒK/¸Q∆3≥€Ojh”ÙÃú›yüÛûùŸ˝Û˜«/ %<6GNÜ•ÖºÀ2-Ë( q≈@%´FÕ„{ÆxŸ8©≠C˛û[N√⁄t\ÒÑ.Ïs«myb[¯>Ø—ät∞¬ÂıöUizNΩF´ÙpÉ˘™Ó7πÎñÑ}§“∫ .˜}·3ldœ´∑^Õ
LX<~r"<+§dziTG+7ˆ®»‘ñSØ[«ª¬{Àw]Â™as∑ =GÊ·E˝∏mZ˜[∂M	√z∂ø√q™«ü:uß˘åa~ 2§©*ôm8Tqú
Ü„WÖÁÏ;bè!ö]|«ê¨4π}¥ÕO¬¶Æ:…¨ã˘Ï»p…ä|,v%	X0x4⁄†U	⁄‘Ç&€m©æ:ô2iT-œ≤l˜Ä$ƒƒ5\7ë¬%&í&Lö∏ç;:÷Ftd‚n àa∫ÎÌÕÓ°∞õ3ˇ«®M™béﬁ®Ωx§•ö••îì;–	•lÕ „'‚;,˜˙g•∫L1.Ô∞Æ–‹V·™b≤…aÑB»ˆ7Ÿ`Hÿ°,J„ïü»-ùAÀÂœ˝“¡§©ÿ4ñGÇ-#≈

9»0É[ÄöI8S3ŸlÑ~Ù‰√2/hî˜íπØ–~C◊>Aãû“Öhè◊ïØ…|ó˛1D&ü≥È	ÃR’ÄgÖºŸéùÙ<€√â·û‰ê¯>Êœâ…Ã‡.Œ‡¡qt4Ò√Œéw≈ﬂπHúT‚ÖŒf˜äŸE‚`ü≥*.bZÌ>}≤BıPK
     A ∫›Ä4÷  -      org/gradle/wrapper/Install.class≠Z	|\U’?'3ô7yy›“¶È–Öö6k”ΩtRäiö“î4-M” Úíº$≥ƒô7m*Pë]Që}≠"*ö¥(à≤
Óä(‡Ç‚Ü†≈|ˇsﬂÃdíº“÷ﬂ◊_zÔ{w9˜,ˇ≥ºõ<Ûﬂ!¢Ö¸ÆNiä•ô*Mâ4”
–§9N^ßÎTŒ34ûÈ!˛Ò£:È<KÊéó&®Û	|¢4'È<õKu∫ëÁH3W„2ù¶pπ¨Ø–∏“œU:›œ’œ”È8Æ—Èû/#‰i°<-“x±NAû°Û^™S=/ì◊ì•Y.M®êr≠üWh|äLØ‘È#|™~¿œu“Ø“πûW˚πAf÷˜ß…¬µ:ïp£ü◊I∫∆M:-„ı7Î¥«apÉ4•9CËlí≠-~ﬁ,#[4ﬁ™Ò6?–œ≠2∞]ßUºCöÈÙü©ÒYü-èÁËt:õ:≠„6ç€u⁄ ‘◊qáü-yÈî&§qóN[∏[„∞ŒÁÚy“Dt⁄&#Qùv?«§èK“πá?ÏÁÑŒI∂8≈;E§]~ÓïæO:_„tÍ≠vÛG
È_¸Qi>¶ÒÖ:E˘"ù/Ê›ÚtÜ¨˛∏∆óh¸	ùí≤!¡ó ÆÀD‚ÀuzGl—-Õ;|Ö∆Wj|ì—K⁄f$Rﬂmµüß^cV¢>b&ìVí)∞∫aM›ñ¶ÕgØnlŸº©q’ñÕçöœﬁX∑y-SQ”πÊN≥&b∆∫jZÏD8÷UÀ4Æ>.ÙbˆV3í≤¸|5ì/ÔÍ≤L”õ‚âÆöÆÑŸ±jv%Ãû+Q”§&±”ﬂﬂãƒÕ¶YnWßÁÂî”ÓÆã—∂àP>—m√∆‹5ÿtú’€I%√;≠5·àU◊ﬁn%ìÎÕò©x´q£–pÿ Á[éÖÌïLgïΩè\Ô/…ëŸ.ﬂ ‰≠èwXLö¬1´9m≥õMLä‚Ìfd´ôÀ{z–kwáaπÆ';∂˜z{¬2mku8i3-wï`õ”√†ù·ÆT¬¥√ÒXmπcÙpºFt"¶hœùg*?jRê®«'¬m)yﬂíà0çw»«,ªfÀ¶F,)Œ]““m.\≤¥%eö—WÁLj¸I7çfZ|D-œ≥'krÚÍp"À‘∞ÃÜ:|{∏Gﬁ°K‡ƒÍëmIç?≥`≤=Åzs>±l$ïr7Ôa∞Àç¿V[™≥S`ô∑cìß€Í≈x∂ÌTÊE·$3I´=ï€}5ÎÅN@su∏ÀJ⁄†ÂÈgOmåı§lúdôQÒ∂∂>Xﬂ¥M¶êw8`ö6Ü´Uä1tãm∂ü∑ﬁÏQ8”¯ç?≠—ç?√4ußïwˆÂjpS<dù>JÍ±Bª‚%ç”Ÿπ±	,î‰ÇaµïlOÑ{{;¬	H;—°è˘HMSX©AwHØçG°∏©#¶Ø'„4¡QWåd{e≠∆ü3Ìæä≠§wIŸX¡é(8<[ã:FÉÃv;eFT
íÒT¢›RQhıˆXÌ∂’°f¸ì5Ëéß\—Û-X:a«»•=çCZ¬]1”N%p¯¸#–£ %iŸΩ¿û-
‹h%¢·dR< >8öÕ,NÀé;†≤:6YfáLìvG<egÒ™é^ODM€Vº?–ÈiC œQÊ∆D\¬Ú™T8‚PBF•…c»å5¬6dΩ∂6kµ£1Ü#©(=w…8HıÒh‘å¡ˇ,ä'“^ßÒµPi8π-CÉ¨û≤ÚÌ+ûl6xVƒípõp—j…îJ/‡o˛ˆnàì∞ Ï…;‹‚Ñp◊Ë˜0q*v~ÔÍgπ»∑bv¢/k•`l≠AkêïÅ9úêf¿Ÿp!~ì°∑!g\Ç§P»JrË6ƒRQ+Â=äCØ«ÜÛ3Q≥d,#È∫–ù‘ä √±.Ó˘9çØ‘€„=}9ëéiﬁ∞fr#†ª@T°vè£'"&–MeöŸÛÁœgÍrMïôº˙ˇÏÚzÁK≥@öÖ√\,.‹vÜ◊S≤uVÜ–!¥‚ÿ	Â÷aZKèLÎà—*Ckô–™>Z€á7ü,õœ8äÕ«©Ûzü≤\N©=f$‰∫caö‘Ç˘«,.vÎ-*C§}5Ωnû,3Ë9zﬁ†?—k=JèÙk˙çAO–ì}Ç.5Ë„tâA¥ﬂ†´¯Û8¯ò™^ŸtΩAW–ï]Fók¸Éo‡æâo÷¯yπ’‡€¯vÉÔ‡€QÉæ⁄±;˛"ﬂr%DêhY[Wç¬…‡/Òó)rgsú +Ô·Ø¸Uæ€‡ØÒÁæáøéÄÂ^∆h¸Éø…˜ºóÔ3¯~~@ö}˜ÛÕ–+LÁú¶¯Êñ¡π•…π¡é∏ï∆‚vØmÜcA3÷áe	§Á∏ƒ¿y¡ÜtÆ⁄Ò`'2A–ÍEZèÙd◊ıÕCï2Ã‹Ü∂s1l~>`É<hC|”ôáe"}vGƒÉ—ˇçÉÊG4>h£¸”∫#K,¶3B4+{–e(ã7ËN˙¢¡ﬂÊÔ¸T ›[•l
∑´(åw∫mvö0n«	•±“X+¿Ì∫&jˆªÕùV∞Õ≤bA€åˆH‹∂ªÁï∆‘◊E"¥ªMçúÎ˙Ì07ÿìàc£›Ñ}rñ—Í4DÁ•Á°–†TP¡pb'D{0yál	ö	∞ñéÉ@ó:.Ω=ÿôàG°;ëJä%úbnûÃ-êÉ®ÔB¡“di,PÉRù î3úµe{∫Œ)´ÄL∞Nãc&~íoF}4åØM©òéZŸ:FúÓ)T√—∑.ë0˚$¸4Ωb3¸¨¡ﬂïßÁ`@zY|Bo«“~,ûGq∏
l∫3_˘Ì›—8J&œ≤%K˛|Tæo¯áˇH ?’Ω2d
∏$ogŒ‡ÛOÑ–O•˘Ÿ°≤ï£¡/àFº¢OÒ≤ügñç¨ ~QñÕzˇ"P„_¸K~…‡ó%vñåç1iT‘«SëÂ9(ì·Éô:9ÿ3\(;„âPP‚œ+ˇ ‡_ãa¥xr^£∆ø1¯∑¸™∆ø3¯˜¸Éˇ»¬Ù.ßæ4¯5˛≥¡ØÛ(i]À(Éﬁ‚7˛ãÚ-˛kF√cj'Éˇ&±˚ÔˇÉ_5¯übÓ£ç±aD18-7ÁNâﬁ≥¸À†wÈﬂø√wçáOLsè≤B˘ùôßFΩπÿ?Í3∂W&ÀZïi˙˚|HÁ‚%∑¨Ã°¥π;ﬂÂ|FéY’†÷„'#ñS›2Mq+I’óÑîÔeçç“ª)ÃÌv•póeèî~bY˘ËÎïi£Â\XL)sΩ¢IÔLgÀu“ˇt7S4ämı]ïo¯¢F«∫Ï5Õ%ˇs¡6RkG-ú{%È3”_zuÆﬂl
»≤ #> Ìöz0'‡qa‰î∞*	bÌêpÅÀ5D˘Æâº@Yá‡k«™rπyJıtò∂‘`p óﬂâ'1‚ÎH{Ñ∑¨\Æ•&çåñÍµ–éØæM*.kt≈êﬂU]v∑¬∂ú)∫ìOÍÈeıc◊g/†™/ù€røœ°Öì—_øæNï‘‘b;∆jÿï˝lÌæ@j˜S\Ÿ:˙Ô<o2|>¥ÎÅ%«h,kg7∑_è€p≥g=
≤€LÿbÅ	Rˆ5ô©äÉƒ:#≥‹owÜΩ$+œ¬Ù∑Â®ÂG/ãœ˙0Íâqe.∫îÁƒâNum…x$e[‚Ô£∂‰˙ã’ÎD¸π¸Z„\iM«àNÆŒ‘∏–ßŸDùt‰˚G1Ã‘õ±x5jƒ·fjôÀ≈ãÚÜ§hZÿÕ5‘-ì∂À€®?êîoÊDÚíú 5Ú6vö˚%Öú7yx*}[&£~Ò⁄&u%∂‚òê<ÊbMB‰˙Ã-dNÌÜ¨¶√∏t  ºèLŒh≠‹}e
&ı5{Téöπ≤ˆ∫BÆ`‚]#k >T’Q'ÚmLÚLséÍ»⁄%'CKbë;≈--Ÿ_fÂL‘™h÷ﬂÖ∞nJ¸Àúëª∆ıÊ#M"ZŒÇ˙n3—±¨ï7x#™H(ŒÇy$ù@YÆ—F^™MË6ìÎ„	´!bEaU≥zÌÙÎh3e„à≠97íπy\—Wåô)["re71ivZôB—ŸÂãûÁ‹¥Üa9Ê≠&WQ#.Íáˇ¸]»Mù@P9ÂSÄ.§ãàÈbºÂ—n*íã<…-ÜÍ/£ÀU]â~2÷^EW£˝$ﬁ./˙ŸTP1HzkQ·$zjÄå}4Æ¢riU˚»WQΩè∆ÔU'|
Ìq‰Cª ;kh
-ãh-¶ìh	]Éô
á&}ö>C§ûÑ'VO¬Uûzæ<˝,]ã·f?È§°_YŸO÷£ôÿ\Ò ç«√§ê7‡Ìß¢PætìC>åè¯iJkE¿»Ø™¨†‚~ö˙(ï‹;äœì!„rPÆØ+h:ùB'“©äœµŒiY>W“ÁË:p$Î?O◊Éä©æ -y∞∑Çn†õ!Ÿt»y›äU'“∫O>∫ªΩÿyˆ‡õﬁëáÔ«ò3◊M€OÅıÉt\kÂ Moˆ,ıNöH˘C˘≈ﬁº€hFu øüf,ı{oz´*êÔ)Üê3˜ΩZ›O≥ˆêÚ…C¿w∞™üéy)ÿ:@'ÑÚ=K}≈æÄ˜ë;i˛$
xã}ã>∂üNi≠üNÚﬁNÖÅ¸âÛ˚iˆ∂@æïnªƒ«{Üûó„Ê‹&'@9ßÇ¡S©Nı•∂≠Tå6±vbE/†”üO«tsÈ#TE≈æã°Ã›ÿu15†_7√∏€`ﬁ6ò∂∆Ì‰.ÿÆ¿ÿ5†,*ÔÑJãh›E_Çr†˘e⁄Uˆ‡˘+P¥F€¢ØbVLw]÷4◊—›P4‹
TæF˜(ﬁ/•Ø”7¿s3ùFﬂ/N_I˜“^–ª{ì6≤>ç.–®D£˚5zÄ5⁄G¯ÊöµF£~ˇiﬁ5
Ú!ö£Q˝ª4nÑ) I«QÜ@3_¯ØÄÛõ´–\¶ïy¶ÚVOUÀ~™ÿOï˜b¶
ÒÍ6LUèûÚ†yyà
ö˜SÕìX4‘"ôXpØ‚Al1á
–~r_â?GA ≥–¨•!ıM¥ê<öπF…´8ÃÍ¨S¡î’”Ë6TŒ°i:;ö≥^zÛÜ“¨Ã=Ç9—›Ú¢†Fè;D≥°=æK˚È38HÃS_˝’UT–¬ê∑Zs—ç¥ ]º≠hâ¶ƒ™liıb`iKk~uK+∞*bÜÚiYk ÄN>∏7ã:G“;¡—]T˚O2∞ÍXt˙ì¡◊*ÔÂ®>ºÎÙ-¿
i=é'	:ıYÈÎÈ€*0 ì8iûz˙érÊ˚TË‰ˇÄ`Æπü†'”°œ]7HÀ·k!	Fµ7–
t+ö!ı¢j1·#K,ŒøìN˜[Ë∏ﬁ)7êQ–– <r\ÓÂ™—&›˙†Ê!Ë MÉ1¿ÀaÄUx^Å2&]@ì¯5¨\LO—” úe]ó6≥;≈∏yYì:#è`DÆ$œBóñqáÉ=ÉÜäf	º=Ÿ	,~V—Ô‚ˇsÙº„P†O±˛8í≈©7êwÔ ï¥V}`ÄÍ÷sÛ ≠jı=Lı≠û¢’∞zQl”Øi†”úËΩ—ëßÒZ3HÎZÈÙVyo†ı‘B4ﬂ ]oÑ}˝tFk»ˇï¥¢Méá¸-˝‘≤QQTºπyÕp»n≈#Ú√~˙`?µ ¿v±PB§†¯°¢3˚È,Å!∫~:ªüŒŸiäÆ.ß-™ø°√Å·vöäˆIh˚)ËÔ‰Àg±‚9@y
—˜†—ÔcÌ‡,?¢ÛË«»æ?≈˛ó@È‰◊ü√*/Å⁄ãXøÄ{˛∏z`~P˝µ≤h‡∫çÊÅ“˜ïÀïÇ÷qZ7Õ≈ãpÊ"⁄∫?ZBt:®ˇ∂πk_ u/ËxzQÅ˝Ò,WŒåŒÚˆbÑ∆_f¡ﬁ@~ˇŒıglåüzçViÙíFÎ4Ñ:D≥0&@Ê."Y¥K∂çÇÏÀ≈âàß„M|jrëπü⁄Ó£ˆ~Íh™,≤˙©Ûûl÷’íW¡ÛÔîÙSù-iæ»˝+Â§yÚ€ó4·G!´≤⁄JÂI—u≠ØzÇ =+gV!◊ùP°pW5s!Ä7@^…õ7RæÁûK<¥W∞|Ò=£¢ üp–k8Óœ4ë^á≥ΩÅ‚ÈM·/4ÔKÈÌ¨≥ïcÂo¡∞Yj∂ CÏ´ ˚øW¨◊fU^KP*ıé#œ{T§—yÊª í'øUJ◊ è·]«í´©[≤∏π¸\AÓ:ORà%OÜÿQ	å%≠U‚±˝áx!üºÙ ûàO|Ëfêpùdk¿7@ˆ •BZÖ™v¥⁄%æ—ªá∆Ö¸Í)‡?∏gËzúÿ'eDÅ<
tΩ¿y'≈¿Wàîæ …}7˙›H‰ª≥±jb—ø1{±Íø»CTäà±åÛËTˆP{i-rÍv.†N.ÑD≈–ß–˜Ú8∫Ä'–Ö<ëv£ø˝U<I©zp^J-0»Î–œ2îo®:j;Í»7aßEË-˙´¬˘’Y•_MKß¥´ÈÔ
Á®-ˇAˇÑô2QœŸ˘6väiÍH{è&¿ø4˙◊{t≤FQ‡Båpôtf4zá Oˇ;To SEB6El¡qÔBNä∏c”“I^îrÕï–Ìå÷•ﬁõh|Uµ*‡Œﬂ3Ù¿8Åßw8Õ©öîßêèKhO£<]˛⁄ìfÛÃú$^öï∏î˛Ofıtöë$ÓMèº¸û*§ÓS≤Áíbgﬂ!*Êa¶'˙a∑°¥o5`ód≠¢i€?\*˚‘äÖ†≥Ó(]ÉŸQGLÙ≥áΩií5Ëe._Æ;A√Y‡ƒÊ|ˆπlˆ›fç˝ÈÕ°tÚ©öÃ}∑p|YY|é,†S¿∫Ô=«HßPw±
∏˙°\|éxˆ∫Rr>é¸YJ~PrÍ?¥Î‘)~∏éÑÓåÔ¿9„·By.FÃs?Ê˝ç(«‰ Ñ'¬/]î¡Ó¥£ „"YœìÈc
È|,\Äè]E˘w#œFV,¯?PK
     A ø:ˆo  4     org/gradle/wrapper/Logger.classÖìko“`«ˇóUncå·@ÿ&s*]7ºã11$KHí∞`≤wœ ìÆ≥¥¨ç_≈O°Fg‚?Ä xûRé5K””ÁrŒˇw.ÈÔ??h†G∑b∏Ç€1TPç£Ü∫4w§π+Õ∂U¡éÇ]ÜË…ÿ.;`XxfXÜ˚ú!R9®ˆË”≤˚Ç!›1,Òj<8Œ>?4Èdπck‹Ïq«ê{ˇ0‚#Üb«vtUwxﬂÍáá¬Q;∂Æß…6mù!WÈÛ˜\5π•´]◊1,Ω)Å @åF\˜s©ÆÀµw/˘–'.Hq´œ∞3´◊:‚NWúåÖ•âfuÊ‚ÖÁ-Ce"⁄ËÑ!«–‘l∑U£#ó;≤õm"x©*≠@o¶—€bàwÌ±£â=CïòÙj[∆$ëB#âí
Ó%q<L‚rIXö'“<%N`◊ñŒ¯ØèÖF	Æ\îÂ\ëcòÒÔ~πb@ˆò¢rìJ[}C#qi0Ç®êÏ«4Õ°‹ôÉzŸ|Êw/Ô˛\L~⁄ÍsW(”ﬂ5öﬁeŸN˙S¢¥Naëlöv{—ƒk?¿j≈Ô}°]Kd&{¨íJoÁyìZVRï∆â‰|Õ}_3]˚Ü–'ƒø"\?ED
ágÑãPP¢ı˙åpz*ú¶ìUÃ{QLÊ[¿5ü–Û	ô	!1!Dﬂ÷>ücîâ±I![3åÃîë°Jgå¥«XÛ&’°ov¬HIFiÌÛî
Q™§V˜(µIÿîíı)rµé/á,Æ”*¸èúÒ»Â‡ÍäßPÊπ*qw(§P›&n¸_›ñ7€õPK
     A È`òé  Ô  8   org/gradle/wrapper/PathAssembler$LocalDistribution.classïQ€J√@=õ§ç≠—÷xø+¯P´ﬂAA(*(Çæm€•›ì∫M’œRP¸ ?Jú›±*à/3sfÊÃúŸ}{y∞é˘,Rœ¿¡Ñ6ì.¶]Ã0∏UŸJ.dìa∞‘‡7<êq∞/C±Ÿ-ÌI≈êﬁíëL∂ÊΩMΩh˘å¡Ÿç´Ç!Wíë8l_ïÖ:ÂÂê2~)Æå+©q7È$uŸb2µ=Zßdπù»8b¢H®›ê∑ZÇZ6J±™5≈´°no6Ö
éyRﬂ°˙SK?Ü–~M$_SÊú|a˘˚≠YÍ£W–à¿I‹V—~œí5ÕÛê¡¨á>∏“p]Ã1¨ˇ_	1*B’Ç£rCTª†_q·ØiX§OL—œZµä|-àºF˙≤d˚	ùSáM>W|+Æ<¡*Æ>¡~0Tœ–≤u≤íh‚îYË–&“„ôâÙBãb√›5y]Ka›Oõ‰µËu∫F~%€ﬂ…wøê-å;Ü<y}™É)“ï˘ PK
     A †·∂;  +  &   org/gradle/wrapper/PathAssembler.classïVÈ’=c-#À„≈I∞±≈	±,…I	î8§D∂â,;ıFù ŒHÀìH3bñƒÈN	k-˚RJ˜ñÓ¶%Rä|Ôﬂ‘ÚÎΩ3c…6rÅ/oÓ{sﬂ=ÁûwÁŒ˚˜ß~‡8>
„VZGëá’0T\ìuÖáe/Î<©àx<å6¨ä¡ñÇ≈O;åÆÚÚ5÷D\£ﬂ„[¯vﬂaá8æ¬˜¬¯>û„~¿÷ì"nÛ©0˙Ò4œàxVƒs!<∆ ~¬èÿ˘^‰@?fÎ'"^
·e6_	·’^·uˆCƒõnõ“Ûri\5-CÕŸñ™k§å¶)∆XI6M≈∞ˇÏÏôÒ©âÂÖπâŸÂ…ôÏƒÚ‹¸lf˙¨Ä»‘e˘™ú*…Z15G¥‚®Äˆ1]3-Y≥Âí≠Ë8?;snblææ´£h»Öí≤`*∆§^f7å™ßTK
ÖË™˙e%oç´ç∫q]@î™©÷ic€Ω∑œÜ¯«ÙEÌúR5e⁄.Ác^Œï¶Àπ. Ü so—o≠™î‰¿înS.≥‘5CÆT#u^∂VœêeÚ4àWgQ±∂Kµk∂Ôa˜IB¨®E€êŸwtËsé|Ê,XŒ¸÷(öÜi
( îìMeZfçC
ÎömÜÆ≥¥ÓL‰4Û¨jE¿LÏ≥˚%ÚlR¢mî&esï,“–µé6Ai∫πΩ¨ò¶\T∆’¢bZ˙]'S…€Üj]Oe∑æ&ˇ@Ó∫≈Ö€r1-@†˜nâ:±ñW*û>A”Å Ñ9KŒ_… Ø(:•¨_U&÷,E3Ÿ˝ö£ñ@Í“–´W√/M±R≥ô]$`yåRΩﬁ7Ω)xÖ @ƒ[¬7MáÊ»¿Ó5æ?ü1mú”m#Ø"˙∂≤·FÒ∂ÑØ‚>	'qüàüJH„	ÒàÑá1-a—∑ø5ºÑü·]	2r‘vRI€j©†~Œ>ø¿/IôîÑ_Òløñ∂~ãwˇÚïœ1Nâ¯ùÑﬂ„=êê≈¥ _v¸Ñà?J¯˛,·/¯´Ñøa]@∑√ÆL1Siµò—,•»‘ﬁgáQ¸ùi˝C¿û&e †∑±:kkñZV∂ºÏ”ÌR!™ÈVtï™6™j€ä∫u3¬±?†¥…∏â™ÑnI¯'ß]c∏ËÁ•Mùngoï!6®Xº¶I5 Âp2J%UÕ®≠]—Ùké:ˇ¢›Ê39nò€ñÊº‚ˆ≈∏+~¡ÔóBƒÜvËûç/Ì‘\w¨i°ÔtÊî)Ü“
Üø–gÔU71KﬂÃ‰p”ﬁø-–¢˚Qs9zó√M4'9K∫LƒDS^QU¿ÅÊﬂsCiÎú‚˛ü~‰ˆäåÛKÃ°cªßøkCqWp{ö?6ƒ]-hW
≤E·±ãiN:X–Ç±åª≤7ñiz<ÒfÕΩ±2øjË◊∏:Z∂—%Ä»îµôŸÑ;Âﬂj⁄πÕV∫/ñiéÀçﬂ+Âq[.ô;‚π<:taúE¢{—1∫ç˘—ÉªqÓ°Y4øwÀ|ntdG∏◊—S§w‘OhºüfK‰„£ggº!û∏âñxÚ&|Ô;õO;€¸4†Ò ZEAçV¢Ó6<Ä3Äc1å‡X‘BvcÃß0p#û®¬_C O÷úé'jO˙7Z‚W≠5Ñ7–∂TÉD≥ˆ*:"ù4Ù¯i®¢´Ü€N6}#€|˜lÛu¨dcSp›K=Åû`{◊Îπı"H„ Â#÷CÿO¢éëÑkH:9N∫úÎ9ﬁ¿8&(£V∫û>H"∑–.g…Ú—ﬁ2˘ü ù∆»;C
(éÑsd…ì˛(û&ÕX”¡8Ùﬂ¬æ*ˆ◊p˚t#ó˛∞KøA7LO‡.=Ê–ãªaÍÙ*Çc1Q¶w;¶z-¸œºG˚xÁH§Áz≥x«tí–˙6–ø‰'Rj8ÿu§äËzvKë√tVG>q"¢€Ú!ä◊êÔœ–]>ç.J}Äê6Ûªõ$¢38O¯m$—◊1K{ì=áy'õë:˚,8Ï…B»âÑ”¬cèıe⁄…%◊ùà‹Y≈—˚˚ﬁA ±ûıU1»˘∂îÎ9:∏áe
Ì¥øQÆ›u¥n|√A…c	…√˝⁄È∂ƒW˜	⁄…1{IßX6…GsÙt?Å'◊ì˝˛KU5–˜Q∆†îüDvQN °qZΩuΩxèF {±ÏìDsÒ9\Z!¸óò];<:œSÓT"BÑío!ˇ -Îâ»p}Ê[ÁSÛ )2Be‰‘TjÛs∏ÎìÑ/ÿ#˛(—ct`ó¬˚\ú:·S»◊à8t¥”˚ÇSú
æ‚î'˝)Õ„h˝PK
     A ÑÕÎ¬  |	  0   org/gradle/wrapper/SystemPropertiesHandler.classçV›SUˇ]í∞!,-–“ã-·3≠äTR∞ñâÚ%A(ı£.aõ,Ñ›∏Ÿî‚W˝~Ïì„L}Õ¡«ô˙í2c«Wˇ§⁄±˛Ó&$§µ9˜‹s~Á‹sÁﬁõ˝˚ﬂ?˛"æ†Q‘ ¿ﬁP0ÄOc(xSNﬁí⁄îÇi3
fh@‘è99æ-≈ºÒ T,H¯;ıXƒR=.‚äÀrë∏Ç´~º¿{x_ä§∏&—÷cöÇÅÊ¯r|!:}mn~vé":ªB„‘övCß53é;∂a&#„ñôu4”Y‘“9]†ˆÇaŒòÄ'‘≥(‡∑Vi=<eò˙LncE∑¥ï¥.ìY	-Ω®ŸÜúç^'ed˙ß,;N⁄⁄jZo⁄Z&£€·¯V÷—7Êlã«–≥ìöI∑Õé$uß“+p2T(◊∞¬FZèÙ¶9«Háßµ„¸Ü…mË⁄Ü@∞339ß‡"L∞∞ñí?6Ωô–3éaôÙy÷ı-&“ÏdnC7ùréfW÷ÙÑC‘°L©.ôûÜÚ“Íãà-V&Ÿ™,5êŸ∑≥÷}ÓΩG§£å”≠Ãc^á ^8ÿ»Éñ1Ÿ‹∏£%÷·ÊQêP∞™Ä uÅ∫∏ë45'g3ÙÈ\?ÛzÅ∏ï≥zÅ§é't|PÜ™xßöˆ÷ô‘≤)Æ•"âî¿—j	¥=°Õ2ù°bÎ*“2Òë*˝hﬂ´z>g:∆ÜæœŸVπ•K9#Ω™€]Q€∂ÏŒÕînv¶-mïæŒΩÜv^g-£*6`Ja©»‡#Yê≠"GAN≈l™∏âîä-|,–˚Ï˜Ég+[Ú*¯D≈ß¯L≈Á∏•‚|©‚+|≠‚|+–Xyvy )†Ó'1MnƒB ∂6ãw{/(ÊË∂ÊX,£÷(~>WŸπ ##Ié¿±=◊˛õ(æD⁄  WFÓŸ$v t$ı0;©¿/Ë”~«*òx§BÅDÙV©`™
-n˝µ|/‚∫#∑øˇé–)„⁄≈¯çy≠e«§2FIiŸ˝&—^” ´,=Açï5Ú≤ÒŸ∂ùÏí·æ¥T„ëm™MÎfRÿµ/}6∑í-∆∑ÑbU	Ò$eÒg˛áËRevX‡|¯3%¿ÛÚ_‡π°~äcg5hÁO»WÇÚ-aéÇ£Ø˜ƒÔ.§õ≤÷5¢T Ù†óc˙–OÉ≈_	¸∂ãöÂ{LıÊ·˝ææªª—P;Ωeôô˝3˝y‘ÒÿÜ:‚ïJ–{ù3ªPów—@Ù°Ê√y42ESÕ˜p‰~Gw–"03∞ÉVÅ;∏L•M`ƒÙÊq¨π=èÁÓ†ø4È»„¯à/Ë£ˆZ˙Ç>◊uÇﬁúÙ`i˚—Nﬂ]x»G7Y¯ Œ∫c√A=∑#7?è£î«·«	∆I4πlv1Í4˝›$ ƒ®nºÃqò≥R!9KÄMœ-≤zõô¿9¸B‘Ørâú‰W )¥5»"Ë Ó,µ€Ï 9z|å~Ö_=/±í »!é~¸LÎ0õƒ˜8èWI˛H±-_Ñ⁄˜{…ˇM
F1µW¡U>ÖÀ
Ø=ÄˇíÇ˙éá®SpÒL<`¶◊›ñ_bÜqWª¸PK
     A ™=©∞  ?  -   org/gradle/wrapper/WrapperConfiguration.classçìmOA«g°Ù⁄„JKü|i·§

"	HULCﬂê-úÂHπíª´&~*M$&æ¯°å3wîeõò&3≥3Ûü˝ÌÓıœﬂ_ø†À:§¿“‡aÊí`@EÉG	xL·<ô2O»<%≥®¡íœéxN£8mó¡PÌàÊñk÷ˆ÷÷3›ı5Ó€≤QOãªM´é5∑)˜ΩÁ¡!ÉBw™~»+ÛıŒ1Ì´sM¢(Íç/;Æ¨0Ë/ïwƒ^¥∞ûÆ9Æ˝Æs‹∞Ωº—
˜nÔÛ÷˜Zãd,8t|ÂZ€kZMè¥lÎã«ONlœ⁄ç¸ã∂˚…iv<N,àõn⁄¡˙•ìgJe˘Ïi_n.]Ó!÷ú4*:Z˛l‹Âk ˘™ÊBÈjØjttWÚå(;"ıv]¯àﬂ≥§£Í„ŸsË~˜"™D√EE,ÍÌé∑oøtËÓGU<Kß1†◊å+ÖÊ¨˙æ}åœÁ·’ø⁄Z]ØU˜∂Î’≠Ω◊õo´d`ò¡òB∫·˙oµ§Œ2Ùï˘daÿÄ<ôô!Hê£)Sˇ˘U «≈#l6éÏ˝ &Øí¬ˇW˙h"F}Ñ˙¨9·Û¬BüFÁG;Ç´]Ã3Ù7Õü¿Ãlˇ)ƒÃl¸¥0NÑqÚ{(E[Ñ¥yàa§„êfã0Ü?@†p\áËF∑ƒ&z™ò?@ˇv>,.‚ÅsÒm‚ÏÓ£ns˙Ù=ÃN†ÊN8°uâ	—Ω–∆ÿq$&ÉL*AÓ¬=HL)£∆ÏBCO*A4dF	r_¢… s®©Ù …
ê)%»†2Ø)©AeêE‘,ı …	ê≤$!É<WÇòjêÑ≤äöµ y2≠I  U%»5HRŸ@Õõ 2jfˇPK
     A G¸®	    (   org/gradle/wrapper/WrapperExecutor.classïW˜Áˇû-˘‰„X2l∆Äêl+§ÿò‚÷Cµlà!≠9Kg˚@÷)ß‡ö—“t§+möêÓt–ôòl7°⁄tÔΩ˚g‰”ˆyﬁ;§ì8(˝AÔzû˜˚ÏÁ=ΩÚÔ_∞ˇíÒàåGCxLAﬁ*„m
Ç8ß@¬€˘‰qÔ·ù2ﬁ•‡ﬁ≠†O(òás2ﬁ£`!Œ’Á{yxÔÁã‡·I¶~0ÑÒ¸ü|òWOáœÁyx6Ñè¸Q&åW·<íáOÖœüÊ·32>¬ÁXÅÃ˛yw„¨‚yı%^}9ÑØ∞˙œ3√2¶y~û…O»∏®`;æ ‰Ø)H„É^V0ÉYWı^î–∞ø;98–›14ÿ›ﬂ724–3íËOtK˜◊NjÌ-;ﬁû¥-#;æ[¬¸N3õ∑µ¨}HÀt	çe ˚í]Ñrbbﬂ‡Aqy1ypﬂ»ñm€GíCΩñÈNå$˚∫*=î
8%gô9›≤=/a©£z¡62Ìâ‚9©ø†ƒu¿»ê˛N√lÁ=q‘§ÃÏò1.aCèiç∑è[Z:£∑ü≤¥›k?ÏÃùÇß`i∂afÈR›òiëú„z ﬁoX4ö÷îÑ≠—r€!vù÷S∫F`ÅN3Mö-Ï1≤z_arT∑µQ÷5‹c¶¥Ã!Õ2xÔ≤›Æ\Ú)È·&*ùü¥µ‘â^-Áﬁ´Ÿcd{ØÑıZ˙ªn√!	]´˜$E◊Èîûs=∞'r|Àùô∏4gÈ9Õ“˜yJ¨—ÉYÜÑE—éÄ¨n∑ts@Úf¡JïBU¢(EÚ2Ê»DK◊““≤2t!cjÈÑ'-BFñY◊&ãvê—›Ÿ\¡véwÀ¯ÜåódºLÓ◊mØz§ùî^B<˙ˇdâ¨ê)G£Go..?§n.∂L∆ó÷aö6ÈßÂz5∂K≥l›q
h÷8Y[Á#Éî0H	M∑(a…®˛- ¬W
ê√v–ú$õÁë˚‹`Pm¨ãﬁ¨‹?}U∑bß˙4FŸ·sÔNë“˙òV»‹Ë\;ÔÈà/T»“,P°ß©(éHûdHW)Ø(±MÀÓ5Úyb-Ÿ´$E;µ∏§¢"6≤	Õˇªv»
o±JàV;€6wª±‘ÓT‚õ$⁄Ø∫ôˆ-ÜT|ﬂ°∆]≤y†êµçIΩXjZ]ù"%»)Yø6ø>í6iõ5Ìà~ö™g#ïM	´î;ïäÔ‚{,Ì5ü;¨Ø√ÎU¿kUD∑
çu=Ç£*Æ„˚$$Ì)’-Ø´¯^Që«I?dIe	ÕûPÒ#Ê¯1ÎΩƒ‰ÑF/Q≤0©‚'∆i?e6ı!#ó§(ËéÑü1ıÁe¯L¯%Í|∫%y∞”,d“¬K‹¢"ß|jôì¬°ŸSøRqåm˝5ˇøUÒ;^˝G©Q•ÀöhÜ&üÖ}#Y‹éIØß7w<}èE¸A≈Ò'ÊL«QQÒW¸M∆ﬂU¸ˇî∞ØœåàDèú2Ïâ»	} âx>ßßå1COGå¨Ø)7rÉíaÖW°‰T÷÷N{¸RÁ”ìÀ|88aôßú˜´ƒ€ÔAXTY¨÷¯æoe›Çzfuî«ë¥y±•∫Æ°ÁtR≥˝{Ö∑ª:âÌﬂvÍ˝:…ZòØ|`GÀ_8Ê™´xÜ8Û®ä£æ¢ÍÚ~Ãïú£7Û:ßÀ+xãµ@§¸-I
›:b‰qJﬁªq(∏Kq6±€∑ﬂb§Öj	&ôö–˘òœÔ};dmß?JﬂpıEˆ§ìõ)∫@a⁄¶®É≈ïf¸hr%íïQﬂÊ¶2&€‘xÎgìlLø->lD⁄‹È◊¡M6¯uFøgñÙ €¬∫ﬂèä
C±ö˛!Ã£Bµh¿^‹Gª◊–Æ
õhøœ≥_F˚œ~Ì;=˚U¥ﬂÔŸ7”æÀ≥_ã0∑kZáπcãôz8ÕÛIvzâ≥èvù®°–0ixU√±pı,sœ¢fÚ¥ÄÎß—a\áç™s	o–µ(éC¥÷ÿBœb˘já√J‡%ÃÆé%Ø@ù≈¸´,,V.£Z»X@3#å8ö–Êë’ÍöëºRMÙ`:B•˚ÈBÄN¶c≥X@¿	x—e,éµ^F8øå∫8isO∆[Ø`IÏQfQ?É•b^∆”ñœ¢açŒŸ
Á¨Iú≠tŒV9gwëá"3XÌ6;ákcãs∂÷9['Œ÷_@cüp√«qvC€,bW/í˛<Ögu–ÅE4n"k÷–ˇ≈ÕXBˇôËe€(¶€âr≈}Ó«NLb≈n∫øóˆ‡<Ó≈ˇÑpaÄˆKqáÖKßÈ∆0 VÏHI¨8C™ÑKó¢Í?RM¡ìQ%”øVö£t Ø<çZã0´hn!Á≈{»£≠◊9o(g.°nmt≤ërgÌ”ÒRH√"2ùÑ∏¸	—LÚéD∆rı
‚.<Ä7í^¨M“´hñ…Ó7—.@ß#ƒ}¨®…‚"·¶læ%ﬁ4ã-áÁp˜∞Xnù≈∂ ÃÍ%˙PG
î2kµ´ÇõYuô
Ë∏2ü&"[≤r€á…˜Ù∆[g∞É~;/@È„πM¥ñd’ÂÆ¢‘‰T≠•P, IaíUOs#ÕM‰\÷#"t[Èf8Ø80å¥£HyCTœ!‚¯»HsàÙö¢∫cÙ£/∑∑–Ã÷ÖúT‹UY««<πê0√ΩﬂÓﬁÚ˝ À„ûÀ¡‚Â„8·˙*C9ˆ≠éÙ›ªmÒ å=ãHN@Nêè3XLπÃà[ù[≈\mRH	#SdL9<HwR€"áäàù>æ\ˆ∏Ÿä≈• l•9OÜäC(à. H']§ÑTÌ µ˙!Ÿû ﬁåƒ´S¥™òß]ÃÁhµDLÖ≥yW†!p5ÅÈ÷k∂NØ<è⁄XúzZ*%q3aÅ0LQwxà|qÜ,8ãÂxòíÈ¢?ÊÒcKQóñ¢.-Æ.ºö"ˆc#ﬁLgëd
™_EX∆ô`-qù-z3AiÃ∑öD#ª7Ë6≤· ◊˛ç∂^·ó«=n*Í“‰Í"·-Çˇ·ˇPK
     A            	          ÌA    META-INF/PK
     A m±>=@   ?              §Å)   META-INF/MANIFEST.MFPK
     A                      ÌAõ   org/PK
     A                      ÌAø   org/gradle/PK
     A                      ÌAÍ   org/gradle/wrapper/PK
     A Pr∫ô´	  -  *           §Å  org/gradle/wrapper/GradleWrapperMain.classPK
     A €∆.q/   3   #           §Å  gradle-wrapper-classpath.propertiesPK
     A            )           §ÅÄ  gradle-wrapper-parameter-names.propertiesPK
     A                      ÌA…  org/gradle/cli/PK
     A ’‹?Æ<  S  1           §Å¯  org/gradle/cli/AbstractCommandLineConverter.classPK
     A ◊Éµ≥X  Ï
  ;           §ÅÉ  org/gradle/cli/AbstractPropertiesCommandLineConverter.classPK
     A }≠ŒyG  K  1           §Å4  org/gradle/cli/CommandLineArgumentException.classPK
     A ≥ﬂ‚˙  g  )           §Å   org/gradle/cli/CommandLineConverter.classPK
     A Sf
’  g  &           §Å*  org/gradle/cli/CommandLineOption.classPK
     A ¸ÌäØ•   Â   (           §Åp  org/gradle/cli/CommandLineParser$1.classPK
     A $f{K  ø	  ;           §Å[  org/gradle/cli/CommandLineParser$AfterFirstSubCommand.classPK
     A •D£¢  &  3           §Åˇ   org/gradle/cli/CommandLineParser$AfterOptions.classPK
     A åãM¸  u  <           §ÅÚ#  org/gradle/cli/CommandLineParser$BeforeFirstSubCommand.classPK
     A ¥*´ZM  Ô  F           §ÅH(  org/gradle/cli/CommandLineParser$CaseInsensitiveStringComparator.classPK
     A |ÏRŒ–  &  =           §Å˘*  org/gradle/cli/CommandLineParser$KnownOptionParserState.classPK
     A $ƒæ¢•  Ù  <           §Å$2  org/gradle/cli/CommandLineParser$MissingOptionArgState.classPK
     A TK>™  ƒ  =           §Å#5  org/gradle/cli/CommandLineParser$OptionAwareParserState.classPK
     A ò%‡Ãª  ™  7           §Å(8  org/gradle/cli/CommandLineParser$OptionComparator.classPK
     A ‰fCòß  £  8           §Å8;  org/gradle/cli/CommandLineParser$OptionParserState.classPK
     A ¢∆˜E´  ∂  3           §Å5=  org/gradle/cli/CommandLineParser$OptionString.classPK
     A gAq≤î  x  =           §Å1@  org/gradle/cli/CommandLineParser$OptionStringComparator.classPK
     A `M~U  ∏  2           §Å C  org/gradle/cli/CommandLineParser$ParserState.classPK
     A pÕX›  k  ?           §ÅtE  org/gradle/cli/CommandLineParser$UnknownOptionParserState.classPK
     A £=  l)  &           §ÅÆH  org/gradle/cli/CommandLineParser.classPK
     A ãÂ>…     &           §Å[  org/gradle/cli/ParsedCommandLine.classPK
     A yﬂt⁄  E  ,           §Åc  org/gradle/cli/ParsedCommandLineOption.classPK
     A \v∆B|    :           §Å9f  org/gradle/cli/ProjectPropertiesCommandLineConverter.classPK
     A 
œ8=|  ¸  9           §Åh  org/gradle/cli/SystemPropertiesCommandLineConverter.classPK
     A                      ÌA‡i  org/gradle/util/PK
     A                      ÌAj  org/gradle/util/internal/PK
     A ˛° ˙  '  &           §ÅIj  org/gradle/util/internal/ZipSlip.classPK
     A ï%”¶π    /           §Åám  org/gradle/wrapper/BootstrapMainStarter$1.classPK
     A i,´  $
  -           §Åço  org/gradle/wrapper/BootstrapMainStarter.classPK
     A hQ˛}¢   “   #           §Å˜t  org/gradle/wrapper/Download$1.classPK
     A y¥[¿4  ÿ  A           §Å⁄u  org/gradle/wrapper/Download$DefaultDownloadProgressListener.classPK
     A ûÇ≠€°  ~  4           §Åmz  org/gradle/wrapper/Download$ProxyAuthenticator.classPK
     A èpOÃ)  ®&  !           §Å`~  org/gradle/wrapper/Download.classPK
     A yÅL¢°       1           §Å»ê  org/gradle/wrapper/DownloadProgressListener.classPK
     A !9|∂  Ñ  3           §Å∏ë  org/gradle/wrapper/ExclusiveFileAccessManager.classPK
     A êÏÑ,y  Ü  -           §Åøò  org/gradle/wrapper/GradleUserHomeLookup.classPK
     A ˙‚Ê™   €   "           §ÅÉõ  org/gradle/wrapper/IDownload.classPK
     A ˇ%≤V  Ü  "           §Åmú  org/gradle/wrapper/Install$1.classPK
     A —ÂQÍ{    -           §Å•  org/gradle/wrapper/Install$InstallCheck.classPK
     A ∫›Ä4÷  -              §Å…ß  org/gradle/wrapper/Install.classPK
     A ø:ˆo  4             §Å›º  org/gradle/wrapper/Logger.classPK
     A È`òé  Ô  8           §Åâø  org/gradle/wrapper/PathAssembler$LocalDistribution.classPK
     A †·∂;  +  &           §Åm¡  org/gradle/wrapper/PathAssembler.classPK
     A ÑÕÎ¬  |	  0           §Åµ»  org/gradle/wrapper/SystemPropertiesHandler.classPK
     A ™=©∞  ?  -           §Å≈Õ  org/gradle/wrapper/WrapperConfiguration.classPK
     A G¸®	    (           §Å¿–  org/gradle/wrapper/WrapperExecutor.classPK    7 7 #  ⁄    
===== ./common/common-kotlin/common-api/common-api-multitenant/gradle/wrapper/gradle-wrapper.properties =====
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-7.5.1-bin.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

===== ./common/common-kotlin/common-api/common-api-multitenant/README.md =====
## Micronaut 3.7.5 Documentation

- [User Guide](https://docs.micronaut.io/3.7.5/guide/index.html)
- [API Reference](https://docs.micronaut.io/3.7.5/api/index.html)
- [Configuration Reference](https://docs.micronaut.io/3.7.5/guide/configurationreference.html)
- [Micronaut Guides](https://guides.micronaut.io/index.html)

---

- [Shadow Gradle Plugin](https://plugins.gradle.org/plugin/com.github.johnrengelman.shadow)

## Feature serialization-jackson documentation

- [Micronaut Serialization Jackson Core documentation](https://micronaut-projects.github.io/micronaut-serialization/latest/guide/)

## Feature hibernate-jpa documentation

- [Micronaut Hibernate JPA documentation](https://micronaut-projects.github.io/micronaut-sql/latest/guide/index.html#hibernate)

## Feature jdbc-hikari documentation

- [Micronaut Hikari JDBC Connection Pool documentation](https://micronaut-projects.github.io/micronaut-sql/latest/guide/index.html#jdbc)

## Feature http-client documentation

- [Micronaut HTTP Client documentation](https://docs.micronaut.io/latest/guide/index.html#httpClient)



===== ./common/common-kotlin/common-api/common-api-multitenant/build.gradle.kts =====
plugins {
   alias(libs.plugins.jvm)
   alias(libs.plugins.kapt)
   alias(libs.plugins.allopen)
   alias(libs.plugins.jpa)
   alias(libs.plugins.shadow)
   alias(libs.plugins.application)
    //alias(libs.plugins.dockerCompose)
}

repositories {
    mavenCentral()
}

configureIntegTest()

dependencies {
    api(project(":common:common-kotlin:common-api:common-api"))
    api(project(":common:common-kotlin:common-api:common-api-db"))
    api(project(":common:common-kotlin:common-api:common-api-json"))
    api(project(":common:common-kotlin:common-api:common-api-model"))
    api(project(":common:common-kotlin:common-api:common-api-security"))
    testImplementation(project(":common:common-kotlin:common-api:common-api-test"))

    implementation(platform("io.micronaut.platform:micronaut-platform"))
    implementation(platform("aws.sdk.kotlin:bom:1.4.92"))
    kapt(annotationProcessorLibs.bundles.commonAnnotationProcessors)
    implementation(libs.bundles.commonLibs)
    implementation(libs.bundles.dbLibs)
    implementation(libs.bundles.webServiceLibs)
    implementation(libs.bundles.securityLibs)

    runtimeOnly(runTimeLibs.bundles.commonRuntimeLibs)
    runtimeOnly(runTimeLibs.bundles.securityRuntimeLibs)
    runtimeOnly(runTimeLibs.bundles.dbRuntimeLibs)

    compileOnly(libs.bundles.compileOnlyLibs)

    testImplementation(testLibs.bundles.testImplementationLibs) {
        exclude(group = "org.slf4j", module = "slf4j-api")
    }
}

application {
    mainClass.set("net.blugrid.api.ApplicationKt")
}
java {
    sourceCompatibility = JavaVersion.toVersion("17")
}
kapt {
    arguments {
        arg("micronaut.openapi.project.dir", projectDir.toString())
    }
}
kotlin {
    jvmToolchain {
        languageVersion.set(JavaLanguageVersion.of(17))
    }
}

graalvmNative.toolchainDetection = false
micronaut {
    runtime("netty")
    testRuntime("junit5")
    processing {
        incremental(true)
        annotations("net.blugrid.api.*")
    }
}

fun Project.configureIntegTest() {
    sourceSets {
        create("integTest") {
            compileClasspath += sourceSets.main.get().output
            runtimeClasspath += sourceSets.main.get().output
        }
    }

    val integTestImplementation by configurations.getting {
        extendsFrom(configurations.implementation.get())
        extendsFrom(configurations.testImplementation.get())
    }

    configurations["integTestRuntimeOnly"].extendsFrom(configurations.runtimeOnly.get())

    dependencies.add("kaptIntegTest", "io.micronaut:micronaut-inject-java")
    dependencies.add("integTestImplementation", "io.micronaut.test:micronaut-test-junit5")

    tasks.register<Test>("integrationTest") {
        group = "verification"
        description = "Runs integration tests against the application."

        testClassesDirs = sourceSets["integTest"].output.classesDirs
        classpath = sourceSets["integTest"].runtimeClasspath

        shouldRunAfter("test")
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/gradle.properties =====
micronautVersion=4.4.3
kotlinVersion=1.9.23

===== ./common/common-kotlin/common-api/common-api-multitenant/micronaut-cli.yml =====
applicationType: default
defaultPackage: example.micronaut
testFramework: junit
sourceLanguage: java
buildTool: gradle
features: [ annotation-api, app-name, data, data-jpa, graalvm, gradle, h2, hibernate-jpa, http-client, jakarta-javax-persistence, java-application, jdbc-hikari, junit, logback, micronaut-build, netty-server, readme, serialization-jackson, shade, spring-boot-java, yaml ]

===== ./common/common-kotlin/common-api/common-api/src/main/kotlin/net/blugrid/api/common/audit/aspect/LogAuditEvent.kt =====
package net.blugrid.api.common.audit.aspect

import io.micronaut.aop.Around
import io.micronaut.context.annotation.AliasFor
import net.blugrid.api.common.model.audit.AuditEventType
import net.blugrid.api.common.model.audit.AuditEventType.CREATE
import java.lang.annotation.Inherited
import kotlin.annotation.AnnotationTarget.CLASS
import kotlin.annotation.AnnotationTarget.FUNCTION


@MustBeDocumented
@Retention(AnnotationRetention.RUNTIME)
@Target(CLASS, FUNCTION)
@Around
annotation class LogAuditEvent(
    @get:AliasFor(annotation = EventType::class, member = "value")
    val eventType: AuditEventType = CREATE,
)

@MustBeDocumented
@Retention(AnnotationRetention.RUNTIME)
@Target(AnnotationTarget.ANNOTATION_CLASS)
@Inherited
annotation class EventType(
    val value: AuditEventType = CREATE,
)
===== ./common/common-kotlin/common-api/common-api/src/main/kotlin/net/blugrid/api/common/audit/aspect/AuditInterceptor.kt =====
package net.blugrid.api.common.audit.aspect

import io.micronaut.aop.InterceptorBean
import io.micronaut.aop.MethodInterceptor
import io.micronaut.aop.MethodInvocationContext
import jakarta.inject.Singleton
import net.blugrid.api.common.audit.service.AuditEventEmitterService
import net.blugrid.api.logging.logger
import net.blugrid.api.common.model.audit.AuditEventType
import net.blugrid.api.common.model.resource.BusinessUnitResource
import net.blugrid.api.common.model.resource.GenericAuditedResource
import net.blugrid.api.common.model.resource.ResourceType
import net.blugrid.api.common.model.resource.TenantResource
import net.blugrid.api.common.model.resource.UnscopedResource
import net.blugrid.api.json.objectToJson

@Singleton
@InterceptorBean(LogAuditEvent::class)
class AuditInterceptor(
    private val eventEmitterService: AuditEventEmitterService
) : MethodInterceptor<Any, Any> {

    private val log = logger()

    override fun intercept(context: MethodInvocationContext<Any, Any>): Any {
        val resource = context.proceed()

        val eventType = context.getEventType()
        val resourceType = getResourceType(resource)
        val tenantId = getTenantId(resource)

        log.trace("Intercepted audit $eventType event for $resourceType resource:  ${objectToJson(resource)}")

        if (resource is GenericAuditedResource<*>) {
            val audit = resource.audit ?: run {
                log.warn("Audit information is null for resource: $resourceType")
                throw IllegalStateException("Missing audit data in resource")
            }

            val sessionId = audit.lastChangedBySessionId ?: run {
                log.warn("Session ID is null for resource: $resourceType")
                throw IllegalStateException("Session ID is null in audit data")
            }

            val version = audit.version
            val lastChangedTimestamp = audit.lastChangedTimestamp ?: run {
                log.warn("LastChangedTimestamp is null for resource: $resourceType")
                throw IllegalStateException("LastChangedTimestamp is null in audit data")
            }

            eventEmitterService.publishEvent(
                eventType = eventType,
                resourceType = resourceType,
                resource = resource,
                resourceId = resource.id,
                tenantId = tenantId,
                sessionId = sessionId,
                version = version,
                localDateTime = lastChangedTimestamp
            )
        } else {
            log.trace("Resource is not of type GenericAuditedResource: $resource")
        }

        return resource
    }

    private fun MethodInvocationContext<Any, Any>.getEventType(): AuditEventType {
        return this.getAnnotation(LogAuditEvent::class.java)
            ?.values
            ?.get("eventType")
            ?.toString()
            ?.let { AuditEventType.valueOf(it) }
            ?: AuditEventType.CREATE
    }

    private fun getResourceType(resource: Any): ResourceType {
        return when (resource) {
            is GenericAuditedResource<*> -> resource.resourceType
            else -> {
                log.warn("Resource is not a GenericAuditedResource: $resource")
                throw IllegalArgumentException("Invalid resource type")
            }
        }
    }

    private fun getTenantId(resource: Any): Long {
        return when (resource) {
            is TenantResource<*> -> resource.permission?.tenantId ?: logAndThrow("TenantResource permission is null")
            is BusinessUnitResource<*> -> resource.permission?.tenantId ?: logAndThrow("BusinessUnitResource permission is null")
            is UnscopedResource<*> -> 1L
            else -> logAndThrow("Unknown resource type for tenantId")
        }
    }

    private fun logAndThrow(message: String): Nothing {
        log.error(message)
        throw IllegalStateException(message)
    }
}

===== ./common/common-kotlin/common-api/common-api/src/main/kotlin/net/blugrid/api/common/audit/service/AuditEventPublisherService.kt =====
package net.blugrid.api.common.audit.service

import io.micronaut.context.event.ApplicationEventPublisher
import jakarta.inject.Singleton
import net.blugrid.api.logging.logger
import net.blugrid.api.common.model.audit.AuditEvent
import net.blugrid.api.common.model.audit.AuditEventType
import net.blugrid.api.common.model.resource.GenericAuditedResource
import net.blugrid.api.common.model.resource.ResourceType
import java.time.LocalDateTime

interface AuditEventEmitterService {
    fun publishEvent(
        eventType: AuditEventType,
        resourceType: ResourceType,
        resource: GenericAuditedResource<*>,
        resourceId: Long,
        tenantId: Long,
        sessionId: Long,
        version: Int,
        localDateTime: LocalDateTime
    )
}

@Singleton
class AuditEventEmitterServiceImpl(
    private val publisher: ApplicationEventPublisher<AuditEvent>
) : AuditEventEmitterService {

    private val logger = logger()

    override fun publishEvent(
        eventType: AuditEventType,
        resourceType: ResourceType,
        resource: GenericAuditedResource<*>,
        resourceId: Long,
        tenantId: Long,
        sessionId: Long,
        version: Int,
        localDateTime: LocalDateTime
    ) {
        logger.debug("publishing $eventType event for $resourceType id: $resourceId version:$version")
        publisher.publishEvent(
            AuditEvent(
                auditEventType = eventType,
                auditEventTimestamp = localDateTime,
                resourceId = resourceId,
                resourceType = resourceType,
                resource = resource,
                version = version,
                tenantId = tenantId,
                sessionId = sessionId,
            )
        )
    }
}


===== ./common/common-kotlin/common-api/common-api/src/main/kotlin/net/blugrid/api/common/utils/PostgresqlUtils.kt =====
package net.blugrid.api.common.utils

fun List<Any>.toTextArray(): String = this.joinToString(",", "{", "}") { it.toString() }
===== ./common/common-kotlin/common-api/common-api/src/main/kotlin/net/blugrid/api/common/service/GenericCrudServiceImpl.kt =====
package net.blugrid.api.common.service

import io.micronaut.data.model.Page
import io.micronaut.data.model.Pageable
import io.micronaut.transaction.annotation.ReadOnly
import jakarta.inject.Singleton
import jakarta.transaction.Transactional
import net.blugrid.api.common.audit.aspect.LogAuditEvent
import net.blugrid.api.common.exception.NotFoundException
import net.blugrid.api.common.model.audit.AuditEventType.CREATE
import net.blugrid.api.common.model.audit.AuditEventType.UPDATE
import net.blugrid.api.common.model.resource.GenericCreateResource
import net.blugrid.api.common.model.resource.GenericResource
import net.blugrid.api.common.model.resource.GenericUpdateResource
import net.blugrid.api.common.repository.GenericCrudRepository
import net.blugrid.api.common.repository.model.GenericEntity
import net.blugrid.api.common.repository.model.GenericEntityMapper
import java.util.Optional
import java.util.UUID


@Deprecated("Use GenericCommandServiceImpl or GenericQueryServiceImpl instead. This will be removed in the next major release.")
@Singleton
open class GenericCrudServiceImpl<T : GenericResource<T>, U : GenericCreateResource<U>, V : GenericUpdateResource<V>, X : GenericEntity<X>, Y : GenericEntityMapper<T, U, V, X>>(
    private val repository: GenericCrudRepository<X>,
    private val mapper: GenericEntityMapper<T, U, V, X>,
) : GenericCrudService<T, U, V, X, Y> {

    @ReadOnly
    override fun getPage(pageable: Pageable): Page<T> {
        return repository.findAll(pageable)
            .map { it.toResponse() }
    }

    @ReadOnly
    override fun getAll(): List<T> {
        return repository.findAll()
            .map { it.toResponse() }
    }

    @ReadOnly
    override fun getById(id: Long): T {
        return repository.findById(id)
            .orElseThrow { NotFoundException("Entity with id $id not found") }
            .toResponse()
    }

    @ReadOnly
    override fun getByIdOptional(id: Long): Optional<T> {
        return repository.findById(id)
            .map { it.toResponse() }
    }

    @ReadOnly
    override fun getByUuid(uuid: UUID): T {
        return repository.findByUuid(uuid)
            .orElseThrow()
            .toResponse()
    }

    @ReadOnly
    override fun getByUuidOptional(uuid: UUID): Optional<T> {
        return repository.findByUuid(uuid)
            .map { it.toResponse() }
    }

    @Transactional
    @LogAuditEvent(eventType = UPDATE)
    override fun update(id: Long, update: V): T {
        return repository.findById(id)
            .orElseThrow { NotFoundException("Entity with id $id not found") }
            .let {
                repository.update(it.update(update.toEntity()))
                    .toResponse()
            }
    }

    @Transactional
    @LogAuditEvent(eventType = CREATE)
    override fun create(newResource: U): T {
        return repository.saveAndFlush(newResource.toEntity())
            .toResponse()
    }

    @Transactional
    override fun delete(id: Long) {
        getById(id)
        repository.deleteById(id)
    }

    fun U.toEntity(): X {
        return mapper.createToEntity(this)
    }

    fun V.toEntity(): X {
        return mapper.updateToEntity(this)
    }

    fun X.toResponse(): T {
        return mapper.entityToResource(this)
    }
}

===== ./common/common-kotlin/common-api/common-api/src/main/kotlin/net/blugrid/api/common/service/GenericQueryServiceImpl.kt =====
package net.blugrid.api.common.service

import io.micronaut.data.jpa.repository.criteria.Specification
import io.micronaut.data.model.Page
import io.micronaut.data.model.Pageable
import io.micronaut.transaction.annotation.ReadOnly
import net.blugrid.api.common.exception.NotFoundException
import net.blugrid.api.common.model.resource.GenericResource
import net.blugrid.api.common.repository.GenericEntityRepository
import net.blugrid.api.common.repository.model.GenericEntity
import java.util.Optional
import java.util.UUID

open class GenericQueryServiceImpl<
        F,
        T: GenericResource<T>,
        E: GenericEntity<E>
        >(
    private val repository: GenericEntityRepository<E>,
    private val mapper: (E) -> T,
    private val specBuilder: (F) -> Specification<E>
) : GenericQueryService<F, T> {

    @ReadOnly
    override fun getPage(pageable: Pageable): Page<T> {
        return repository.findAll(pageable)
            .map { it.toResponse() }
    }

    @ReadOnly
    override fun getAll(): List<T> {
        return repository.findAll()
            .map { it.toResponse() }
    }

    @ReadOnly
    override fun getById(id: Long): T {
        return repository.findById(id)
            .orElseThrow { NotFoundException("Entity with id $id not found") }
            .toResponse()
    }

    @ReadOnly
    override fun getByIdOptional(id: Long): Optional<T> {
        return repository.findById(id)
            .map { it.toResponse() }
    }

    @ReadOnly
    override fun getByUuid(uuid: UUID): T {
        return repository.findByUuid(uuid)
            .orElseThrow()
            .toResponse()
    }

    @ReadOnly
    override fun getByUuidOptional(uuid: UUID): Optional<T> {
        return repository.findByUuid(uuid)
            .map { it.toResponse() }
    }

    @ReadOnly
    override fun findByFilter(filter: F, pageable: Pageable): Page<T> {
        val spec = specBuilder(filter)
        return repository.findAll(spec, pageable).map(mapper)
    }

    fun E.toResponse(): T {
        return mapper(this)
    }
}

===== ./common/common-kotlin/common-api/common-api/src/main/kotlin/net/blugrid/api/common/service/GenericCommandServiceImpl.kt =====
package net.blugrid.api.common.service

import jakarta.inject.Singleton
import jakarta.transaction.Transactional
import net.blugrid.api.common.audit.aspect.LogAuditEvent
import net.blugrid.api.common.exception.NotFoundException
import net.blugrid.api.common.model.audit.AuditEventType.CREATE
import net.blugrid.api.common.model.audit.AuditEventType.UPDATE
import net.blugrid.api.common.model.resource.GenericCreateResource
import net.blugrid.api.common.model.resource.GenericResource
import net.blugrid.api.common.model.resource.GenericUpdateResource
import net.blugrid.api.common.repository.GenericEntityRepository
import net.blugrid.api.common.repository.model.GenericEntity
import net.blugrid.api.common.repository.model.GenericEntityMapper


@Singleton
open class GenericCommandServiceImpl<T : GenericResource<T>, U : GenericCreateResource<U>, V : GenericUpdateResource<V>, X : GenericEntity<X>, Y : GenericEntityMapper<T, U, V, X>>(
    private val repository: GenericEntityRepository<X>,
    private val mapper: GenericEntityMapper<T, U, V, X>,
) : GenericCommandService<T, U, V, X, Y> {

    @Transactional
    @LogAuditEvent(eventType = UPDATE)
    override fun update(id: Long, update: V): T {
        return repository.findById(id)
            .orElseThrow { NotFoundException("Entity with id $id not found") }
            .let {
                repository.update(it.update(update.toEntity()))
                    .toResponse()
            }
    }

    @Transactional
    @LogAuditEvent(eventType = CREATE)
    override fun create(newResource: U): T {
        return repository.saveAndFlush(newResource.toEntity())
            .toResponse()
    }

    @Transactional
    override fun delete(id: Long) {
        repository.findById(id)
            .orElseThrow { NotFoundException("Entity with id $id not found") }
        repository.deleteById(id)
    }

    fun U.toEntity(): X {
        return mapper.createToEntity(this)
    }

    fun V.toEntity(): X {
        return mapper.updateToEntity(this)
    }

    fun X.toResponse(): T {
        return mapper.entityToResource(this)
    }
}

===== ./common/common-kotlin/common-api/common-api/src/main/kotlin/net/blugrid/api/common/controller/GenericCrudControllerImpl.kt =====
package net.blugrid.api.common.controller

import io.micronaut.data.model.Page
import io.micronaut.data.model.Pageable
import net.blugrid.api.common.model.resource.GenericCreateResource
import net.blugrid.api.common.model.resource.GenericResource
import net.blugrid.api.common.model.resource.GenericUpdateResource
import net.blugrid.api.common.repository.GenericCrudRepository
import net.blugrid.api.common.repository.model.GenericEntity
import net.blugrid.api.common.repository.model.GenericEntityMapper
import net.blugrid.api.common.service.GenericCrudServiceImpl


open class GenericCrudControllerImpl<T : GenericResource<T>, U : GenericCreateResource<U>, V : GenericUpdateResource<V>, X : GenericEntity<X>, Y : GenericEntityMapper<T, U, V, X>>(
    repository: GenericCrudRepository<X>,
    mapper: GenericEntityMapper<T, U, V, X>,
) : GenericCrudController<T, U, V, X, Y> {

    private val service: GenericCrudServiceImpl<T, U, V, X, Y> = GenericCrudServiceImpl(repository, mapper)

    override fun create(created: U): T {
        return service.create(created)
    }

    override fun update(id: Long, updated: V): T {
        return service.update(id, updated)
    }

    override fun getById(id: Long): T {
        return service.getById(id)
    }

    override fun getPage(pageable: Pageable): Page<T> {
        return service.getPage(pageable)
    }

    override fun getAll(): List<T> {
        return service.getAll()
    }

    override fun delete(id: Long) {
        service.delete(id)
    }
}


===== ./common/common-kotlin/common-api/common-api/src/main/kotlin/net/blugrid/api/common/repository/JpaSpecificationDSL.kt =====
package net.blugrid.api.common.repository

import io.micronaut.data.jpa.repository.criteria.Specification
import jakarta.persistence.criteria.CriteriaBuilder
import jakarta.persistence.criteria.Fetch
import jakarta.persistence.criteria.From
import jakarta.persistence.criteria.Join
import jakarta.persistence.criteria.Path
import jakarta.persistence.criteria.Predicate
import jakarta.persistence.criteria.Root
import kotlin.reflect.KProperty1

// Helper to allow joining to Properties
fun <Z, T, R> From<Z, T>.join(prop: KProperty1<T, R?>): Join<T, R> = this.join<T, R>(prop.name)

fun <Z, T, R> From<Z, T>.fetch(prop: KProperty1<T, R?>): Fetch<T, R> = this.fetch<T, R>(prop.name)
fun <Z, T, R> Fetch<Z, T>.fetch(prop: KProperty1<T, R?>): Fetch<T, R> = this.fetch<T, R>(prop.name)

// Helper to enable get by Property
fun <R> Path<*>.get(prop: KProperty1<*, R?>): Path<R> = this.get<R>(prop.name)

// Version of Specification.where that makes the CriteriaBuilder implicit
fun <T> where(makePredicate: CriteriaBuilder.(Root<T>) -> Predicate): Specification<T> =
    Specification { root, _, criteriaBuilder -> criteriaBuilder.makePredicate(root) }

// helper function for defining Specification that take a Path to a property and send it to a CriteriaBuilder
private fun <T, R> KProperty1<T, R?>.spec(makePredicate: CriteriaBuilder.(path: Path<R>) -> Predicate): Specification<T> =
    let { property -> where { root -> makePredicate(root.get(property)) } }

// Equality
fun <T, R> KProperty1<T, R?>.equal(x: R): Specification<T> = spec { equal(it, x) }

fun <T, R> KProperty1<T, R?>.notEqual(x: R): Specification<T> = spec { notEqual(it, x) }

// Ignores empty collection otherwise an empty 'in' predicate will be generated which will never match any results
fun <T, R : Any> KProperty1<T, R?>.`in`(values: Collection<R>): Specification<T> = if (values.isNotEmpty()) spec { path ->
    `in`(path).apply { values.forEach { this.value(it) } }
} else Specification.where(null)

// Comparison
fun <T> KProperty1<T, Number?>.le(x: Number) = spec { le(it, x) }

fun <T> KProperty1<T, Number?>.lt(x: Number) = spec { lt(it, x) }
fun <T> KProperty1<T, Number?>.ge(x: Number) = spec { ge(it, x) }
fun <T> KProperty1<T, Number?>.gt(x: Number) = spec { gt(it, x) }
fun <T, R : Comparable<R>> KProperty1<T, R?>.lessThan(x: R) = spec { lessThan(it, x) }
fun <T, R : Comparable<R>> KProperty1<T, R?>.lessThanOrEqualTo(x: R) = spec { lessThanOrEqualTo(it, x) }
fun <T, R : Comparable<R>> KProperty1<T, R?>.greaterThan(x: R) = spec { greaterThan(it, x) }
fun <T, R : Comparable<R>> KProperty1<T, R?>.greaterThanOrEqualTo(x: R) = spec { greaterThanOrEqualTo(it, x) }
fun <T, R : Comparable<R>> KProperty1<T, R?>.between(x: R, y: R) = spec { between(it, x, y) }

// True/False
fun <T> KProperty1<T, Boolean?>.isTrue() = spec { isTrue(it) }

fun <T> KProperty1<T, Boolean?>.isFalse() = spec { isFalse(it) }

// Null / NotNull
fun <T, R> KProperty1<T, R?>.isNull() = spec { isNull(it) }

fun <T, R> KProperty1<T, R?>.isNotNull() = spec { isNotNull(it) }

// Collections
fun <T, R : Collection<*>> KProperty1<T, R?>.isEmpty() = spec { isEmpty(it) }

fun <T, R : Collection<*>> KProperty1<T, R?>.isNotEmpty() = spec { isNotEmpty(it) }
fun <T, E, R : Collection<E>> KProperty1<T, R?>.isMember(elem: E) = spec { isMember(elem, it) }
fun <T, E, R : Collection<E>> KProperty1<T, R?>.isNotMember(elem: E) = spec { isNotMember(elem, it) }

// Strings
fun <T> KProperty1<T, String?>.like(x: String): Specification<T> = spec { like(it, x) }

fun <T> KProperty1<T, String?>.like(x: String, escapeChar: Char): Specification<T> = spec { like(it, x, escapeChar) }
fun <T> KProperty1<T, String?>.notLike(x: String): Specification<T> = spec { notLike(it, x) }
fun <T> KProperty1<T, String?>.notLike(x: String, escapeChar: Char): Specification<T> = spec { notLike(it, x, escapeChar) }

// And
infix fun <T> Specification<T>.and(other: Specification<T>): Specification<T> = this.and(other)

inline fun <reified T> and(vararg specs: Specification<T>?): Specification<T> {
    return and(specs.toList())
}

inline fun <reified T> and(specs: Iterable<Specification<T>?>): Specification<T> {
    return combineSpecification(specs, Specification<T>::and)
}

// Or
infix fun <T> Specification<T>.or(other: Specification<T>): Specification<T> = this.or(other)

inline fun <reified T> or(vararg specs: Specification<T>?): Specification<T> {
    return or(specs.toList())
}

inline fun <reified T> or(specs: Iterable<Specification<T>?>): Specification<T> {
    return combineSpecification(specs, Specification<T>::or)
}

// Not
operator fun <T> Specification<T>.not(): Specification<T> = Specification.not(this)

// Combines Specification with an operation
inline fun <reified T> combineSpecification(
    specs: Iterable<Specification<T>?>,
    operation: Specification<T>.(Specification<T>) -> Specification<T>
): Specification<T> {
    return specs.filterNotNull().fold(emptySpecification()) { existing, new -> existing.operation(new) }
}

// Empty Specification
inline fun <reified T> emptySpecification(): Specification<T> = Specification.where(null)

// fetch

===== ./common/common-kotlin/common-api/common-api/src/main/kotlin/net/blugrid/api/common/repository/GenericCrudRepository.kt =====
package net.blugrid.api.common.repository

import io.micronaut.data.jpa.repository.JpaRepository
import io.micronaut.data.jpa.repository.JpaSpecificationExecutor
import net.blugrid.api.common.repository.model.GenericEntity
import java.util.Optional
import java.util.UUID

@Deprecated("Use GenericEntityRepository instead")
interface GenericCrudRepository<T : GenericEntity<T>> : JpaRepository<T, Long>, JpaSpecificationExecutor<T> {
    fun update(update: T): T

    fun findByUuid(uuid: UUID): Optional<T>
}

===== ./common/common-kotlin/common-api/common-api/src/main/kotlin/net/blugrid/api/common/repository/GenericRepositoryUtils.kt =====
package net.blugrid.api.common.repository

import net.blugrid.api.common.repository.model.GenericEntity

fun <E : GenericEntity<*>, R : GenericCrudRepository<E>> replaceCollection(
    existingEntities: Set<E>,
    incomingEntities: Set<E>,
    repository: R,
): Set<E> {
    // delete entities
    (existingEntities - incomingEntities).takeIf {
        it.isNotEmpty()
    }?.let(
        repository::deleteAll
    )

    // insert new entities
    val newEntities = (incomingEntities - existingEntities).takeIf {
        it.isNotEmpty()
    }?.let {
        repository.saveAll(it)
    }?.toSet() ?: emptySet()

    val unmodifiedEntities = existingEntities intersect incomingEntities

    return (unmodifiedEntities + newEntities)
        .takeIf { it.isNotEmpty() }
        ?: emptySet()
}

===== ./common/common-kotlin/common-api/common-api/src/main/kotlin/net/blugrid/api/common/repository/GenericEntityRepository.kt =====
package net.blugrid.api.common.repository

import io.micronaut.data.jpa.repository.JpaRepository
import io.micronaut.data.jpa.repository.JpaSpecificationExecutor
import net.blugrid.api.common.repository.model.GenericEntity
import java.util.Optional
import java.util.UUID

interface GenericEntityRepository<T : GenericEntity<T>> : JpaRepository<T, Long>, JpaSpecificationExecutor<T> {
    fun update(update: T): T

    fun findByUuid(uuid: UUID): Optional<T>
}

===== ./common/common-kotlin/common-api/common-api/build.gradle.kts =====
plugins {
   alias(libs.plugins.jvm)
   alias(libs.plugins.kapt)
   alias(libs.plugins.allopen)
   alias(libs.plugins.jpa)
   alias(libs.plugins.shadow)
   alias(libs.plugins.application)
}

repositories {
    mavenCentral()
}

dependencies {
    api(project(":common:common-kotlin:common-api:common-api-db"))
    api(project(":common:common-kotlin:common-api:common-api-json"))
    api(project(":common:common-kotlin:common-api:common-api-model"))
    api(project(":common:common-kotlin:common-api:common-api-logging"))
    testImplementation(project(":common:common-kotlin:common-api:common-api-test"))

    implementation(platform("io.micronaut.platform:micronaut-platform"))
    implementation(platform("aws.sdk.kotlin:bom:1.4.92"))
    kapt(annotationProcessorLibs.bundles.commonAnnotationProcessors)
    implementation(libs.bundles.commonLibs)
    implementation(libs.bundles.dbLibs)
    implementation(libs.bundles.webServiceLibs)
    implementation(libs.bundles.securityLibs)

    compileOnly(libs.bundles.compileOnlyLibs)
}

application {
    mainClass.set("net.blugrid.api.ApplicationKt")
}
java {
    sourceCompatibility = JavaVersion.toVersion("17")
}
kapt {
    arguments {
        arg("micronaut.openapi.project.dir", projectDir.toString())
    }
}
kotlin {
    jvmToolchain {
        languageVersion.set(JavaLanguageVersion.of(17))
    }
}

graalvmNative.toolchainDetection = false
micronaut {
    runtime("netty")
    testRuntime("junit5")
    processing {
        incremental(true)
        annotations("net.blugrid.api.*")
    }
}

===== ./common/common-kotlin/common-api/common-api/gradle.properties =====
micronautVersion=4.4.3
kotlinVersion=1.9.23

