===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/db/TenantSequence.kt =====
package net.blugrid.api.db

import jakarta.inject.Singleton
import net.blugrid.api.config.DbProps
import org.hibernate.engine.jdbc.spi.JdbcCoordinator
import org.hibernate.engine.spi.SharedSessionContractImplementor
import java.sql.SQLException

interface TenantSequence {
    fun tenantNextVal(session: SharedSessionContractImplementor, inputName: String, tenantId: Long): Long
}

@Singleton
class TenantSequenceImpl(
    private val DbProps: DbProps,
    private val databaseService: DatabaseService,
) : TenantSequence {

    override fun tenantNextVal(session: SharedSessionContractImplementor, inputName: String, tenantId: Long): Long {
        val jdbcCoordinator = session.jdbcCoordinator
        val defaultSchemaName = DbProps.schema
        val (schemaName, tableName) = parseInputName(inputName, defaultSchemaName)

        // 4. Check if the input_name (including schema) refers to an existing sequence
        if (sequenceExists(jdbcCoordinator, schemaName, tableName)) {
            // If table_name already refers to a sequence, call nextval directly
            return executeNextVal(jdbcCoordinator, inputName)
                .also { jdbcCoordinator.afterStatementExecution() }
        } else {
            // 5. Generate the sequence name based on table and tenant_id
            val isTenantTable = isTenantTable(jdbcCoordinator, tableName)
            val seqName = generateSequenceName(tableName, tenantId, isTenantTable)

            // 7. Check if the sequence already exists
            if (!sequenceExists(jdbcCoordinator, schemaName, seqName)) {
                // 8. If the sequence does not exist, create it with the appropriate settings
                createSequence(jdbcCoordinator, seqName, tenantId, isTenantTable)
            }

            // 11. Use the sequence to get the next ID value
            return executeNextVal(jdbcCoordinator, "$schemaName.$seqName")
                .also { jdbcCoordinator.afterStatementExecution() }
        }
    }

    private fun parseInputName(inputName: String, defaultSchemaName: String): Pair<String, String> {
        val schemaName = inputName.substringBefore('.', defaultSchemaName)
        val tableName = inputName.substringAfter('.', inputName)
        return schemaName to tableName
    }

    private fun sequenceExists(jdbcCoordinator: JdbcCoordinator, schemaName: String, sequenceName: String): Boolean {
        val sql = "SELECT EXISTS(SELECT 1 FROM pg_sequences WHERE schemaname = ? AND sequencename = ?)"
        val params = listOf(schemaName, sequenceName)
        return databaseService.executeQuery(jdbcCoordinator, sql, params).use { rs ->
            rs?.next() == true && rs.getBoolean(1)
        }
    }

    private fun isTenantTable(jdbcCoordinator: JdbcCoordinator, tableName: String): Boolean {
        val sql = "SELECT table_column_exists(?, 'tenant_id') AND ? != 'organisation'"
        val params = listOf(tableName, tableName)
        return databaseService.executeQuery(jdbcCoordinator, sql, params).use { rs ->
            rs?.next() == true && rs.getBoolean(1)
        }
    }

    private fun generateSequenceName(tableName: String, tenantId: Long?, isTenantTable: Boolean): String {
        return if (isTenantTable && tenantId != null) {
            "seq_${tableName}_$tenantId"
        } else {
            "seq_$tableName"
        }
    }

    private fun createSequence(jdbcCoordinator: JdbcCoordinator, seqName: String, tenantId: Long?, isTenantTable: Boolean) {
        val sql: String
        val params: List<Any>

        if (isTenantTable && tenantId != null) {
            val tenantDetails = getTenantSequenceDetails(jdbcCoordinator, tenantId)
            sql = "CREATE SEQUENCE $seqName START WITH ? MINVALUE ? MAXVALUE ?"
            params = listOf(tenantDetails.minId + 1, tenantDetails.minId, tenantDetails.maxId)
        } else {
            sql = "CREATE SEQUENCE $seqName START WITH 1"
            params = emptyList()
        }

        return databaseService.executeUpdate(jdbcCoordinator, sql, params)
    }

    private fun getTenantSequenceDetails(jdbcCoordinator: JdbcCoordinator, tenantId: Long): TenantSequenceDetails {
        val sql = "SELECT min_id + 1 AS min_id, max_id FROM tenant_sequence_details(?)"
        val params = listOf(tenantId)
        return databaseService.executeQuery(jdbcCoordinator, sql, params).use { rs ->
            if (rs?.next() == true) {
                TenantSequenceDetails(rs.getLong("min_id"), rs.getLong("max_id"))
            } else {
                throw SQLException("Failed to fetch tenant sequence details for tenantId: $tenantId")
            }
        }
    }

    private fun executeNextVal(jdbcCoordinator: JdbcCoordinator, sequenceName: String): Long {
        val sql = "SELECT nextval(?)"
        val params = listOf(sequenceName)
        return databaseService.executeQuery(jdbcCoordinator, sql, params).use { rs ->
            if (rs?.next() == true) {
                rs.getLong(1)
            } else {
                throw SQLException("Failed to get next value from sequence: $sequenceName")
            }
        }
    }
}

data class TenantSequenceDetails(val minId: Long, val maxId: Long)

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/db/GlobalTenantSequenceGenerator.kt =====
package net.blugrid.api.db

import net.blugrid.api.logging.logger
import net.blugrid.api.security.context.CurrentRequestContext
import org.hibernate.HibernateException
import org.hibernate.engine.spi.SharedSessionContractImplementor
import org.hibernate.id.IdentifierGenerator
import org.hibernate.id.enhanced.SequenceStyleGenerator
import org.hibernate.service.ServiceRegistry
import org.hibernate.type.Type
import java.io.Serializable
import java.sql.PreparedStatement
import java.sql.SQLException
import java.sql.Types
import java.util.Properties

class GlobalTenantSequenceGenerator : SequenceStyleGenerator(), IdentifierGenerator {

    private val log = logger()

    private lateinit var sequenceName: String

    override fun configure(type: Type, params: Properties, serviceRegistry: ServiceRegistry) {
        super<SequenceStyleGenerator>.configure(type, params, serviceRegistry)
        this.sequenceName = params.getProperty("target_table")
            .removePrefix("vw_")
            .removeSuffix("_##scope_option##")
    }

    override fun generate(session: SharedSessionContractImplementor, entity: Any?): Serializable {
        val tenantId = CurrentRequestContext.currentTenantId
        log.debug("Generating Id sequenceName: $sequenceName for tenantId: $tenantId")

        val jdbcCoordinator = session.jdbcCoordinator
        var nextValue: Long = 1

        val sql = if (tenantId != null) {
            "SELECT tenant_nextval(?,?)"
        } else {
            "SELECT unscoped_nextval(?)"
        }

        try {
            jdbcCoordinator.statementPreparer.prepareStatement(sql).use { preparedStatement ->
                prepareStatement(preparedStatement, tenantId)
                jdbcCoordinator.resultSetReturn.extract(preparedStatement, sql).use { resultSet ->
                    if (resultSet.next()) {
                        nextValue = resultSet.getLong(1)
                        log.trace("Sequence value obtained: $nextValue")
                    } else {
                        throw HibernateException("No value obtained for sequence.")
                    }
                }
            }
            jdbcCoordinator.afterStatementExecution()
        } catch (sqlException: SQLException) {
            throw session.jdbcServices.sqlExceptionHelper.convert(sqlException, "Could not get next sequence value")
        }

        return nextValue
    }

    private fun prepareStatement(preparedStatement: PreparedStatement, tenantId: Long?) {
        if (tenantId != null) {
            preparedStatement.setString(1, sequenceName)
            preparedStatement.setObject(2, tenantId, Types.BIGINT)
        } else {
            preparedStatement.setString(1, sequenceName)
        }
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/db/DatabaseService.kt =====
package net.blugrid.api.db

import jakarta.inject.Singleton
import org.hibernate.engine.jdbc.spi.JdbcCoordinator
import java.sql.PreparedStatement
import java.sql.ResultSet
import java.sql.SQLException
import kotlin.collections.forEachIndexed
import kotlin.collections.indices
import kotlin.let

interface DatabaseService {
    fun executeQuery(jdbcCoordinator: JdbcCoordinator, sql: String, params: List<Any>? = null): ResultSet?
    fun releaseResources(jdbcCoordinator: JdbcCoordinator, resultSet: ResultSet?, preparedStatement: PreparedStatement?)
    fun executeUpdate(jdbcCoordinator: JdbcCoordinator, sql: String, params: List<Any>)
}

@Singleton
class DatabaseServiceImpl : DatabaseService {

    override fun executeQuery(jdbcCoordinator: JdbcCoordinator, sql: String, params: List<Any>?): ResultSet? {
        val preparedStatement: PreparedStatement = jdbcCoordinator.statementPreparer.prepareStatement(sql)
        if (params != null) {
            for (i in params.indices) {
                preparedStatement.setObject(i + 1, params[i])
            }
        }

        return try {
            jdbcCoordinator.resultSetReturn.extract(preparedStatement, sql)
        } catch (e: SQLException) {
            jdbcCoordinator.logicalConnection.resourceRegistry.release(preparedStatement)
            jdbcCoordinator.afterStatementExecution()
            throw e
        }
    }

    override fun executeUpdate(jdbcCoordinator: JdbcCoordinator, sql: String, params: List<Any>) {
        val preparedStatement: PreparedStatement = jdbcCoordinator.statementPreparer.prepareStatement(sql)
        try {
            // Set parameters
            params.forEachIndexed { index, param ->
                preparedStatement.setObject(index + 1, param)
            }

            // Execute the update
            preparedStatement.executeUpdate()
        } finally {
            // Release the prepared statement
            jdbcCoordinator.logicalConnection.resourceRegistry.release(preparedStatement)
            jdbcCoordinator.afterStatementExecution()
        }
    }


    override fun releaseResources(jdbcCoordinator: JdbcCoordinator, resultSet: ResultSet?, preparedStatement: PreparedStatement?) {
        try {
            resultSet?.let {
                jdbcCoordinator.logicalConnection.resourceRegistry.release(it, preparedStatement)
            }
        } finally {
            preparedStatement?.let {
                jdbcCoordinator.logicalConnection.resourceRegistry.release(it)
            }
            jdbcCoordinator.afterStatementExecution()
        }
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/config/EnvProps.kt =====
package net.blugrid.api.config

import io.micronaut.context.annotation.ConfigurationProperties
import io.micronaut.core.bind.annotation.Bindable

@ConfigurationProperties("env")
interface EnvProps {

    @get:Bindable(defaultValue = "")
    val name: String
}

@ConfigurationProperties("env.server")
interface ServerProps {

    @get:Bindable(defaultValue = "")
    val baseUri: String
}

@ConfigurationProperties("env.web")
interface WebProps {

    @get:Bindable(defaultValue = "")
    val baseUri: String
}


@ConfigurationProperties("env.db")
interface DbProps {

    @get:Bindable(defaultValue = "")
    val dbname: String

    @get:Bindable(defaultValue = "")
    val schema: String
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/config/GlobalExceptionHandler.kt =====
package net.blugrid.api.config

import io.micronaut.context.annotation.Requires
import io.micronaut.http.HttpRequest
import io.micronaut.http.HttpResponse
import io.micronaut.http.HttpStatus
import io.micronaut.http.annotation.Produces
import io.micronaut.http.server.exceptions.ExceptionHandler
import jakarta.inject.Singleton
import net.blugrid.api.common.exception.APIException
import net.blugrid.api.logging.logger

@Produces
@Singleton
@Requires(classes = [APIException::class, ExceptionHandler::class])
class GlobalExceptionHandler : ExceptionHandler<Throwable, HttpResponse<Map<String, Any>>> {

    private val log = logger()

    override fun handle(request: HttpRequest<*>, exception: Throwable): HttpResponse<Map<String, Any>> {
        log.error("Exception occurred: ${exception.localizedMessage}")

        if (exception is APIException) {
            log.error("Error Code: ${exception.apiError.code}")

            // Log stack trace if required
            if (exception.includeStackTrace) {
                exception.stackTrace.forEach {
                    log.error(it.toString())
                }
            }

            return HttpResponse.status<Map<String, Any>>(exception.status)
                .body(exception.toResponseBody())
        } else {
            // Handle other types of exceptions (e.g., unexpected errors)
            log.error("Unexpected error: ${exception.message}")
            exception.stackTrace.forEach {
                log.error(it.toString())
            }

            // Return a generic internal server error response
            return HttpResponse.status<Map<String, Any>>(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(mapOf(
                    "status" to HttpStatus.INTERNAL_SERVER_ERROR.code,
                    "message" to "An unexpected error occurred",
                    "code" to "INTERNAL_SERVER_ERROR"
                ))
        }
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/config/PostgreSQL10JsonDialect.kt =====
package net.blugrid.api.config

import org.hibernate.dialect.PostgreSQLDialect
import java.sql.Types

/*
New Hibernate Type to handle the JDBC Types.OTHER either globally or on a per-query basis.
This is required to work around hibernates incompatibility with json types and union queries.

When unions for inherited type the 1111 JDBC type corresponds to Types.OTHER which is what the PostgreSQL JDBC Driver uses for jsonb column types.
Hibernate will throw the following MappingException in this case.
*/
//class PostgreSQL10JsonDialect : PostgreSQL10Dialect() {
//    init {
//        registerColumnType(Types.OTHER, "jsonb")
//        registerHibernateType(Types.OTHER, "jsonb")
//    }
//}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/config/ApplicationConfiguration.kt =====
package net.blugrid.api.config

import io.micronaut.context.annotation.ConfigurationProperties

interface ApplicationConfiguration {
    val max: Int
}

@ConfigurationProperties("application")
class ApplicationConfigurationProperties : ApplicationConfiguration {
    private val DEFAULT_MAX = 10
    override var max = DEFAULT_MAX
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/jwt/JwksLoader.kt =====
package net.blugrid.api.security.jwt

import com.nimbusds.jose.jwk.JWKSet
import com.nimbusds.jose.jwk.RSAKey
import java.security.KeyFactory
import java.security.interfaces.RSAPublicKey
import java.security.spec.RSAPublicKeySpec

class JwksLoader(jwksFilePath: String) {
    val publicKey: RSAPublicKey

    init {
        val jwksStream = javaClass.classLoader.getResourceAsStream(jwksFilePath)
            ?: throw IllegalArgumentException("Cannot load file: $jwksFilePath")
        val jwks = jwksStream.bufferedReader().use { it.readText() }
        val jwkSet = JWKSet.parse(jwks)
        val jwk = jwkSet.keys.first() as RSAKey
        val modulus = jwk.modulus.decodeToBigInteger()
        val exponent = jwk.publicExponent.decodeToBigInteger()
        val keySpec = RSAPublicKeySpec(modulus, exponent)
        val keyFactory = KeyFactory.getInstance("RSA")
        publicKey = keyFactory.generatePublic(keySpec) as RSAPublicKey
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/jwt/JwtDecoder.kt =====
@file:Suppress("DEPRECATION")

package net.blugrid.api.security.jwt

import com.nimbusds.jose.JOSEObjectType
import com.nimbusds.jose.JWSAlgorithm
import com.nimbusds.jose.jwk.source.RemoteJWKSet
import com.nimbusds.jose.proc.DefaultJOSEObjectTypeVerifier
import com.nimbusds.jose.proc.JWSVerificationKeySelector
import com.nimbusds.jose.proc.SecurityContext
import com.nimbusds.jwt.JWT
import com.nimbusds.jwt.JWTClaimsSet
import com.nimbusds.jwt.JWTParser
import com.nimbusds.jwt.SignedJWT
import com.nimbusds.jwt.proc.DefaultJWTClaimsVerifier
import com.nimbusds.jwt.proc.DefaultJWTProcessor
import com.nimbusds.jwt.proc.JWTProcessor
import io.micronaut.context.annotation.Requires
import io.micronaut.context.env.Environment
import io.micronaut.security.authentication.AuthorizationException
import io.micronaut.security.oauth2.configuration.OauthClientConfigurationProperties
import jakarta.inject.Singleton
import net.blugrid.api.jwt.model.JwtDecoder
import net.blugrid.api.logging.logger
import java.net.URL
import java.nio.charset.StandardCharsets
import java.text.ParseException
import java.util.Base64

// Not used. The Micronuat JwtValidator does this via configuration
@Singleton
@Requires(notEnv = [Environment.TEST])
class JwtDecoderImpl(
    private val oauthClientProps: OauthClientConfigurationProperties
) : JwtDecoder {

    private val log = logger()

    companion object {
        private var exactClaims: JWTClaimsSet? = null
        private var requiredClaims: Set<String>? = null
        private lateinit var processor: JWTProcessor<SecurityContext>
        private lateinit var jwksUri: String

        fun initialize(oauthClientProps: OauthClientConfigurationProperties) {
            jwksUri = oauthClientProps.openid.flatMap { it.jwksUri }.orElseThrow {
                IllegalStateException("jwksUri is not available")
            }
            processor = DefaultJWTProcessor<SecurityContext>().apply {
                jwsTypeVerifier = DefaultJOSEObjectTypeVerifier(JOSEObjectType("jwt"))
                jwsKeySelector = JWSVerificationKeySelector(
                    JWSAlgorithm.RS256,
                    RemoteJWKSet(URL(jwksUri))
                )
                jwtClaimsSetVerifier = DefaultJWTClaimsVerifier(exactClaims, requiredClaims)
            }
        }
    }

    init {
        initialize(oauthClientProps)
    }

    override fun decode(token: String): JWT {
        return try {
            processor.process(token, null)
                .let { JWTParser.parse(token) }
        } catch (e: ParseException) {
            log.error("Parsing error: $e")
            throw AuthorizationException(null)
        }
    }
}

@Singleton
@Requires(env = [Environment.TEST])
class FakeJwtDecoder : JwtDecoder {

    override fun decode(token: String): JWT {
        // Decode the token from Base64
        val decodedToken = String(Base64.getDecoder().decode(token), StandardCharsets.UTF_8)
        val signedJWT = SignedJWT.parse(decodedToken)

        return signedJWT
    }
}


===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/jwt/SelfSignedJwtDecoder.kt =====
package net.blugrid.api.security.jwt

import com.nimbusds.jose.JWSVerifier
import com.nimbusds.jose.crypto.RSASSAVerifier
import com.nimbusds.jwt.JWT
import com.nimbusds.jwt.JWTParser
import com.nimbusds.jwt.SignedJWT
import io.micronaut.context.annotation.Requires
import io.micronaut.context.annotation.Value
import jakarta.inject.Singleton
import net.blugrid.api.jwt.model.SelfSignedJwtDecoder
import net.blugrid.api.logging.logger
import java.security.interfaces.RSAPublicKey
import java.util.Optional

@Singleton
@Requires(property = "micronaut.security.token.jwt.signatures.jwks-static.selfSigned.path")
class SelfSignedJwtDecoderImpl(
    @Value("\${micronaut.security.token.jwt.signatures.jwks-static.selfSigned.path}") jwksFilePath: String
) : SelfSignedJwtDecoder {
    private val log = logger()
    private val publicKey: RSAPublicKey

    init {
        val jwksLoader = JwksLoader(jwksFilePath)
        publicKey = jwksLoader.publicKey
    }

    override fun decode(token: String): Optional<JWT> {
        val jwt: SignedJWT = JWTParser.parse(token) as SignedJWT
        val verifier: JWSVerifier = RSASSAVerifier(publicKey)

        return if (jwt.verify(verifier)) {
            Optional.of(jwt)
        } else {
            log.error("JWT verification failed")
            Optional.empty()
        }
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/jwt/SelfSignedJwtEncoder.kt =====
package net.blugrid.api.security.jwt

import jakarta.inject.Singleton
import net.blugrid.api.jwt.factory.AccessTokenFactory
import net.blugrid.api.jwt.model.JwtToken

@Singleton
class SelfSignedJwtEncoder {
    fun encode(token: JwtToken): String {
        return AccessTokenFactory.token(token)
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/jwt/JwtAuthenticationFetcher.kt =====
package net.blugrid.api.security.jwt

import com.fasterxml.jackson.databind.ObjectMapper
import io.micronaut.context.annotation.Replaces
import io.micronaut.context.event.ApplicationEventPublisher
import io.micronaut.http.HttpRequest
import io.micronaut.http.server.util.HttpHostResolver
import io.micronaut.http.server.util.locale.HttpLocaleResolver
import io.micronaut.security.authentication.Authentication
import io.micronaut.security.event.TokenValidatedEvent
import io.micronaut.security.filters.AuthenticationFetcher
import io.micronaut.security.filters.SecurityFilter
import io.micronaut.security.token.TokenAuthenticationFetcher
import jakarta.inject.Singleton
import net.blugrid.api.jwt.model.SelfSignedJwtDecoder
import net.blugrid.api.jwt.mapping.jwtObjectMapper
import net.blugrid.api.logging.logger
import net.blugrid.api.security.config.SecurityProps
import net.blugrid.api.security.mapping.toMultitenantAuthentication
import org.reactivestreams.Publisher
import reactor.core.publisher.Flux
import reactor.core.publisher.Mono

@Replaces(TokenAuthenticationFetcher::class)
@Singleton
class JwtAuthenticationFetcher(
    private val cookieProps: SecurityProps.CookieConfig,
    private val selfSignedJwtDecoder: SelfSignedJwtDecoder,
    private val tokenValidatedEventPublisher: ApplicationEventPublisher<TokenValidatedEvent>,
    private val httpHostResolver: HttpHostResolver,
    private val httpLocaleResolver: HttpLocaleResolver,
) : AuthenticationFetcher<HttpRequest<*>> {

    private val log = logger()

    companion object {
        const val ORDER = 0
        private var objectMapper: ObjectMapper = jwtObjectMapper
    }

    init {
        objectMapper = jwtObjectMapper
    }

    override fun fetchAuthentication(request: HttpRequest<*>): Publisher<Authentication> {
        val jwtCookie = request.cookies.get(cookieProps.jwt)
        return if (jwtCookie == null) {
            Flux.empty()
        } else {
            Flux.fromIterable(listOf(jwtCookie.value))
                .flatMap { tokenValue ->
                    val jwtOpt = selfSignedJwtDecoder.decode(tokenValue)
                    if (jwtOpt.isPresent) {
                        val jwt = jwtOpt.get()

                        jwt.toMultitenantAuthentication(log, objectMapper)
                            ?.let { authentication ->
                                request.setAttribute(SecurityFilter.TOKEN, tokenValue)
                                request.setAttribute("jwt", jwt)

                                tokenValidatedEventPublisher.publishEvent(
                                    TokenValidatedEvent(
                                        tokenValue,
                                        httpHostResolver.resolve(request),
                                        httpLocaleResolver.resolveOrDefault(request)
                                    )
                                )
                                Mono.just(authentication as Authentication)
                            }
                            ?: Flux.empty()
                    } else {
                        Flux.empty()
                    }
                }
        }
    }

    override fun getOrder(): Int {
        return ORDER
    }
}



===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/pkce/PkceUtil.kt =====
package net.blugrid.api.security.pkce

import java.security.MessageDigest
import java.security.SecureRandom
import java.util.Base64

object PkceUtil {

    fun generateCodeVerifier(): String {
        val secureRandom = SecureRandom()
        val code = ByteArray(32)
        secureRandom.nextBytes(code)
        return Base64.getUrlEncoder().withoutPadding().encodeToString(code)
    }

    fun generateCodeChallenge(verifier: String): String {
        val bytes = verifier.toByteArray(Charsets.US_ASCII)
        val messageDigest = MessageDigest.getInstance("SHA-256")
        messageDigest.update(bytes, 0, bytes.size)
        val digest = messageDigest.digest()
        return Base64.getUrlEncoder().withoutPadding().encodeToString(digest)
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/config/MultiTenantResolver.kt =====
package net.blugrid.api.security.config

import jakarta.inject.Named
import jakarta.inject.Singleton
import org.hibernate.context.spi.CurrentTenantIdentifierResolver

@Singleton
@Named("currentTenantResolver")
class MultiTenantResolver : CurrentTenantIdentifierResolver<String> {

    companion object {
        private const val DEFAULT_REGION_ID = "region_1"
    }

    override fun resolveCurrentTenantIdentifier(): String {
        return DEFAULT_REGION_ID
    }

    override fun validateExistingCurrentSessions(): Boolean {
        return true
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/config/CustomJdbcStatementInspector.kt =====
package net.blugrid.api.security.config

import jakarta.inject.Singleton
import net.blugrid.api.security.context.IsUnscoped
import org.hibernate.resource.jdbc.spi.StatementInspector

@Singleton
open class CustomJdbcStatementInspector : StatementInspector {
    override fun inspect(sql: String): String {
        val modifier = if (isUnscoped) "_unscoped" else ""
        return sql.replace("_##scope_option##", modifier)
    }

    private val isUnscoped: Boolean
        get() = when {
            IsUnscoped.isSet() -> IsUnscoped.value
            else -> false
        }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/config/MultiTenantConnectionProvider.kt =====
package net.blugrid.api.security.config

import jakarta.inject.Singleton
import net.blugrid.api.logging.logger
import net.blugrid.api.security.service.SecurityContextService
import net.blugrid.api.session.model.BusinessUnitSession
import net.blugrid.api.session.model.TenantSession
import org.hibernate.HibernateException
import org.hibernate.cfg.AvailableSettings
import org.hibernate.engine.config.spi.ConfigurationService
import org.hibernate.engine.jdbc.connections.spi.AbstractDataSourceBasedMultiTenantConnectionProviderImpl
import org.hibernate.service.spi.ServiceRegistryAwareService
import org.hibernate.service.spi.ServiceRegistryImplementor
import org.hibernate.service.spi.Stoppable
import java.sql.Connection
import java.sql.SQLException
import java.sql.Types
import java.util.concurrent.ConcurrentHashMap
import javax.sql.DataSource

@Suppress("UNCHECKED_CAST")
@Singleton
open class MultiTenantConnectionProvider(
    private val securityContextService: SecurityContextService
) : AbstractDataSourceBasedMultiTenantConnectionProviderImpl<String>(),
    ServiceRegistryAwareService,
    Stoppable {

    private val log = logger()

    private var dataSourceMap: Map<String, DataSource>? = null
    private var tenantIdentifierForAny: String? = null

    companion object {
        const val DEFAULT_TENANT_ID = "default"
        const val TENANT_IDENTIFIER_TO_USE_FOR_ANY_KEY = "hibernate.multi_tenant.datasource.identifier_for_any"
    }

    override fun selectAnyDataSource(): DataSource {
        return selectDataSource(tenantIdentifierForAny ?: DEFAULT_TENANT_ID)
    }

    override fun selectDataSource(tenantIdentifier: String): DataSource {
        return dataSourceMap()[tenantIdentifier]
            ?: throw HibernateException("Could not locate datasource for tenantIdentifier: $tenantIdentifier")
    }

    override fun getAnyConnection(): Connection {
        return getConnection("1")
    }

    override fun getConnection(regionId: String): Connection {
        val connection: Connection
        try {
            connection = selectAnyDataSource().connection
            val schema = connection.schema
            val unscoped = securityContextService.currentIsUnscoped
            val currentTenantId = securityContextService.currentTenantId
            val currentBusinessUnitId = securityContextService.currentBusinessUnitId
            val currentSession = securityContextService.currentSession

            when {
                unscoped -> {
                    log.debug("Configuring connection - unscoped override found - no scoping needed")
                    connection.configureUnscoped(schema)
                }

                currentSession is TenantSession && currentTenantId != null -> {
                    log.debug("Configuring connection - WebApplication session found in SecurityContext - scoping to TenantId: $currentTenantId")
                    connection.configureTenantSessionScope(schema, currentTenantId.toString(), currentSession.sessionId)
                }

                currentSession is BusinessUnitSession && currentTenantId != null && currentBusinessUnitId != null -> {
                    log.debug("Configuring connection - Business unit session found in SecurityContext - scoping to TenantId: $currentTenantId, BusinessUnitId: $currentBusinessUnitId")
                    connection.configureBusinessUnitSessionScope(schema, currentTenantId.toString(), currentBusinessUnitId.toString(), currentSession.sessionId)
                }

                currentTenantId != null && currentBusinessUnitId != null -> {
                    log.debug("Configuring connection - Business unit session found in SecurityContext - scoping to TenantId: $currentTenantId, BusinessUnitId: $currentBusinessUnitId")
                    connection.configureBusinessUnitIdScope(schema, currentTenantId.toString(), currentBusinessUnitId.toString())
                }

                currentTenantId != null -> {
                    log.debug("Configuring connection - WebApplication session found in SecurityContext - scoping to TenantId: $currentTenantId")
                    connection.configureTenantIdScope(schema, currentTenantId.toString())
                }

                else -> {
                    log.debug("Configuring connection - no scoping needed")
                    connection.configureUnscoped(schema)
                }
            }
        } catch (e: SQLException) {
            throw SQLException("Could not alter JDBC connection: ", e)
        }
        return connection
    }

    override fun releaseAnyConnection(connection: Connection) {
        this.releaseConnection("1", connection)
    }

    override fun releaseConnection(regionId: String, connection: Connection) {
        log.debug("Releasing connection")
        connection.close()
    }

    override fun supportsAggressiveRelease(): Boolean {
        return true
    }

    private fun dataSourceMap(): MutableMap<String, DataSource?> {
        if (dataSourceMap == null) {
            dataSourceMap = ConcurrentHashMap()
        }
        return dataSourceMap as MutableMap<String, DataSource?>
    }

    override fun injectServices(serviceRegistry: ServiceRegistryImplementor) {
        @Suppress("DEPRECATION") val dataSourceConfigValue = serviceRegistry.getService(ConfigurationService::class.java)?.settings?.get(AvailableSettings.DATASOURCE)
        if (dataSourceConfigValue == null) {
            throw HibernateException("Improper set up of DataSourceBasedMultiTenantConnectionProviderImpl")
        }
        log.info("Default data source: $dataSourceConfigValue")
        dataSourceMap = mapOf(DEFAULT_TENANT_ID to dataSourceConfigValue as DataSource)
    }

    override fun stop() {
        if (dataSourceMap != null) {
            dataSourceMap = null
        }
    }
}

private fun Connection.configureUnscoped(schema: String) {
    prepareCall("select pg_catalog.set_config('search_path', ?, false)")
        .use { statement ->
            statement.setString(1, schema)
            statement.execute()
        }
}

private fun Connection.configureTenantIdScope(schema: String, tenantId: String) {
    prepareCall("{? = CALL set_tenant_session(CAST(? AS TEXT), CAST(? AS TEXT)) }")
        .use { statement ->
            statement.registerOutParameter(1, Types.INTEGER)
            statement.setString(2, schema)
            statement.setString(3, tenantId)
            statement.execute()
        }
}

private fun Connection.configureTenantSessionScope(schema: String, tenantId: String, sessionId: String) {
    prepareCall("{? = CALL set_tenant_session(CAST(? AS TEXT), CAST(? AS TEXT), CAST(? AS TEXT)) }")
        .use { statement ->
            statement.registerOutParameter(1, Types.INTEGER)
            statement.setString(2, schema)
            statement.setString(3, tenantId)
            statement.setString(4, sessionId)
            statement.execute()
        }
}


private fun Connection.configureBusinessUnitIdScope(schema: String, tenantId: String, businessUnitId: String) {
    prepareCall("{? = CALL set_business_unit_session(CAST(? AS TEXT), CAST(? AS TEXT), CAST(? AS TEXT)) }")
        .use { statement ->
            statement.registerOutParameter(1, Types.INTEGER)
            statement.setString(2, schema)
            statement.setString(3, tenantId)
            statement.setString(4, businessUnitId)
            statement.execute()
        }
}

private fun Connection.configureBusinessUnitSessionScope(schema: String, tenantId: String, businessUnitId: String, sessionId: String) {
    prepareCall("{? = CALL set_business_unit_session(CAST(? AS TEXT), CAST(? AS TEXT), CAST(? AS TEXT), CAST(? AS TEXT)) }")
        .use { statement ->
            statement.registerOutParameter(1, Types.INTEGER)
            statement.setString(2, schema)
            statement.setString(3, tenantId)
            statement.setString(4, businessUnitId)
            statement.setString(5, sessionId)
            statement.execute()
        }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/config/JpaConfigurationCreatedEventListener.kt =====
package net.blugrid.api.security.config

import io.micronaut.configuration.hibernate.jpa.JpaConfiguration
import io.micronaut.context.event.BeanCreatedEvent
import io.micronaut.context.event.BeanCreatedEventListener
import jakarta.inject.Inject
import jakarta.inject.Singleton
//import org.hibernate.MultiTenancyStrategy.DATABASE
import org.hibernate.cfg.AvailableSettings

@Singleton
open class JpaConfigurationCreatedEventListener : BeanCreatedEventListener<JpaConfiguration> {

    @Inject
    var connectionProvider: MultiTenantConnectionProvider? = null

    @Inject
    var tenantResolver: MultiTenantResolver? = null

    override fun onCreated(event: BeanCreatedEvent<JpaConfiguration>): JpaConfiguration {
        val jpaConfiguration = event.bean
        jpaConfiguration.properties[AvailableSettings.MULTI_TENANT_CONNECTION_PROVIDER] = connectionProvider
        jpaConfiguration.properties[AvailableSettings.MULTI_TENANT_IDENTIFIER_RESOLVER] = tenantResolver
//        jpaConfiguration.properties[AvailableSettings.MULTI_TENANT] = DATABASE
        jpaConfiguration.properties[AvailableSettings.STATEMENT_INSPECTOR] = CustomJdbcStatementInspector::class.java
        return jpaConfiguration
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/service/LoginHandler.kt =====
package net.blugrid.api.security.service

import io.micronaut.context.annotation.Replaces
import io.micronaut.http.MutableHttpResponse
import io.micronaut.security.oauth2.endpoint.token.response.IdTokenLoginHandler
import jakarta.inject.Singleton
import net.blugrid.api.security.model.BaseAuthenticatedSession
import net.blugrid.api.security.model.DecoratedAuthentication
import java.util.UUID

@Singleton
@Replaces(IdTokenLoginHandler::class)
class EnhancedIdTokenLoginHandler(
    private val cookieService: CookieService,
    private val redirectService: RedirectService,
) {

    fun tenantLoginSuccess(multitenantAuthentication: DecoratedAuthentication<BaseAuthenticatedSession>): MutableHttpResponse<*> {
        return cookieService.applyJwtCookie(
            response = redirectService.redirectToLoginSuccess(),
            authentication = multitenantAuthentication
        )
    }

    fun invitationLoginSuccess(multitenantAuthentication: DecoratedAuthentication<BaseAuthenticatedSession>, partyRegistrationInvitationUuid: UUID): MutableHttpResponse<*> {
        return cookieService.applyJwtCookie(
            response = redirectService.redirectToLoginRegistration(partyRegistrationInvitationUuid),
            authentication = multitenantAuthentication
        )
    }

    fun loginFailed(): MutableHttpResponse<*> {
        return cookieService.clearCookies(
            response = redirectService.redirectToLoginFailure()
        )
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/service/CookieService.kt =====
package net.blugrid.api.security.service

import io.micronaut.http.MutableHttpResponse
import io.micronaut.security.authentication.Authentication
import jakarta.inject.Singleton
import net.blugrid.api.jwt.clearCookies
import net.blugrid.api.jwt.model.JwtToken
import net.blugrid.api.jwt.setCookie
import net.blugrid.api.logging.logger
import net.blugrid.api.security.config.SecurityProps
import net.blugrid.api.security.jwt.SelfSignedJwtEncoder
import net.blugrid.api.security.mapping.toJwtToken
import net.blugrid.api.security.model.BaseAuthenticatedSession
import net.blugrid.api.security.model.BusinessUnitAuthentication
import net.blugrid.api.security.model.DecoratedAuthentication
import net.blugrid.api.security.model.GuestAuthentication
import net.blugrid.api.security.model.TenantAuthentication
import java.time.Duration
import java.time.Instant

interface CookieService {
    fun applyJwtCookie(response: MutableHttpResponse<*>, authentication: DecoratedAuthentication<BaseAuthenticatedSession>): MutableHttpResponse<*>
    fun applyStateCookie(response: MutableHttpResponse<*>, state: String): MutableHttpResponse<*>
    fun clearCookies(response: MutableHttpResponse<*>): MutableHttpResponse<*>
    fun applyNonceCookie(response: MutableHttpResponse<*>, nonce: String): MutableHttpResponse<*>
}

@Singleton
class CookieServiceImpl(
    private val cookieSecurityProps: SecurityProps.CookieConfig,
    private val selfSignedJwtEncoder: SelfSignedJwtEncoder
) : CookieService {
    private val log = logger()

    override fun applyJwtCookie(response: MutableHttpResponse<*>, authentication: DecoratedAuthentication<BaseAuthenticatedSession>): MutableHttpResponse<*> {
        val ttl = authentication.toCookieExpiration().toMillis()
        val jwt = authentication.toJwtToken()
        val accessToken = selfSignedJwtEncoder.encode(jwt)
        return response.setCookie(cookieSecurityProps.jwt, accessToken, ttl)
    }

    override fun applyNonceCookie(response: MutableHttpResponse<*>, nonce: String): MutableHttpResponse<*> {
        return response.setCookie(cookieSecurityProps.oathNonce, nonce)
    }

    override fun applyStateCookie(response: MutableHttpResponse<*>, state: String): MutableHttpResponse<*> {
        return response.setCookie(cookieSecurityProps.oathState, state)
    }

    override fun clearCookies(response: MutableHttpResponse<*>): MutableHttpResponse<*> {
        return response.clearCookies(
            listOf(
                cookieSecurityProps.jwt,
                cookieSecurityProps.oauthPkce,
                cookieSecurityProps.oathState,
                cookieSecurityProps.oathNonce
            )
        )
    }

    private fun DecoratedAuthentication<BaseAuthenticatedSession>.toCookieExpiration(): Duration =
        expirationTime?.let {
            Duration.between(Instant.now(), it.toInstant())
        } ?: Duration.ofDays(1)
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/service/RedirectService.kt =====
package net.blugrid.api.security.service

import io.micronaut.context.annotation.Value
import io.micronaut.http.HttpRequest
import io.micronaut.http.HttpResponse
import io.micronaut.http.MutableHttpResponse
import io.micronaut.http.uri.UriBuilder
import jakarta.inject.Singleton
import net.blugrid.api.config.WebProps
import net.blugrid.api.logging.logger
import net.blugrid.api.security.config.RedirectProps
import net.blugrid.api.security.config.SecurityProps
import net.blugrid.api.security.pkce.PkceUtil
import java.net.URI
import java.util.UUID

@Singleton
class RedirectService(
    private val auth0Config: SecurityProps.Auth0Config,
    private val webProps: WebProps,
    private val redirectProps: RedirectProps,
    @Value("\${micronaut.security.endpoints.logout.path:/logout}")
    private val logoutPath: String,
) {

    private val log = logger()

    val getAuth0AuthorizeCallback: URI
        get() = URI(redirectProps.loginCallbackUrl)

    fun getAuth0LoginAndRegisterUri(state: String, nonce: String): URI {
        return UriBuilder.of(auth0Config.auth0Domain)
            .path("/authorize")
            .queryParam("audience", auth0Config.audience)
            .queryParam("scope", "openid profile email")
            .queryParam("response_type", "code")
            .queryParam("client_id", auth0Config.clientId)
            .queryParam("redirect_uri", redirectProps.registrationCallbackUrl)
            .queryParam("state", state)
            .queryParam("nonce", nonce)
            .build()
    }

    val auth0LoginUri: URI
        get() {
            val codeVerifier = PkceUtil.generateCodeVerifier()
            val codeChallenge = PkceUtil.generateCodeChallenge(codeVerifier)

            return UriBuilder.of(auth0Config.auth0Domain)
                .path("/authorize")
                .queryParam("audience", auth0Config.audience)
                .queryParam("scope", "openid profile email")
                .queryParam("response_type", "code")
                .queryParam("client_id", auth0Config.clientId)
                .queryParam("redirect_uri", redirectProps.loginCallbackUrl)
                .queryParam("code_challenge", codeChallenge)
                .queryParam("code_challenge_method", "S256")
                .build()
        }

    val auth0LogoutUri: URI
        get() = UriBuilder.of(auth0Config.auth0Domain)
            .path("/v2/logout")
            .queryParam("client_id", auth0Config.clientId)
            .queryParam("returnTo", redirectProps.logoutCallbackUrl)
            .build()

    fun redirectToAuth0Login(request: HttpRequest<*>): MutableHttpResponse<*> {
        log.debug("redirectToAuth0Login: ${request.cookies}")
        return HttpResponse.seeOther<Any>(auth0LoginUri)
    }

    fun redirectToLoginSuccess(): MutableHttpResponse<*> {
        return HttpResponse.seeOther<Any>(URI(redirectProps.loginSuccessUrl))
    }

    fun getRegistrationUrl(partyRegistrationInvitationUuid: UUID): String {
        val baseUri = redirectProps.registrationUrl.trimEnd('/')
        return "$baseUri?invitationUuid=$partyRegistrationInvitationUuid"
    }

    fun redirectToLoginRegistration(partyRegistrationInvitationUuid: UUID): MutableHttpResponse<*> {
        return HttpResponse.seeOther<Any>(UriBuilder.of(webProps.baseUri)
            .path("/#/signup")
            .queryParam("invitationUuid", partyRegistrationInvitationUuid)
            .build()
        )
    }

    fun redirectToLoginFailure(): MutableHttpResponse<*> {
        return HttpResponse.seeOther<Any>(URI(redirectProps.loginFailureUrl))
    }

    fun redirectToLogout(): MutableHttpResponse<*> {
        return HttpResponse.seeOther<Any>(URI(logoutPath))
    }

    fun redirectToAuth0Logout(request: HttpRequest<*>): MutableHttpResponse<*> {
        log.debug("getLogoutRedirect: ${request.cookies}")
        return HttpResponse.seeOther<Any>(auth0LogoutUri)
    }

    fun redirectToLogoutSuccess(): MutableHttpResponse<*> {
        return HttpResponse.seeOther<Any>(URI(redirectProps.logoutUrl))
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/service/SecurityContextService.kt =====
package net.blugrid.api.security.service

import jakarta.inject.Singleton
import net.blugrid.api.logging.logger
import net.blugrid.api.security.context.BusinessUnitIdOverride
import net.blugrid.api.security.context.CurrentRequestContext
import net.blugrid.api.security.context.IsUnscoped
import net.blugrid.api.security.context.TenantIdOverride
import net.blugrid.api.security.model.BaseAuthenticatedOrganisation
import net.blugrid.api.security.model.BaseAuthenticatedSession
import net.blugrid.api.security.model.BaseAuthenticatedUser
import net.blugrid.api.security.repository.RequestScopeRepository
import java.util.concurrent.Callable

interface SecurityContextService {
    fun <T> runWithTenantId(tenantId: Long, original: Callable<T>): T
    fun <T> runWithBusinessUnitId(tenantId: Long, businessUnitId: Long, original: Callable<T>): T
    fun <T> runUnscoped(original: Callable<T>): T

    val currentTenant: BaseAuthenticatedOrganisation?
    val currentUser: BaseAuthenticatedUser?
    val currentSession: BaseAuthenticatedSession?

    val currentBusinessUnitId: Long?
    val currentTenantId: Long?

    val currentIsUnscoped: Boolean
}

@Singleton
open class SecurityContextServiceImpl(
    private val requestScopeRepository: RequestScopeRepository,
) : SecurityContextService {

    val log = logger()

    override val currentSession: BaseAuthenticatedSession?
        get() = CurrentRequestContext.currentSession

    override val currentTenant: BaseAuthenticatedOrganisation?
        get() = CurrentRequestContext.currentOrganisation

    override val currentUser: BaseAuthenticatedUser?
        get() = CurrentRequestContext.currentUser

    override val currentBusinessUnitId: Long?
        get() = CurrentRequestContext.currentBusinessUnitId

    override val currentTenantId: Long?
        get() = CurrentRequestContext.currentTenantId

    override val currentIsUnscoped: Boolean
        get() = CurrentRequestContext.currentIsUnscoped

    override fun <T> runWithTenantId(tenantId: Long, original: Callable<T>): T {
        log.debug("Running with tenantId: $tenantId")
        val previousTenantId = if (TenantIdOverride.hasOverride()) {
            TenantIdOverride.value
        } else {
            null
        }
        try {
            TenantIdOverride.use {
                TenantIdOverride.value = tenantId.toString()
                requestScopeRepository.setTenantId(tenantId.toString())
                return original.call()
            }
        } finally {
            if (previousTenantId != null) {
                TenantIdOverride.value = previousTenantId
                requestScopeRepository.setTenantId(previousTenantId)
            }
        }
    }

    override fun <T> runWithBusinessUnitId(tenantId: Long, businessUnitId: Long, original: Callable<T>): T {
        log.debug("Running with tenantId: $tenantId businessUnitId: $businessUnitId")
        val previousBusinessId = if (BusinessUnitIdOverride.hasOverride()) {
            BusinessUnitIdOverride.value
        } else {
            null
        }
        val previousTenantId = if (TenantIdOverride.hasOverride()) {
            TenantIdOverride.value
        } else {
            null
        }
        try {
            TenantIdOverride.use {
                TenantIdOverride.value = tenantId.toString()
                requestScopeRepository.setTenantId(tenantId.toString())
                BusinessUnitIdOverride.use {
                    BusinessUnitIdOverride.value = businessUnitId.toString()
                    requestScopeRepository.setBusinessUnitId(businessUnitId.toString())
                    return original.call()
                }
            }
        } finally {
            if (previousBusinessId != null) {
                BusinessUnitIdOverride.value = previousBusinessId
                requestScopeRepository.setBusinessUnitId(previousBusinessId)
            }
            if (previousTenantId != null) {
                TenantIdOverride.value = previousTenantId
                requestScopeRepository.setTenantId(previousTenantId)
            }
        }
    }

    override fun <T> runUnscoped(original: Callable<T>): T {
        log.debug("Running unscoped")
        val previousToken = if (IsUnscoped.isSet()) {
            IsUnscoped.value
        } else {
            null
        }
        try {
            IsUnscoped.use {
                IsUnscoped.value = true
                return original.call()
            }
        } finally {
            if (previousToken != null) {
                IsUnscoped.value = previousToken
            }
        }
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/service/CustomOauthRouteUrlBuilder.kt =====
package net.blugrid.api.security.service

import io.micronaut.context.annotation.Replaces
import io.micronaut.context.annotation.Value
import io.micronaut.http.HttpRequest
import io.micronaut.http.uri.UriBuilder
import io.micronaut.security.oauth2.configuration.OauthConfiguration
import io.micronaut.security.oauth2.url.OauthRouteUrlBuilder
import jakarta.inject.Singleton
import net.blugrid.api.config.ServerProps
import java.net.MalformedURLException
import java.net.URI
import java.net.URISyntaxException
import java.net.URL

@Singleton
@Replaces(bean = OauthRouteUrlBuilder::class)
class CustomOauthRouteUrlBuilder(
    private val serverProps: ServerProps,
    private val oauthConfiguration: OauthConfiguration,
    @Value("\${micronaut.server.context-path:/}") private val contextPath: String
) : OauthRouteUrlBuilder<HttpRequest<*>> {

    private val loginUriTemplate: String = oauthConfiguration.loginUri
    private val callbackUriTemplate: String = oauthConfiguration.callbackUri

    override fun buildLoginUrl(originating: HttpRequest<*>, providerName: String): URL {
        return buildUrl(originating, getPath(loginUriTemplate, providerName))
    }

    override fun buildCallbackUrl(originating: HttpRequest<*>, providerName: String): URL {
        return buildUrl(originating, getPath(callbackUriTemplate, providerName))
    }

    override fun buildLoginUri(providerName: String?): URI {
        return try {
            URI(getPath(loginUriTemplate, providerName ?: DEFAULT_PROVIDER_NAME))
        } catch (e: URISyntaxException) {
            throw IllegalArgumentException("Error building URI for path [$loginUriTemplate]", e)
        }
    }

    override fun buildCallbackUri(providerName: String?): URI {
        return try {
            URI(getPath(callbackUriTemplate, providerName ?: DEFAULT_PROVIDER_NAME))
        } catch (e: URISyntaxException) {
            throw IllegalArgumentException("Error building URI for path [$callbackUriTemplate]", e)
        }
    }

    private fun getPath(uriTemplate: String, providerName: String): String {
        val uriParams = mutableMapOf<String, Any>("provider" to providerName)
        return UriBuilder.of(contextPath)
            .path(uriTemplate)
            .expand(uriParams)
            .toString()
    }

    override fun buildUrl(originating: HttpRequest<*>, path: String): URL {
        return try {
            UriBuilder.of(serverProps.baseUri)
                .path(path)
                .build()
                .toURL()
        } catch (e: MalformedURLException) {
            throw IllegalArgumentException("Error building URL for path [$path]", e)
        }
    }

    companion object {
        private val DEFAULT_PROVIDER_NAME = "" // This will build a route like Registering default login route [GET: /oauth/login/]
    }
}


===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/controller/LogoutController.kt =====
package net.blugrid.api.security.controller

import io.micronaut.context.annotation.Replaces
import io.micronaut.context.event.ApplicationEventPublisher
import io.micronaut.http.HttpRequest
import io.micronaut.http.MediaType
import io.micronaut.http.MutableHttpResponse
import io.micronaut.http.annotation.Controller
import io.micronaut.http.annotation.Get
import io.micronaut.http.annotation.Produces
import io.micronaut.http.server.util.HttpHostResolver
import io.micronaut.http.server.util.locale.HttpLocaleResolver
import io.micronaut.scheduling.TaskExecutors
import io.micronaut.scheduling.annotation.ExecuteOn
import io.micronaut.security.annotation.Secured
import io.micronaut.security.authentication.Authentication
import io.micronaut.security.endpoints.LogoutController
import io.micronaut.security.event.LogoutEvent
import io.micronaut.security.rules.SecurityRule
import net.blugrid.api.security.service.CookieService
import net.blugrid.api.security.service.RedirectService

@Replaces(LogoutController::class)
@Controller("\${micronaut.security.endpoints.logout.path:/logout}")
@ExecuteOn(TaskExecutors.BLOCKING)
@Secured(SecurityRule.IS_ANONYMOUS)
class EnhancedLogoutController(
    private val cookieService: CookieService,
    private val httpHostResolver: HttpHostResolver,
    private val httpLocaleResolver: HttpLocaleResolver,
    private val logoutEventPublisher: ApplicationEventPublisher<LogoutEvent>,
    private val redirectService: RedirectService,
) {

    @Get
    @Produces(MediaType.APPLICATION_JSON)
    fun startLogout(request: HttpRequest<*>): MutableHttpResponse<*> {
        return redirectService.redirectToAuth0Logout(request)
    }

    @Get("/callback")
    fun handleCallback(request: HttpRequest<*>, authentication: Authentication?): MutableHttpResponse<*> {
        if (authentication != null) {
            logoutEventPublisher.publishEvent(LogoutEvent(authentication, httpHostResolver.resolve(request), httpLocaleResolver.resolveOrDefault(request)))
        }
        return cookieService.clearCookies(
            response = redirectService.redirectToLogoutSuccess()
        )
    }
}



===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/controller/RedirectController.kt =====
package net.blugrid.api.security.controller

import io.micronaut.http.HttpRequest
import io.micronaut.http.HttpResponse
import io.micronaut.http.annotation.Controller
import io.micronaut.http.annotation.Get
import io.micronaut.scheduling.TaskExecutors
import io.micronaut.scheduling.annotation.ExecuteOn
import io.micronaut.security.annotation.Secured
import io.micronaut.security.rules.SecurityRule
import net.blugrid.api.security.service.RedirectService

@Controller("/redirect")
@ExecuteOn(TaskExecutors.BLOCKING)
@Secured(SecurityRule.IS_ANONYMOUS)
class RedirectController(
    private val redirectService: RedirectService,
) {

    @Get("/login")
    fun login(request: HttpRequest<*>): HttpResponse<*> {
        return redirectService.redirectToAuth0Login(request)
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/controller/CheckSessionController.kt =====
package net.blugrid.api.security.controller

import io.micronaut.http.HttpRequest
import io.micronaut.http.HttpResponse
import io.micronaut.http.MediaType
import io.micronaut.http.annotation.Controller
import io.micronaut.http.annotation.Get
import io.micronaut.http.annotation.Produces
import io.micronaut.scheduling.TaskExecutors
import io.micronaut.scheduling.annotation.ExecuteOn
import io.micronaut.security.annotation.Secured
import io.micronaut.security.rules.SecurityRule
import net.blugrid.api.security.service.RedirectService
import toMultitenantAuthentication

@Controller("/check-session")
@ExecuteOn(TaskExecutors.BLOCKING)
@Secured(SecurityRule.IS_ANONYMOUS)
class CheckSessionController(
    private val redirectService: RedirectService
) {

    @Get("/")
    @Produces(MediaType.APPLICATION_JSON)
    fun checkSession(request: HttpRequest<*>): HttpResponse<*> {
        val authenticationOpt = request.toMultitenantAuthentication()
        return if (authenticationOpt.isPresent) {
            return if (authenticationOpt.get().isExpired) {
                sendFailedResponse()
            } else {
                HttpResponse.ok<Any>()
            }
        } else {
            sendFailedResponse()
        }
    }

    private fun sendFailedResponse() = HttpResponse.unauthorized<Map<String, String>>()
        .body(mapOf("redirectUri" to redirectService.getAuth0AuthorizeCallback.toString()))
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/repository/model/RequestScopeEntity.kt =====
package net.blugrid.api.security.repository.model

import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.Id
import jakarta.persistence.Table

@Entity
@Table(name = "vw_request_scope")
class RequestScopeEntity(

    @Id
    @Column(name = "tenant_id")
    val tenantId: Long? = null,
)

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/security/repository/RequestScopeRepository.kt =====
package net.blugrid.api.security.repository

import io.micronaut.data.annotation.Query
import io.micronaut.data.annotation.Repository
import io.micronaut.data.jpa.repository.JpaRepository
import net.blugrid.api.security.repository.model.RequestScopeEntity

@Repository
interface RequestScopeRepository : JpaRepository<RequestScopeEntity?, Long?> {

    @Query(value = "SELECT set_tenant_scope(CAST(:tenantId AS TEXT))", nativeQuery = true)
    fun setTenantId(tenantId: String): Int

    @Query(value = "SELECT set_business_unit_scope(CAST(:businessUnitId AS TEXT))", nativeQuery = true)
    fun setBusinessUnitId(
        businessUnitId: String,
    ): Int

    @Query(value = "SELECT reset_request_scope()", nativeQuery = true)
    fun resetRequestScope(): Int
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/kotlin/net/blugrid/api/Application.kt =====
package net.blugrid.api


import io.micronaut.runtime.Micronaut.run


fun main(args: Array<String>) {
    run(*args)
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/resources/logback.xml =====
<configuration>

    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <withJansi>true</withJansi>
        <!-- encoders are assigned the type
             ch.qos.logback.classic.encoder.PatternLayoutEncoder by default -->
        <encoder>
            <pattern>%cyan(%d{HH:mm:ss.SSS}) %gray([%thread]) %highlight(%-5level) %magenta(%logger{36}) - %msg%n</pattern>
        </encoder>
    </appender>

    <root level="info">
        <appender-ref ref="STDOUT"/>
    </root>
</configuration>

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/resources/application-consul.yml =====
micronaut:
  application:
    name: ${SERVICE_NAME:restApi}
  config-client:
    enabled: true

consul:
  client:
    registration:
      enabled: true
    defaultZone: "${CONSUL_HOST:10.200.10.1}:${CONSUL_PORT:8500}"

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/resources/application-security.yml =====
#tag::env[]
env:
  name: ${SERVICE_NAME:restApi}
  server:
    baseUri: ${SERVICE_BASE_URI:`http://localhost:8080`}
  web:
    baseUri: ${WEB_BASE_URI:`http://localhost:4201`}
  consul:
    host: ${CONSUL_HOST:consul}
    port: ${CONSUL_PORT:8500}
  db:
    dbname: bizkinetics
    schema: ${POSTGRES_SCHEMA:common}
    host-1:
      name: ${POSTGRES_HOST_1:localhost}
      port: ${POSTGRES_PORT_1:5432}
      username: ${POSTGRES_USERNAME_1:postgres}
      password: ${POSTGRES_PASSWORD_1:password}
    host-2:
      name: ${POSTGRES_HOST_2:localhost}
      port: ${POSTGRES_PORT_2:5432}
      username: ${POSTGRES_USERNAME_2:postgres}
      password: ${POSTGRES_PASSWORD_2:password}
#end::env[]
---
#tag::security[]
redirect:
  loginCallbackUrl: "${env.server.baseUri}${micronaut.server.context-path}/oauth/callback"
  loginRedirectUri: "${env.server.baseUri}${micronaut.server.context-path}/oauth/login"
  loginSuccessUrl: "${env.web.baseUri}/#/app/dashboard"  # ToDo: This needs to be configured
  loginFailureUrl: "${env.web.baseUri}/#/error/login-failure"
  logoutCallbackUrl: "${env.server.baseUri}${micronaut.server.context-path}/logout/callback"
  logoutUrl: "${env.web.baseUri}/#/logout"  # ToDo: This needs to be configured
  registrationUrl: "${env.server.baseUri}${micronaut.server.context-path}/party-registration/signup"
  registrationCallbackUrl: "${redirect.registrationUrl}/callback"
security:
  auth0:
    audience: "https://dev.bizkinetics.com.au/api/rest"
    auth0Domain: "https://bizkinetics.au.auth0.com"
    clientId: "mR4yoUpZJQ4Ttk9zLcyH7jcMwirQydZG"
  cookies:
    jwt: "JWT"
    oauthPkce: "OAUTH2_PKCE"
    oathState: "OAUTH2_STATE"
    oathNonce: "OPENID_NONCE"
micronaut:
  server:
    context-path: ""
    cors:
      enabled: true
      configurations:
        all:
          allowed-origins:
            - "${env.web.baseUri}"
            - "http://localhost:4201"
            - "http://dev.bizkinetics.com.au"
            - "https://dev.bizkinetics.com.au"
          allowed-methods:
            - HEAD
            - OPTIONS
            - POST
            - PUT
            - GET
          allowed-headers:
            - Content-Type
            - Authorization
          allow-credentials: true
  security:
    enabled: true
    authentication: idtoken
    endpoints:
      logout:
        enabled: true
        get-allowed: true
        path: "/logout"
    intercept-url-map:
      - pattern: "/admin/**"
        http-method: GET
        access:
          - isAnonymous()
      - pattern: "/oauth/**"
        http-method: GET
        access:
          - isAnonymous()
      - pattern: "/swagger/**"
        http-method: GET
        access:
          - isAnonymous()
      - pattern: "/swagger-ui/**"
        http-method: GET
        access:
          - isAnonymous()
      - pattern: "/**"
        http-method: OPTIONS
        access:
          - isAnonymous()
      - pattern: "/**"
        access:
          - isAuthenticated()
    oauth2:
      clients:
        auth0:
          client-id: "${OAUTH_CLIENT_ID:mR4yoUpZJQ4Ttk9zLcyH7jcMwirQydZG}"
          client-secret: "${OAUTH_CLIENT_SECRET:A62x6oAXb556euKq-CcNs131iFSaq71buRE7I8OobXkPAxFOYjXoBT9UJd3L6fIg}"
          openid:
            issuer: "https://bizkinetics.au.auth0.com/"
            jwks-uri: "https://bizkinetics.au.auth0.com/.well-known/jwks.json/"
            scopes: "openid profile email"
            end-session:
              enabled: false
      default-provider: auth0
    redirect:
      login-success: "${env.web.baseUri}/#/app/dashboard"  # ToDo: This needs to be configured
      login-failure: "${env.web.baseUri}/#/error/login-failure"
      logout: "${env.web.baseUri}/#/logout"  # ToDo: This needs to be configured
    token:
      cookie:
        enabled: true
      jwt:
        enabled: true
        signatures:
          jwks-static:
            selfSigned:
              path: "jwks.json"
  multitenancy:
    tenantresolver:
      httpheader:
        header-name: tenantId
        enabled: true
#end::security[]
---
#tag::endpoints[]
endpoints:
  all:
    enabled: true
    path: "/admin/"
    sensitive: false
#end::endpoints[]

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/resources/application-multitenant-test.yml =====
env.db.schema: multitenant

===== ./common/common-kotlin/common-api/common-api-multitenant/src/main/resources/application-security-tracing.yml =====

logger:
  levels:
    net.blugrid.api.security: TRACE
    com.fasterxml.jackson: TRACE
    io.micronaut.security: TRACE

===== ./common/common-kotlin/common-api/common-api-multitenant/src/test/kotlin/api/blugrid/net/ApplicationTest.kt =====
package net.blugrid.api

import io.micronaut.runtime.EmbeddedApplication
import io.micronaut.test.extensions.junit5.annotation.MicronautTest
import jakarta.inject.Inject
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test

@MicronautTest
internal class ApplicationTest {
    @Inject
    var application: EmbeddedApplication<*>? = null

    @Test
    fun testItWorks() {
        Assertions.assertTrue(application!!.isRunning)
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/integTest/kotlin/net/blugrid/api/security/service/SecurityContextServiceTest.kt =====
//package net.blugrid.api.security.service
//
//import io.github.serpro69.kfaker.faker
//import io.micronaut.test.extensions.junit5.annotation.MicronautTest
//import jakarta.inject.Inject
//import net.blugrid.api.common.model.organisation.OrganisationCreate
//import net.blugrid.api.example.model.BookCreate
//import net.blugrid.api.example.service.BookStateServiceImpl
//import net.blugrid.api.organisation.service.OrganisationStateServiceImpl
//import net.blugrid.api.security.context.doInRequestContext
//import org.hamcrest.CoreMatchers.equalTo
//import org.hamcrest.MatcherAssert.assertThat
//import org.junit.jupiter.api.Test
//import java.util.UUID
//
//@MicronautTest(environments = ["logging", "json", "security", "db", "multitenant-test"])
//class SecurityContextServiceTest {
//
//    @Inject
//    lateinit var securityContextService: SecurityContextServiceImpl
//
//    @Inject
//    lateinit var bookStateService: BookStateServiceImpl
//
//    @Inject
//    lateinit var organisationStateService: OrganisationStateServiceImpl
//
//    val faker = faker {}
//
//    @Test
//    fun `test runWithTenantId saves to the database with the assumed tenantId`() {
//        val firstTenantId = 1L
//        val secondTenantId = 2L
//        doInRequestContext {
//            securityContextService.runWithTenantId(firstTenantId) {
//                bookStateService.create(book())
//                    .also { assertThat("run with first tenantId", it.permission!!.tenantId, equalTo(firstTenantId)) }
//
//                organisationStateService.create(OrganisationCreate(uuid = UUID.randomUUID(), parentOrganisationId = -1))
//
//                securityContextService.runWithTenantId(secondTenantId) {
//                    bookStateService.create(book())
//                        .also { assertThat("run with second tenantId", it.permission!!.tenantId, equalTo(secondTenantId)) }
//                }
//
//                bookStateService.create(book())
//                    .also { assertThat("run with first tenantId again", it.permission!!.tenantId, equalTo(firstTenantId)) }
//            }
//        }
//    }
//
//    private fun book() = BookCreate(uuid = UUID.randomUUID(), name = faker.cannabis.strains())
//}

===== ./common/common-kotlin/common-api/common-api-multitenant/src/integTest/kotlin/net/blugrid/api/BaseMultitenantIntegTest.kt =====
package net.blugrid.api

import io.micronaut.http.client.HttpClient
import io.micronaut.http.client.annotation.Client
import io.micronaut.test.extensions.junit5.annotation.MicronautTest
import net.blugrid.api.test.controller.CommonControllerIntegTest

@MicronautTest(environments = ["logging", "json", "security", "db", "multitenant-test"])
open class BaseMultitenantIntegTest(
    override val baseUri: String,
    @Client("/") override val client: HttpClient
) : CommonControllerIntegTest(
    baseUri = baseUri,
    client = client
)

===== ./common/common-kotlin/common-api/common-api-multitenant/gradle/wrapper/gradle-wrapper.properties =====
distributionBase=GRADLE_USER_HOME
distributionPath=wrapper/dists
distributionUrl=https\://services.gradle.org/distributions/gradle-7.5.1-bin.zip
zipStoreBase=GRADLE_USER_HOME
zipStorePath=wrapper/dists

===== ./common/common-kotlin/common-api/common-api-multitenant/README.md =====
## Micronaut 3.7.5 Documentation

- [User Guide](https://docs.micronaut.io/3.7.5/guide/index.html)
- [API Reference](https://docs.micronaut.io/3.7.5/api/index.html)
- [Configuration Reference](https://docs.micronaut.io/3.7.5/guide/configurationreference.html)
- [Micronaut Guides](https://guides.micronaut.io/index.html)

---

- [Shadow Gradle Plugin](https://plugins.gradle.org/plugin/com.github.johnrengelman.shadow)

## Feature serialization-jackson documentation

- [Micronaut Serialization Jackson Core documentation](https://micronaut-projects.github.io/micronaut-serialization/latest/guide/)

## Feature hibernate-jpa documentation

- [Micronaut Hibernate JPA documentation](https://micronaut-projects.github.io/micronaut-sql/latest/guide/index.html#hibernate)

## Feature jdbc-hikari documentation

- [Micronaut Hikari JDBC Connection Pool documentation](https://micronaut-projects.github.io/micronaut-sql/latest/guide/index.html#jdbc)

## Feature http-client documentation

- [Micronaut HTTP Client documentation](https://docs.micronaut.io/latest/guide/index.html#httpClient)



===== ./common/common-kotlin/common-api/common-api-multitenant/build.gradle.kts =====
plugins {
    alias(libs.plugins.jvm)
    alias(libs.plugins.kapt)
    alias(libs.plugins.allopen)
    alias(libs.plugins.jpa)
    alias(libs.plugins.application)
}

dependencies {
    // API dependencies - expose to consumers
    api(project(":common:common-kotlin:common-api:common-api-json"))
    api(project(":common:common-kotlin:common-api:common-api-model"))
    api(project(":common:common-kotlin:common-api:common-api-security"))
    api(project(":common:common-kotlin:common-api:common-api-web"))

    // Platform BOMs
    implementation(platform(libs.micronaut.bom))
    implementation(platform(libs.aws.bom))

    // Core dependencies using new bundles
    implementation(libs.bundles.kotlinCore)
    implementation(libs.bundles.micronautCore)
    implementation(libs.bundles.micronautWeb)
    implementation(libs.bundles.micronautData)
    implementation(libs.bundles.micronautSecurity)

    // Multitenancy-specific dependencies
    implementation(libs.micronaut.multitenancy)    // Core multitenancy support

    // Reactive support for AuthenticationFetcher
    implementation(libs.micronaut.reactor)               // Reactor core integration
    implementation(libs.micronaut.reactor.http.client)   // HTTP reactive support

    // Annotation processing
    kapt(libs.bundles.annotationProcessors)

    // Compile-only dependencies
    compileOnly(libs.bundles.compileOnly)

    // Runtime dependencies
    runtimeOnly(libs.bundles.runtimeCore)
    runtimeOnly(libs.bundles.runtimeDatabase)
    runtimeOnly(libs.bundles.runtimeSecurity)

    // Test dependencies
    testImplementation(project(":common:common-kotlin:common-api:common-api-test"))
    testImplementation(libs.bundles.testing) {
        exclude(group = "org.slf4j", module = "slf4j-api")
    }
}

java {
    sourceCompatibility = JavaVersion.toVersion("17")
}

kapt {
    arguments {
        arg("micronaut.openapi.project.dir", projectDir.toString())
    }
}

graalvmNative.toolchainDetection = false
micronaut {
    runtime("netty")
    testRuntime("junit5")
    processing {
        incremental(true)
        annotations("net.blugrid.api.*")
    }
}

// Integration test configuration
configureIntegrationTests()

fun Project.configureIntegrationTests() {
    sourceSets {
        create("integTest") {
            compileClasspath += sourceSets.main.get().output
            runtimeClasspath += sourceSets.main.get().output
        }
    }

    val integTestImplementation by configurations.getting {
        extendsFrom(configurations.implementation.get())
        extendsFrom(configurations.testImplementation.get())
    }
    configurations["integTestRuntimeOnly"].extendsFrom(configurations.runtimeOnly.get())

    dependencies.add("kaptIntegTest", libs.micronaut.inject.java.get())
    dependencies.add("integTestImplementation", libs.micronaut.test.junit5.get())

    tasks.register<Test>("integrationTest") {
        group = "verification"
        description = "Runs integration tests"
        testClassesDirs = sourceSets["integTest"].output.classesDirs
        classpath = sourceSets["integTest"].runtimeClasspath
        shouldRunAfter("test")
    }
}

===== ./common/common-kotlin/common-api/common-api-multitenant/gradle.properties =====
micronautVersion=4.4.3
kotlinVersion=1.9.23

===== ./common/common-kotlin/common-api/common-api-multitenant/micronaut-cli.yml =====
applicationType: default
defaultPackage: example.micronaut
testFramework: junit
sourceLanguage: java
buildTool: gradle
features: [ annotation-api, app-name, data, data-jpa, graalvm, gradle, h2, hibernate-jpa, http-client, jakarta-javax-persistence, java-application, jdbc-hikari, junit, logback, micronaut-build, netty-server, readme, serialization-jackson, shade, spring-boot-java, yaml ]

