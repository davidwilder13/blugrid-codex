===== ./common/common-kotlin/common-api/common-api-security/src/main/kotlin/net/blugrid/api/security/config/RedirectProps.kt =====
package net.blugrid.api.security.config

import io.micronaut.context.annotation.ConfigurationProperties

@ConfigurationProperties("redirect")
interface RedirectProps {

    val loginCallbackUrl: String
    val loginSuccessUrl: String
    val loginFailureUrl: String
    val logoutCallbackUrl: String
    val logoutUrl: String
    val registrationUrl: String
    val registrationCallbackUrl: String
}

===== ./common/common-kotlin/common-api/common-api-security/src/main/kotlin/net/blugrid/api/security/config/SecurityProps.kt =====
package net.blugrid.api.security.config

import io.micronaut.context.annotation.ConfigurationProperties
import io.micronaut.core.bind.annotation.Bindable

@ConfigurationProperties("security")
interface SecurityProps {

    @ConfigurationProperties("auth0")
    class Auth0Config {
        lateinit var audience: String
        lateinit var auth0Domain: String
        lateinit var clientId: String
    }

    @ConfigurationProperties("cookies")
    interface CookieConfig {

        @get:Bindable(defaultValue = "JWT")
        val jwt: String

        @get:Bindable(defaultValue = "OAUTH2_PKCE")
        val oauthPkce: String

        @get:Bindable(defaultValue = "OAUTH2_STATE")
        val oathState: String

        @get:Bindable(defaultValue = "OPENID_NONCE")
        val oathNonce: String

        @get:Bindable(defaultValue = "300000L")
        val maxAge: Long
    }
}

===== ./common/common-kotlin/common-api/common-api-security/src/main/kotlin/net/blugrid/api/security/context/CurrentRequestContext.kt =====
package net.blugrid.api.security.context

import io.micronaut.http.context.ServerRequestContext
import net.blugrid.api.security.model.BaseAuthenticatedOrganisation
import net.blugrid.api.security.model.BaseAuthenticatedSession
import net.blugrid.api.security.model.BaseAuthenticatedUser
import net.blugrid.api.security.model.BusinessUnitAuthentication
import net.blugrid.api.security.model.DecoratedAuthentication
import net.blugrid.api.security.model.GuestAuthentication
import net.blugrid.api.security.model.TenantAuthentication
import toMultitenantAuthentication
import java.util.Optional

object CurrentRequestContext : RequestContextProvider {

    override val currentSessionId: Long?
        get() = authentication?.session?.sessionId?.toLongOrNull()

    override val currentBusinessUnitId: Long?
        get() = when {
            BusinessUnitIdOverride.hasOverride() -> BusinessUnitIdOverride.value.toLong()
            authentication is BusinessUnitAuthentication -> (authentication as BusinessUnitAuthentication)
                .session
                .businessUnitId
                .toLongOrNull()

            else -> null
        }

    override val currentTenantId: Long?
        get() = when {
            TenantIdOverride.hasOverride() -> TenantIdOverride.value.toLong()
            authentication is TenantAuthentication -> (authentication as TenantAuthentication)
                .session
                .tenantId
                .toLongOrNull()

            authentication is BusinessUnitAuthentication -> (authentication as BusinessUnitAuthentication)
                .session
                .tenantId
                .toLongOrNull()

            else -> null
        }

    override val currentIsUnscoped: Boolean
        get() = IsUnscoped.isSet() && IsUnscoped.value

    override val currentOrganisation: BaseAuthenticatedOrganisation?
        get() = when (authentication) {
            is TenantAuthentication -> (authentication as TenantAuthentication).organisation
            is BusinessUnitAuthentication -> (authentication as BusinessUnitAuthentication).organisation
            else -> null
        }

    override val currentSession: BaseAuthenticatedSession?
        get() = when (authentication) {
            is GuestAuthentication -> (authentication as GuestAuthentication).session
            is TenantAuthentication -> (authentication as TenantAuthentication).session
            is BusinessUnitAuthentication -> (authentication as BusinessUnitAuthentication).session
            else -> null
        }

    override val currentUser: BaseAuthenticatedUser?
        get() = when (authentication) {
            is GuestAuthentication -> (authentication as GuestAuthentication).user
            is TenantAuthentication -> (authentication as TenantAuthentication).user
            is BusinessUnitAuthentication -> (authentication as BusinessUnitAuthentication).user
            else -> null
        }

    val authentication: DecoratedAuthentication<out BaseAuthenticatedSession>?
        get() = authenticationOpt.orElse(null)

    val authenticationOpt: Optional<DecoratedAuthentication<out BaseAuthenticatedSession>>
        get() = ServerRequestContext.currentRequest<Any>()
            .flatMap { it.toMultitenantAuthentication() }
}

===== ./common/common-kotlin/common-api/common-api-security/src/main/kotlin/net/blugrid/api/security/context/RequestContextOverride.kt =====
package net.blugrid.api.security.context

import io.micronaut.http.HttpRequest
import io.micronaut.http.context.ServerRequestContext
import java.io.Closeable
import java.util.Optional
import java.util.function.Supplier

abstract class IdOverride(private val attributeName: String) : Closeable {

    var value: String
        get() = currentRequestContext().getStringAttribute(attributeName)
            .orElseThrow {
                IllegalStateException("No $attributeName override found")
            }
        set(value) {
            currentRequestContext().setStringAttribute(attributeName, value)
        }

    fun hasOverride(): Boolean = currentRequestContext().getStringAttribute(attributeName).isPresent

    override fun close() {
        currentRequestContext().removeStringAttribute(attributeName)
    }

    private fun currentRequestContext() = ServerRequestContext.currentRequest<Any?>()
    private fun Optional<HttpRequest<Any>>.getStringAttribute(name: String) = flatMap { it.getAttribute(name, String::class.java) }
    private fun Optional<HttpRequest<Any>>.setStringAttribute(name: String, value: String) = get().setAttribute(name, value)
    private fun Optional<HttpRequest<Any>>.removeStringAttribute(name: String) = flatMap { it.removeAttribute(name, String::class.java) }
}

object IsUnscoped : Closeable {

    private val attributeName = "isUnscoped"

    var value: Boolean
        get() = currentRequestContext().getBooleanAttribute(attributeName)
            .orElseThrow {
                IllegalStateException("No $attributeName override found")
            }
        set(value) {
            currentRequestContext().setBooleanAttribute(attributeName, value)
        }

    fun isSet(): Boolean = currentRequestContext().getBooleanAttribute(attributeName).isPresent

    override fun close() {
        currentRequestContext().removeBooleanAttribute(attributeName)
    }

    private fun currentRequestContext() = ServerRequestContext.currentRequest<Any?>()
    private fun Optional<HttpRequest<Any>>.getBooleanAttribute(name: String) = flatMap { it.getAttribute(name, Boolean::class.java) }
    private fun Optional<HttpRequest<Any>>.setBooleanAttribute(name: String, value: Boolean) = get().setAttribute(name, value)
    private fun Optional<HttpRequest<Any>>.removeBooleanAttribute(name: String) = flatMap { it.removeAttribute(name, Boolean::class.java) }
}

object TenantIdOverride : IdOverride("tenantIdOverride")
object BusinessUnitIdOverride : IdOverride("businessUnitIdOverride")

fun <T> doInRequestContext(action: () -> T): Any? {
    val currentRequest = ServerRequestContext.currentRequest<Any>()

    return if (currentRequest.isPresent) {
        // If the current request context is present, just execute the action
        action()
    } else {
        // If no request context is present, create a new one
        val newRequest: HttpRequest<Any?> = createNewRequest()
        ServerRequestContext.with(newRequest, Supplier { action() })
    }
}

private fun createNewRequest(): HttpRequest<Any?> {
    // Implement this method to create a new HttpRequest object as per your application's needs
    // For instance, you can use a dummy request or a specific request object required by your context
    return HttpRequest.GET("/")
}

===== ./common/common-kotlin/common-api/common-api-security/src/main/kotlin/net/blugrid/api/security/model/AuthenticatedUserIdentity.kt =====
package net.blugrid.api.security.model

import net.blugrid.api.userIdentity.model.UserIdentity
import java.util.UUID

data class AuthenticatedUserIdentity(
    override val id: Long,
    override val uuid: UUID,
    override val name: String,
    override val email: String,
    override val displayName: String?,
    override val emailVerified: Boolean?,
    override val providerId: String,
    override val partyId: Long?,
    override val nickName: String?,
    override val givenName: String?,
    override val familyName: String?,
    override val pictureUrl: String?
) : UserIdentity

===== ./common/common-kotlin/common-api/common-api-security/src/main/kotlin/net/blugrid/api/security/model/AuthenticatedOrganisationModel.kt =====
package net.blugrid.api.security.model

import net.blugrid.api.organisation.model.Organisation

data class AuthenticatedOrganisationModel(
    override val id: Long,
    override val displayName: String?,
    override val partyId: Long?,
    override val primaryPartyId: Long?
) : Organisation

===== ./common/common-kotlin/common-api/common-api-security/src/main/kotlin/net/blugrid/api/security/model/TenantAuthentication.kt =====
package net.blugrid.api.security.model

import io.micronaut.security.authentication.Authentication
import net.blugrid.api.session.model.TenantSession
import java.util.Date

data class TenantAuthentication(
    override val providerId: String,
    override val principalName: String,
    override val principalEmail: String,
    override val sessionId: String,
    override val userId: String,
    override val expirationTime: Date? = null,
    override val user: AuthenticatedUser,
    override val session: TenantSession,
    val organisation: AuthenticatedOrganisation,
) : DecoratedAuthentication<TenantSession>, Authentication {
    override val authenticationType: AuthenticationType = AuthenticationType.TENANT

    override fun getName(): String = principalName

    override fun getAttributes(): Map<String, Any> = mapOf(
        "userId" to user.userIdentityId,
        "sessionId" to session.sessionId,
        "tenantId" to organisation.tenantId,
        "webApplicationId" to session.webApplicationId,
        "authenticationType" to authenticationType.name
    )
}

===== ./common/common-kotlin/common-api/common-api-security/src/main/kotlin/net/blugrid/api/security/model/GuestAuthentication.kt =====
package net.blugrid.api.security.model

import io.micronaut.security.authentication.Authentication
import net.blugrid.api.session.model.GuestSession
import java.util.Date

data class GuestAuthentication(
    override val providerId: String,
    override val principalName: String,
    override val principalEmail: String,
    override val sessionId: String,
    override val userId: String,
    override val expirationTime: Date? = null,
    override val user: AuthenticatedUser,
    override val session: GuestSession,
) : DecoratedAuthentication<GuestSession>, Authentication {
    override val authenticationType: AuthenticationType = AuthenticationType.GUEST

    override fun getName(): String = principalName

    override fun getAttributes(): Map<String, Any> = mapOf(
        "userId" to user.userIdentityId,
        "sessionId" to session.sessionId,
        "webApplicationId" to session.webApplicationId,
        "authenticationType" to authenticationType.name
    )
}

===== ./common/common-kotlin/common-api/common-api-security/src/main/kotlin/net/blugrid/api/security/model/BusinessUnitAuthentication.kt =====
package net.blugrid.api.security.model

import io.micronaut.security.authentication.Authentication
import net.blugrid.api.session.model.BusinessUnitSession
import java.util.Date

data class BusinessUnitAuthentication(
    override val providerId: String,
    override val principalName: String,
    override val principalEmail: String,
    override val sessionId: String,
    override val userId: String,
    override val expirationTime: Date? = null,
    override val user: AuthenticatedUser,
    override val session: BusinessUnitSession,
    val organisation: AuthenticatedOrganisation,
) : DecoratedAuthentication<BusinessUnitSession>, Authentication {
    override val authenticationType: AuthenticationType = AuthenticationType.BUSINESS_UNIT

    override fun getName(): String = principalName

    override fun getAttributes(): Map<String, Any> = mapOf(
        "userId" to user.userIdentityId,
        "sessionId" to session.sessionId,
        "tenantId" to organisation.tenantId,
        "businessUnitId" to session.businessUnitId,
        "webApplicationId" to session.webApplicationId,
        "authenticationType" to authenticationType.name
    )
}

===== ./common/common-kotlin/common-api/common-api-security/src/main/kotlin/net/blugrid/api/security/mapping/AuthenticatedOrganisationMapper.kt =====
package net.blugrid.api.security.mapping

import net.blugrid.api.organisation.model.Organisation
import net.blugrid.api.security.model.AuthenticatedOrganisation

fun Organisation.toAuthenticatedOrganisation(): AuthenticatedOrganisation =
    AuthenticatedOrganisation(
        tenantId = id.toString(),
        partyId = partyId?.toString(),
        primaryPartyId = primaryPartyId?.toString(),
        displayName = displayName
    )

===== ./common/common-kotlin/common-api/common-api-security/src/main/kotlin/net/blugrid/api/security/mapping/AuthenticatedUserMapper.kt =====
package net.blugrid.api.security.mapping

import net.blugrid.api.security.model.AuthenticatedUser
import net.blugrid.api.userIdentity.model.UserIdentity

fun UserIdentity.toAuthenticatedUser(): AuthenticatedUser =
    AuthenticatedUser(
        userIdentityId = id.toString(),
        displayName = displayName,
        email = email,
        emailVerified = emailVerified,
        partyId = partyId.toString(),
        providerId = providerId,
        nickName = nickName,
        givenName = givenName,
        familyName = familyName,
        pictureUrl = pictureUrl
    )

===== ./common/common-kotlin/common-api/common-api-security/src/main/kotlin/net/blugrid/api/security/mapping/AuthenticationMappers.kt =====
package net.blugrid.api.security.mapping

import net.blugrid.api.security.context.BusinessUnitSessionContext
import net.blugrid.api.security.context.GuestSessionContext
import net.blugrid.api.security.context.WebApplicationSessionContext
import net.blugrid.api.security.model.BusinessUnitAuthentication
import net.blugrid.api.security.model.GuestAuthentication
import net.blugrid.api.security.model.TenantAuthentication

fun GuestSessionContext.toAuthentication(): GuestAuthentication =
    GuestAuthentication(
        providerId = user.providerId,
        principalName = user.name,
        principalEmail = user.email,
        sessionId = id.toString(),
        userId = user.id.toString(),
        user = user.toAuthenticatedUser(),
        session = this.toAuthenticatedSession()
    )

fun WebApplicationSessionContext.toAuthentication(): TenantAuthentication =
    TenantAuthentication(
        providerId = user.providerId,
        principalName = user.name,
        principalEmail = user.email,
        sessionId = id.toString(),
        userId = user.id.toString(),
        organisation = organisation.toAuthenticatedOrganisation(),
        session = this.toAuthenticatedSession(),
        user = user.toAuthenticatedUser()
    )

fun BusinessUnitSessionContext.toAuthentication(): BusinessUnitAuthentication =
    BusinessUnitAuthentication(
        providerId = user.providerId,
        principalName = user.name,
        principalEmail = user.email,
        sessionId = id.toString(),
        userId = user.id.toString(),
        organisation = organisation.toAuthenticatedOrganisation(),
        session = this.toAuthenticatedSession(),
        user = user.toAuthenticatedUser()
    )

fun TenantAuthentication.toBusinessUnitAuthentication(
    context: BusinessUnitSessionContext
): BusinessUnitAuthentication =
    BusinessUnitAuthentication(
        providerId = providerId,
        principalName = principalName,
        principalEmail = principalEmail,
        sessionId = sessionId,
        userId = userId,
        expirationTime = expirationTime,
        organisation = organisation,
        session = context.toAuthenticatedSession(),
        user = user
    )


===== ./common/common-kotlin/common-api/common-api-security/src/main/kotlin/net/blugrid/api/security/mapping/OrganisationMappers.kt =====
package net.blugrid.api.security.mapping

import net.blugrid.api.organisation.model.Organisation
import net.blugrid.api.security.model.AuthenticatedOrganisationModel
import net.blugrid.api.security.model.BaseAuthenticatedOrganisation

fun BaseAuthenticatedOrganisation.toOrganisation(): Organisation =
    AuthenticatedOrganisationModel(
        id = tenantId.toLongOrNull() ?: -1L,  // fallback if invalid
        displayName = displayName,
        partyId = partyId?.toLongOrNull(),
        primaryPartyId = primaryPartyId?.toLongOrNull()
    )

===== ./common/common-kotlin/common-api/common-api-security/src/main/kotlin/net/blugrid/api/security/mapping/SessionMappers.kt =====
package net.blugrid.api.security.mapping

import net.blugrid.api.security.context.BusinessUnitSessionContext
import net.blugrid.api.security.context.GuestSessionContext
import net.blugrid.api.security.context.WebApplicationSessionContext
import net.blugrid.api.session.model.BusinessUnitSession
import net.blugrid.api.session.model.GuestSession
import net.blugrid.api.session.model.TenantSession

fun GuestSessionContext.toAuthenticatedSession() = GuestSession(
    sessionId = id.toString(),
    userId = user.id.toString(),
    webApplicationId = webApplicationId.toString(),
)

fun WebApplicationSessionContext.toAuthenticatedSession() = TenantSession(
    sessionId = id.toString(),
    userId = user.id.toString(),
    tenantId = organisation.id.toString(),
    webApplicationId = webApplicationId.toString(),
    operatorId = operatorId.toString()
)

fun BusinessUnitSessionContext.toAuthenticatedSession() = BusinessUnitSession(
    sessionId = id.toString(),
    userId = user.id.toString(),
    tenantId = organisation.id.toString(),
    webApplicationId = webApplicationId.toString(),
    operatorId = operatorId.toString(),
    businessUnitId = businessUnitId.toString()
)

===== ./common/common-kotlin/common-api/common-api-security/src/main/kotlin/net/blugrid/api/security/mapping/UserIdentityMappers.kt =====
package net.blugrid.api.security.mapping

import net.blugrid.api.security.model.AuthenticatedUserIdentity
import net.blugrid.api.security.model.BaseAuthenticatedUser
import net.blugrid.api.userIdentity.model.UserIdentity
import java.util.UUID

fun BaseAuthenticatedUser.toUserIdentity(): UserIdentity =
    AuthenticatedUserIdentity(
        id = userIdentityId.toLong(),
        uuid = try {
            UUID.fromString(userIdentityId)
        } catch (e: Exception) {
            UUID(0L, 0L)
        },
        name = displayName ?: email,
        email = email,
        displayName = displayName,
        emailVerified = emailVerified,
        providerId = providerId,
        partyId = partyId?.toLongOrNull(),
        nickName = nickName,
        givenName = givenName,
        familyName = familyName,
        pictureUrl = pictureUrl
    )

===== ./common/common-kotlin/common-api/common-api-security/src/main/kotlin/net/blugrid/api/security/mapping/HttpRequestAuthenticationExt.kt =====
import com.fasterxml.jackson.core.JsonProcessingException
import com.fasterxml.jackson.databind.JsonNode
import com.fasterxml.jackson.databind.ObjectMapper
import com.nimbusds.jwt.JWT
import io.micronaut.http.HttpRequest
import io.micronaut.security.filters.SecurityFilter
import net.blugrid.api.security.model.AuthenticatedOrganisation
import net.blugrid.api.security.model.AuthenticatedUser
import net.blugrid.api.security.model.AuthenticationType
import net.blugrid.api.security.model.BaseAuthenticatedSession
import net.blugrid.api.security.model.BusinessUnitAuthentication
import net.blugrid.api.security.model.DecoratedAuthentication
import net.blugrid.api.security.model.GuestAuthentication
import net.blugrid.api.security.model.TenantAuthentication
import net.blugrid.api.session.model.BusinessUnitSession
import net.blugrid.api.session.model.GuestSession
import net.blugrid.api.session.model.TenantSession
import org.slf4j.Logger
import java.time.Instant
import java.util.Date
import java.util.Optional

@Suppress("UNCHECKED_CAST")
fun HttpRequest<*>.toMultitenantAuthentication(): Optional<DecoratedAuthentication<out BaseAuthenticatedSession>> {
    val attributeValue = attributes.getValue(SecurityFilter.AUTHENTICATION)
    return if (attributeValue is DecoratedAuthentication<*>) {
        Optional.of(attributeValue)
    } else {
        Optional.empty()
    }
}

fun JWT.toMultitenantAuthentication(log: Logger, objectMapper: ObjectMapper): DecoratedAuthentication<out BaseAuthenticatedSession>? =
    try {
        val rootNode: JsonNode = objectMapper.readTree(jwtClaimsSet.toString())

        val providerId = rootNode.get("provider_id").asText()
        val principalName = rootNode.get("principal_name").asText()
        val principalEmail = rootNode.get("principal_email").asText()
        val sessionId = rootNode.get("session_id").asText()
        val userId = rootNode.get("user_identity_id").asText()
        val expirationTime = rootNode.toExpirationTime()
        val webApplicationId = rootNode.get("web_application_id")?.asText() ?: "100000001"

        val user = rootNode.toAuthenticatedUser(objectMapper)

        val authenticationType = objectMapper.readValue(
            rootNode.get("authentication_type").toString(),
            AuthenticationType::class.java
        )

        when (authenticationType!!) {
            AuthenticationType.GUEST -> GuestAuthentication(
                providerId = providerId,
                principalName = principalName,
                principalEmail = principalEmail,
                sessionId = sessionId,
                userId = userId,
                expirationTime = expirationTime,
                session = rootNode.toAuthenticatedGuestSession(objectMapper),
                user = user,
            )

            AuthenticationType.TENANT -> TenantAuthentication(
                providerId = providerId,
                principalName = principalName,
                principalEmail = principalEmail,
                sessionId = sessionId,
                userId = userId,
                expirationTime = expirationTime,
                organisation = rootNode.toAuthenticatedOrganisation(objectMapper),
                session = rootNode.toAuthenticatedWebApplicationSession(objectMapper),
                user = user,
            )

            AuthenticationType.BUSINESS_UNIT -> BusinessUnitAuthentication(
                providerId = providerId,
                principalName = principalName,
                principalEmail = principalEmail,
                sessionId = sessionId,
                userId = userId,
                expirationTime = expirationTime,
                organisation = rootNode.toAuthenticatedOrganisation(objectMapper),
                session = rootNode.toAuthenticatedBusinessUnitSession(objectMapper),
                user = user,
            )
        }
    } catch (e: JsonProcessingException) {
        log.error("Error decoding authentication: ${e.message}")
        null
    }

fun JsonNode.toAuthenticatedOrganisation(objectMapper: ObjectMapper): AuthenticatedOrganisation {
    val organisationNode: JsonNode = get("organisation")
    return objectMapper.treeToValue(organisationNode, AuthenticatedOrganisation::class.java)
}

fun JsonNode.toAuthenticatedGuestSession(objectMapper: ObjectMapper): GuestSession {
    val sessionNode: JsonNode = get("session")
    return objectMapper.treeToValue(sessionNode, GuestSession::class.java)
}

fun JsonNode.toAuthenticatedBusinessUnitSession(objectMapper: ObjectMapper): BusinessUnitSession {
    val sessionNode: JsonNode = get("session")
    return objectMapper.treeToValue(sessionNode, BusinessUnitSession::class.java)
}

fun JsonNode.toAuthenticatedWebApplicationSession(objectMapper: ObjectMapper): TenantSession {
    val organisationNode: JsonNode = get("session")
    return objectMapper.treeToValue(organisationNode, TenantSession::class.java)
}

fun JsonNode.toAuthenticatedUser(objectMapper: ObjectMapper): AuthenticatedUser {
    val userNode: JsonNode = get("user")
    return objectMapper.treeToValue(userNode, AuthenticatedUser::class.java)
}

fun JsonNode.toExpirationTime(): Date? {
    val expirationTimeStr = get("expiration_time")?.asText()
    return if (expirationTimeStr != null) {
        try {
            Date.from(Instant.parse(expirationTimeStr))
        } catch (e: Exception) {
            null
        }
    } else {
        null
    }
}

===== ./common/common-kotlin/common-api/common-api-security/src/main/kotlin/net/blugrid/api/security/mapping/JwtAuthenticationMapper.kt =====
package net.blugrid.api.security.mapping

import io.micronaut.security.authentication.Authentication
import net.blugrid.api.jwt.model.JwtToken
import net.blugrid.api.security.model.AuthenticatedOrganisation
import net.blugrid.api.security.model.AuthenticationType
import net.blugrid.api.security.model.BusinessUnitAuthentication
import net.blugrid.api.security.model.DecoratedAuthentication
import net.blugrid.api.security.model.GuestAuthentication
import net.blugrid.api.security.model.TenantAuthentication
import net.blugrid.api.session.model.BusinessUnitSession
import net.blugrid.api.session.model.GuestSession
import net.blugrid.api.session.model.TenantSession

/**
 * Maps a JwtToken + AuthenticationType into a concrete Authentication implementation
 * (Tenant, Guest, or BusinessUnit).
 */
fun JwtToken.toAuthentication(type: AuthenticationType): Authentication = when (type) {
    AuthenticationType.GUEST -> toGuestAuthentication()
    AuthenticationType.TENANT -> toTenantAuthentication()
    AuthenticationType.BUSINESS_UNIT -> toBusinessUnitAuthentication()
}

fun JwtToken.toGuestAuthentication(): GuestAuthentication = GuestAuthentication(
    providerId = user.providerId,
    principalName = user.displayName ?: user.email,
    principalEmail = user.email,
    sessionId = session.sessionId,
    userId = user.userIdentityId,
    expirationTime = expirationTime,
    session = session as GuestSession,
    user = user
)

fun JwtToken.toTenantAuthentication(): TenantAuthentication = TenantAuthentication(
    providerId = user.providerId,
    principalName = user.displayName ?: user.email,
    principalEmail = user.email,
    sessionId = session.sessionId,
    userId = user.userIdentityId,
    organisation = organisation as AuthenticatedOrganisation,
    session = session as TenantSession,
    user = user
)

fun JwtToken.toBusinessUnitAuthentication(): BusinessUnitAuthentication = BusinessUnitAuthentication(
    providerId = user.providerId,
    principalName = user.displayName ?: user.email,
    principalEmail = user.email,
    sessionId = session.sessionId,
    userId = user.userIdentityId,
    organisation = organisation as AuthenticatedOrganisation,
    session = session as BusinessUnitSession,
    user = user
)

fun DecoratedAuthentication<*>.toJwtToken(): JwtToken = when (this) {
    is GuestAuthentication -> toGuestJwtToken()
    is TenantAuthentication -> toTenantJwtToken()
    is BusinessUnitAuthentication -> toBusinessUnitJwtToken()
    else -> throw IllegalArgumentException("Unsupported authentication: $this")
}

fun GuestAuthentication.toGuestJwtToken(): JwtToken =
    JwtToken(
        authenticationType = authenticationType,
        user = user,
        session = session,
        expirationTime = expirationTime,
    )

fun TenantAuthentication.toTenantJwtToken(): JwtToken =
    JwtToken(
        authenticationType = authenticationType,
        user = user,
        session = session,
        organisation = organisation,
        expirationTime = expirationTime,
    )

fun BusinessUnitAuthentication.toBusinessUnitJwtToken(): JwtToken =
    JwtToken(
        authenticationType = authenticationType,
        user = user,
        session = session,
        organisation = organisation,
        expirationTime = expirationTime,
    )

===== ./common/common-kotlin/common-api/common-api-security/src/main/kotlin/net/blugrid/api/security/mapping/JwtAuthenticationDecoder.kt =====
package net.blugrid.api.security.mapping

import com.fasterxml.jackson.databind.JsonNode
import com.fasterxml.jackson.databind.ObjectMapper
import com.nimbusds.jwt.JWT
import io.micronaut.security.authentication.Authentication
import net.blugrid.api.jwt.model.JwtToken
import net.blugrid.api.security.model.AuthenticationType
import org.slf4j.Logger

fun JWT.toMultitenantAuthentication(
    log: Logger,
    objectMapper: ObjectMapper
): Authentication? =
    try {
        val rootNode: JsonNode = objectMapper.readTree(jwtClaimsSet.toString())
        val authType = objectMapper.readValue(
            rootNode.get("authentication_type").toString(),
            AuthenticationType::class.java
        )
        val jwtToken = objectMapper.treeToValue(rootNode, JwtToken::class.java)
        jwtToken.toAuthentication(authType)
    } catch (e: Exception) {
        log.error("JWT decode failed: ${e.message}", e)
        null
    }

===== ./common/common-kotlin/common-api/common-api-security/src/main/resources/jwks.json =====
{
  "keys": [
    {
      "kty": "RSA",
      "use": "sig",
      "kid": "test-key-id",
      "n": "ANnWlsN92SQIavWlqw3zYJsabKNR_eLW7iA8kbIKGWsUS4FLRgdbGxTUYmncOB6G_EsUUX_POxxC8OO6Q6RsPpoafGDHCoDg_PCS3HTxrs_3VJcwQpeVnlnhgL2L1QOJ2uy-Y8tMlYNXQeMcbNtcF5ZKjNMbLCCjeqs0wnb8cW7pd_CqF5qyN_EbbqAhgZpEiVTO6MY736TasR4Y4VtoPs1DQAgPZz4Wg_Ll0BCsDGhcGFz7ciob3W6gDO6epfsS_9wW_IMTrWw3b6dXPvgkP5uRZDtVg4uiBZlwfWSp77vCA97_pMAdzlFOSwbOEiCThyyUvHQBj9XVzCRadmDIyus=",
      "e": "AQAB"
    }
  ]
}
===== ./common/common-kotlin/common-api/common-api-security/src/main/resources/keystore.jks =====
˛Ì˛Ì          jwt_key  ê›°ÿ.  0Ç˝0
+* ÇÈ#}ˆD.˚74√yJ4r íŸmu˘*ö1]•µ@â˙~|<ﬂTÏﬁÇãB
ÿëâàºA56Ïm=8â˘Ê∑∫ãƒîSπÊÁÆx|x˚qœ]‡'8°Fqõ∆@D	Cºº†<]Ù∏˚+»#¿˘>∫_Ã•˜¬Rdó ˚ê--4ƒ∞9¿ùå'±Àq∞Ãjﬁß[ÉÌBËçx…û°d^yƒ(ÃX>í±7®≈⁄5wïﬂ~VJ‚5Ú„πÎXÁ\]wK‹´ôä2Ê&äÄ
Ú±›¨µXÖ√QËy¡¸kjå∑ZÇ,¯åó[H<ª∆:ÒìÆE1÷Z 6È∂	|ß‡oAtU%ÏtÃØX∆Jò„ää˝QN@°ÄP_‚ /ÛﬁàC'ÿDé_h,äYqZ[Ô]ˇÙ…⁄ﬁPÚÀ±^m˝U¬dV9™}MV®¨∂cLÙ72E◊Üßøëv®Ì‘p%˝Ï`›Æ¥4t¶ë0ÿ~ÅË?ã|π⁄"ÙKJ£Ú¨ù§â;îØ2Ìù÷?◊⁄Bv§µo(Y∆mÀ9œùq4≠'∏£/Øôsù\”ÈOıß≈_—'}µ7¢ÆûV¢:®ı$p˝ví¿ÁÊ?Ëñ\œ|gdGæ˛ƒ:DP_∑Œøúnç_ ~ ˝,x≤}ˆ~,o‡√ûÛÕM!¬VÃÏä;v‚âôD©ù“µ‹õM42®∏ßÀ\èG≥\”R¥É`$átÕÆ®[ëßòí·pŸéÓÌ#ñÿhˇ˜•ﬂ}_yïz†tå#∆°ÅΩ°dlÕèÙd&«eiøå¬Ò!ŸùÄ¨,RÚ‹svC©Ï\¥Ë§¸XÒ“Ú!Ö˚‹~°®nQß#‰ê≈©õ“πz·ﬁÄıguÍL˛o¯DÙ4ﬁÛÊ‰w–Åë¬y,∂+@‹È∏4OÈbD=je´¸˝ÄÙ"8∑D,9ã{@≤™Á∞Ñü63ià°Ï|¥y’ï^ûBÀäût~2Y1õˇ ˜?¿dﬁ…{ugcX·≤YŒ•ë*q˝¿‘¸∆?\"#Q±ÆÉTm€åAZÈ>â\8¨à—€¯oÑ)+ôX∏ì67∏cRïÇûœŒ∑§V¨ê
Êå,Ω”Åˇ •ùBvuo–64 ◊x»”A˚ÓN!Ãn'@—.H0ÚxXQ¬RAi˚+HeÅ{^˜r3,ë.x¥s/z–»IãQéæ–˜⁄™⁄r(nf)w≠XLY'pÂJ,|Ô˜eÒ;m_†G6q9û{å´¨z¡`¨)—ÃL∑ÑÒ1êˆUeÔƒΩLxiQ‡d∂Ã∆	π-Œ5qcétò∂*ôÚóÅF.@ˆö`fßÂ'ã5ÊT
®@ﬁ(’0ıòµ’sRvØj≤Öa}ÕÙÙß˙êrúê`ØH•¥ÉÿK◊ªít€îŒH6F.å;«	\Êu'A3*¬#ÅâF{Ωkœ$E &=ŒÏ≠—¬¸õQ˘/ÇE r ãü  πWMºöåuB“§Eeÿ
ñ…ã3†i@ÓN 9•÷ÛﬂÄ VªÃ%to≠
nîCáÚvXÿAıúX§#xÅ⁄¥°Ûà∫›ÏB)P—4ë-Åõ¢çòJì*¶¿®ÈIâAœ”Ô≈ZçVl7á”§dÔ˙Ÿ¸—ZXÏ    X.509  Ä0Ç|0Çd†	 ≤k˛Ã…_í0	*ÜHÜ˜ 0l10UUnknown10UUnknown10UUnknown10U
Unknown10UUnknown10UUnknown0240723032800Z340721032800Z0l10UUnknown10UUnknown10UUnknown10U
Unknown10UUnknown10UUnknown0Ç"0	*ÜHÜ˜ Ç 0Ç
Ç Ÿ÷ñ√}Ÿ$jı•´Û`õl£Q˝‚÷Ó <ë≤
kKÅKF[‘bi‹8Ü¸KQœ;B„∫C§l>ö|`«
Ä‡¸í‹tÒÆœ˜Tó0BóïûY·ÄΩã’â⁄ÏæcÀLïÉWA„l€\ñJå”, £z´4¬v¸qnÈw™ö≤7Òn†!ÅöDâTŒË∆;ﬂ§⁄±·[h>ÕC@g>ÉÚÂ–¨h\\˚r*›n†Óû•˚ˇ‹¸É≠l7oßW>¯$?õëd;UÉã¢ôp}d©Ôª¬ﬁˇ§¿ŒQNKŒ ìá,îºtè’’Ã$Zv`» Î £!00U˚µMµÿÖ£ÅB	§Gﬁxı¡∂{âº0	*ÜHÜ˜ Ç …1Ó«•iÊîæä⁄ƒåïÏõ≤¬pøçÅa¿‹TØßﬂ%ÁFë%	%zŒ¶M›WâÄ∆AL®˘x®ìh¬g
S{ Áøm˛Û∑≈≈
Ê-¡i7Ò´(K•9¡«ñ7Ú¥Ÿ©0ﬂï˙ñåüÇQájÆqD˘ÙêœÚ˘i^< €Zj˚Ãó„ßîƒ¥Ï”ı†`x~g√™⁄^â4˛ÏMûyô‰l=¬è|ÀqÅ|"´’ˆ Ì/¸‚mÿ÷Ä@÷84*yı≠◊nÁR‡9m˜‰∑L\ÄJx<6ÀÙBÉ6Í çˇ;nÄÕ‘ÚËêzUß\«®&F0uB‘76,T;M$(
ª/¿
9Ö¡sﬁ˚ÀßÆ˜•\]=õ
===== ./common/common-kotlin/common-api/common-api-security/scripts/readme.md =====
# Scripts Directory

This directory contains scripts and utilities to manage keys and certificates for JWT token signing and verification.

## Contents

- `keystore.jks`: The Java KeyStore file containing the RSA key pair.
- `publickey.cert`: The public key certificate exported from the keystore.
- `PublicKeyExtractor.java`: A Java program to extract the public key and generate a `jwks.json` file.
- `PublicKeyExtractor.kt`: A Kotlin version of the program to extract the public key and generate a `jwks.json` file.

## Steps to Generate Keys and Create JWKS File

### 1. Create the Keystore File

Use the following command to generate an RSA key pair and store it in a Java KeyStore (JKS) file:

```sh
keytool -genkeypair -alias test-alias -keyalg RSA -keysize 2048 -keystore keystore.jks -storetype JKS -validity 3650
```

You will be prompted to enter the keystore password and other details.

### 2. Export the Public Key Certificate

Use the following command to export the public key certificate from the keystore to a file:

```sh
keytool -exportcert -alias test-alias -keystore keystore.jks -rfc -file publickey.cert
```

This will create a file named `publickey.cert` containing the public key certificate in PEM format.

### 3. Run the PublicKeyExtractor to Generate JWKS

#### Using Java

1. Compile the `PublicKeyExtractor.java` file:

    ```sh
    javac scripts/PublicKeyExtractor.java
    ```

2. Run the `PublicKeyExtractor` program to generate the `jwks.json` file:

    ```sh
    java -cp scripts PublicKeyExtractor
    ```

#### Using Kotlin

1. Compile the `PublicKeyExtractor.kt` file (if you have a Kotlin version):

    ```sh
    kotlinc scripts/PublicKeyExtractor.kt -include-runtime -d PublicKeyExtractor.jar
    ```

2. Run the `PublicKeyExtractor` program to generate the `jwks.json` file:

    ```sh
    java -jar PublicKeyExtractor.jar
    ```

### 4. Copy the `jwks.json` File

After running the `PublicKeyExtractor`, the `jwks.json` file will be created in the `scripts` directory. Copy this file to your `src/main/resources` directory in your Micronaut project or upload it to a location accessible to your clients.

### Example `application.yml` Configuration

Make sure your `application.yml` file is configured to use the `jwks.json` file:

```yaml
micronaut:
  security:
    token:
      cookie:
        enabled: true
      jwt:
        enabled: true
        signatures:
          jwks-static:
            selfSigned:
              path: "jwks.json"
```

This setup ensures that your Micronaut application can load the JWKS configuration and use it to verify JWT tokens.

## Summary

1. **Create Keystore**: Generate an RSA key pair and store it in a JKS keystore.
2. **Export Public Key**: Export the public key certificate from the keystore.
3. **Generate JWKS**: Run the `PublicKeyExtractor` to create the `jwks.json` file.
4. **Copy JWKS**: Copy the `jwks.json` file to your `src/main/resources` directory or upload it to a location accessible to clients.

===== ./common/common-kotlin/common-api/common-api-security/scripts/publickey.cert =====
-----BEGIN CERTIFICATE-----
MIIDfDCCAmSgAwIBAgIJALIFa/7MyV+SMA0GCSqGSIb3DQEBCwUAMGwxEDAOBgNV
BAYTB1Vua25vd24xEDAOBgNVBAgTB1Vua25vd24xEDAOBgNVBAcTB1Vua25vd24x
EDAOBgNVBAoTB1Vua25vd24xEDAOBgNVBAsTB1Vua25vd24xEDAOBgNVBAMTB1Vu
a25vd24wHhcNMjQwNzIzMDMyODAwWhcNMzQwNzIxMDMyODAwWjBsMRAwDgYDVQQG
EwdVbmtub3duMRAwDgYDVQQIEwdVbmtub3duMRAwDgYDVQQHEwdVbmtub3duMRAw
DgYDVQQKEwdVbmtub3duMRAwDgYDVQQLEwdVbmtub3duMRAwDgYDVQQDEwdVbmtu
b3duMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA2daWw33ZJAhq9aWr
DfNgmxpso1H94tbuIDyRsgoZaxRLgUtGB1sbFNRiadw4Hob8SxRRf887HELw47pD
pGw+mhp8YMcKgOD88JLcdPGuz/dUlzBCl5WeWeGAvYvVA4na7L5jy0yVg1dB4xxs
21wXlkqM0xssIKN6qzTCdvxxbul38KoXmrI38RtuoCGBmkSJVM7oxjvfpNqxHhjh
W2g+zUNACA9nPhaD8uXQEKwMaFwYXPtyKhvdbqAM7p6l+xL/3Bb8gxOtbDdvp1c+
+CQ/m5FkO1WDi6IFmXB9ZKnvu8ID3v+kwB3OUU5LBs4SIJOHLJS8dAGP1dXMJFp2
YMjK6wIDAQABoyEwHzAdBgNVHQ4EFgQU+7VNtdiFo4FCCaRH3nj1wbZ7ibwwDQYJ
KoZIhvcNAQELBQADggEBAMkx7hDHpWnmlL6K2sSMleybshHCcL+NgWHA3FSvGKff
JedGkSXwCQcles6mTd1XiYDGHRNBTKgD+Xiok2jCZwpTGXsA579t/vO3xcUK5i3B
BGk38asoS6U5wceWN/K02QepMB7flQ/6loyfglGHaq5xRPn0kAILDQHP8vlpXjzK
21pq+8yX46eUxLTs0/WgYHh+Z8Oq2l6JNP7sTZ55meRsPcKPfMtxgXwiq9X2yu0H
L/zibdjWgEDWODQqeRwR9a3XCG7nUuA5bffkt0xcgEp4PDbL9EKDNuogGhWN/ztu
gM3U8uiQG3pVp1zHqCZGFDB1Qh3UNzYsVDtNAyQoCg4=
-----END CERTIFICATE-----

===== ./common/common-kotlin/common-api/common-api-security/scripts/PublicKeyExtractor.java =====
import java.io.FileInputStream;
import java.io.FileWriter;
import java.security.cert.CertificateFactory;
import java.security.cert.X509Certificate;
import java.security.interfaces.RSAPublicKey;
import java.util.Base64;

public class PublicKeyExtractor {

    public static void main(String[] args) throws Exception {
        String certificateFile = "publickey.cert";
        String keyId = "test-key-id"; // Use a unique key ID

        // Load the public key certificate
        CertificateFactory certFactory = CertificateFactory.getInstance("X.509");
        FileInputStream fis = new FileInputStream(certificateFile);
        X509Certificate cert = (X509Certificate) certFactory.generateCertificate(fis);
        RSAPublicKey publicKey = (RSAPublicKey) cert.getPublicKey();

        // Extract the modulus and exponent
        String modulus = Base64.getUrlEncoder().encodeToString(publicKey.getModulus().toByteArray());
        String exponent = Base64.getUrlEncoder().encodeToString(publicKey.getPublicExponent().toByteArray());

        // Create the JWKS JSON string
        String jwkTemplate = "{\n" +
                "  \"keys\": [\n" +
                "    {\n" +
                "      \"kty\": \"RSA\",\n" +
                "      \"use\": \"sig\",\n" +
                "      \"kid\": \"%s\",\n" +
                "      \"n\": \"%s\",\n" +
                "      \"e\": \"%s\"\n" +
                "    }\n" +
                "  ]\n" +
                "}";
        String jwks = String.format(jwkTemplate, keyId, modulus, exponent);

        // Write the JWKS JSON string to a file
        try (FileWriter file = new FileWriter("jwks.json")) {
            file.write(jwks);
        }

        System.out.println("JWKS JSON file created successfully: jwks.json");
    }
}

===== ./common/common-kotlin/common-api/common-api-security/build.gradle.kts =====
plugins {
    alias(libs.plugins.jvm)
    alias(libs.plugins.kapt)
    alias(libs.plugins.allopen)
    alias(libs.plugins.application)
}

dependencies {
    // API dependencies - expose to consumers
    api(project(":common:common-kotlin:common-api:common-api-model"))
    api(project(":common:common-kotlin:common-api:common-api-jwt"))

    // JSON processing for JWT token parsing
    implementation(project(":common:common-kotlin:common-api:common-api-json"))

    // Platform BOMs
    implementation(platform(libs.micronaut.bom))
    implementation(platform(libs.aws.bom))

    // Core dependencies using new bundles
    implementation(libs.bundles.kotlinCore)
    implementation(libs.bundles.micronautCore)
    implementation(libs.bundles.micronautSecurity)

    // Reactive support for AuthenticationFetcher
    implementation(libs.micronaut.reactor)               // Reactor core integration
    implementation(libs.micronaut.reactor.http.client)   // HTTP reactive support

    // Jackson dependencies for JWT parsing (explicit)
    implementation(libs.bundles.jsonLibs)        // Complete JSON stack
    implementation(libs.micronaut.jackson)       // Micronaut Jackson integration

    // Additional security libraries
    implementation(libs.nimbus.jose.jwt)         // JWT/JOSE support

    // Annotation processing
    kapt(libs.bundles.annotationProcessors)

    // Compile-only dependencies
    compileOnly(libs.bundles.compileOnly)

    // Runtime dependencies
    runtimeOnly(libs.bundles.runtimeCore)
    runtimeOnly(libs.bundles.runtimeSecurity)

    // Test dependencies
    testImplementation(libs.bundles.testing) {
        exclude(group = "org.slf4j", module = "slf4j-api")
    }
}

java {
    sourceCompatibility = JavaVersion.toVersion("17")
}

kapt {
    arguments {
        arg("micronaut.openapi.project.dir", projectDir.toString())
    }
}

micronaut {
    runtime("netty")
    testRuntime("junit5")
    processing {
        incremental(true)
        annotations("net.blugrid.api.*")
    }
}

