===== ./common/common-kotlin/common-api/common-api-json/src/main/kotlin/net/blugrid/api/json/config/ObjectMapperBeanListener.kt =====
//package net.blugrid.api.json.config
//
//import com.fasterxml.jackson.databind.ObjectMapper
//import io.micronaut.context.event.BeanCreatedEvent
//import io.micronaut.context.event.BeanCreatedEventListener
//import jakarta.inject.Singleton
//
//@Singleton
//open class ObjectMapperBeanEventListener(
//    private val objectMapperFactory: CustomObjectMapperFactory
//) : BeanCreatedEventListener<ObjectMapper> {
//
//    override fun onCreated(event: BeanCreatedEvent<ObjectMapper>): ObjectMapper {
//        return objectMapperFactory.objectMapper(null, null)
//    }
//}

===== ./common/common-kotlin/common-api/common-api-json/src/main/kotlin/net/blugrid/api/json/config/CustomObjectMapperFactory.kt =====
package net.blugrid.api.json.config

import com.fasterxml.jackson.annotation.JsonInclude
import com.fasterxml.jackson.core.JsonFactory
import com.fasterxml.jackson.core.JsonGenerator
import com.fasterxml.jackson.core.StreamReadFeature
import com.fasterxml.jackson.databind.DeserializationFeature
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.databind.SerializationFeature
import com.fasterxml.jackson.databind.SerializerProvider
import com.fasterxml.jackson.databind.module.SimpleModule
import com.fasterxml.jackson.databind.ser.std.StdSerializer
import com.fasterxml.jackson.datatype.jdk8.Jdk8Module
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule
import com.fasterxml.jackson.datatype.jsr310.deser.LocalDateTimeDeserializer
import com.fasterxml.jackson.datatype.jsr310.ser.LocalDateTimeSerializer
import com.fasterxml.jackson.module.kotlin.KotlinModule
import io.micronaut.context.annotation.Replaces
import io.micronaut.jackson.JacksonConfiguration
import io.micronaut.jackson.ObjectMapperFactory
import jakarta.inject.Singleton
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

@Singleton
@Replaces(ObjectMapperFactory::class)
open class CustomObjectMapperFactory : ObjectMapperFactory() {

    companion object {
        lateinit var objectMapper: ObjectMapper

        private const val LOCAL_DATE_TIME_FORMAT = "yyyy-MM-dd'T'HH:mm:ss.SSS"
    }

    @Singleton
    @Replaces(ObjectMapper::class)
    override fun objectMapper(jacksonConfiguration: JacksonConfiguration?, jsonFactory: JsonFactory?): ObjectMapper {
        val factory = JsonFactory.builder()
            .enable(StreamReadFeature.INCLUDE_SOURCE_IN_LOCATION)
            .build()

        objectMapper = super.objectMapper(jacksonConfiguration, factory)

        // JsonGenerator
        objectMapper.configure(JsonGenerator.Feature.WRITE_BIGDECIMAL_AS_PLAIN, true)

        // Serialization
        objectMapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false)
        objectMapper.configure(SerializationFeature.WRITE_DATE_TIMESTAMPS_AS_NANOSECONDS, false)
        objectMapper.configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false)
        objectMapper.configure(SerializationFeature.WRITE_ENUMS_USING_TO_STRING, true)
        // configure(WRITE_NUMBERS_AS_STRINGS.mappedFeature(), true)
        // NB: Consul registration fail if port number (Integer) is string. Replaced with custom serializer for Longs only.

        // Deserialization
        objectMapper.configure(DeserializationFeature.ACCEPT_EMPTY_ARRAY_AS_NULL_OBJECT, true)
        objectMapper.configure(DeserializationFeature.ACCEPT_EMPTY_STRING_AS_NULL_OBJECT, true)
        objectMapper.configure(DeserializationFeature.ACCEPT_SINGLE_VALUE_AS_ARRAY, true)
        objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)
        objectMapper.configure(DeserializationFeature.FAIL_ON_NULL_FOR_PRIMITIVES, false)
        objectMapper.configure(DeserializationFeature.READ_DATE_TIMESTAMPS_AS_NANOSECONDS, false)
        objectMapper.configure(DeserializationFeature.READ_ENUMS_USING_TO_STRING, true)
        objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL)
        objectMapper.registerModule(Jdk8Module())
        objectMapper.registerModule(KotlinModule.Builder().build())
        objectMapper.registerModule(
            SimpleModule()
                .addSerializer(
                    Long::class.java,
                    LongToStringSerializer()
                )
        )
        objectMapper.registerModule(
            JavaTimeModule()
                .addSerializer(LocalDateTimeSerializer(DateTimeFormatter.ofPattern(LOCAL_DATE_TIME_FORMAT))) // .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(LOCAL_DATE_TIME_FORMAT)))
                .addDeserializer(
                    LocalDateTime::class.java,
                    LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(LOCAL_DATE_TIME_FORMAT)),
                ),
        )
        return objectMapper
    }
}

class LongToStringSerializer : StdSerializer<Long>(Long::class.java) {
    override fun serialize(value: Long?, generator: JsonGenerator, provider: SerializerProvider) {
        value?.let {
            generator.writeString(it.toString())
        }
            ?: generator.writeNull()
    }
}




===== ./common/common-kotlin/common-api/common-api-json/src/main/kotlin/net/blugrid/api/json/config/DbLocalDateTimeDeserializer.kt =====
// package net.blugrid.api.json.config
//
// import net.blugrid.api.common.logging.logger
// import io.jsonwebtoken.io.Deserializer
// import io.micronaut.context.annotation.Primary
// import io.micronaut.core.type.Argument
// import io.micronaut.serde.Decoder
// import io.micronaut.serde.Deserializer
// import io.micronaut.serde.Deserializer.DecoderContext
// import jakarta.inject.Singleton
// import java.time.LocalDateTime
// import java.time.format.DateTimeFormatter
// import java.time.format.DateTimeParseException
//
// @Singleton
// @Primary
// class DbLocalDateTimeDeserializer : Deserializer<LocalDateTime> {
//
//    private val log = logger()
//
//    companion object {
//        private val FORMATTERS = listOf(
//            DateTimeFormatter.ISO_DATE_TIME,
//            DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss.SSSSSSxxx"),
//        )
//    }
//
//    override fun deserialize(decoder: Decoder, context: DecoderContext, type: Argument<in LocalDateTime>): LocalDateTime? {
//        val str = decoder.decodeString()
//        return FORMATTERS.firstNotNullOf { it.tryDeserialize(str) }
//    }
//
//    private fun DateTimeFormatter.tryDeserialize(date: String): LocalDateTime? {
//        return try {
//            LocalDateTime.parse(date, this)
//        } catch (e: DateTimeParseException) {
//            log.warn("Cannot deserialize date ($date) with Format (${this}): ${e.cause}")
//            null
//        }
//    }
// }

===== ./common/common-kotlin/common-api/common-api-json/src/main/kotlin/net/blugrid/api/json/Json.kt =====
package net.blugrid.api.json

import com.fasterxml.jackson.core.JsonProcessingException
import com.fasterxml.jackson.core.type.TypeReference
import com.fasterxml.jackson.databind.JsonNode
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.module.kotlin.readValue
import net.blugrid.api.json.config.CustomObjectMapperFactory
import net.blugrid.api.json.exception.JsonException
import java.io.IOException
import java.io.InputStream


val objectMapper: ObjectMapper = CustomObjectMapperFactory.objectMapper

inline fun <reified T : Any> String.fromJson() = objectMapper.readValue<T>(this)

inline fun <reified R : Any> R.toJson() = objectToJson(this)

fun <T> readValue(json: String?, valueType: Class<T>?): T =
    try {
        objectMapper.readValue(json, valueType)
    } catch (e: JsonProcessingException) {
        throw JsonException(e)
    }

fun <T> fromJson(bytes: ByteArray?, typeRef: TypeReference<T>?): T =
    try {
        objectMapper.readValue(bytes, typeRef)
    } catch (e: IOException) {
        throw JsonException(e)
    }

fun <T> fromJson(json: String?, typeRef: TypeReference<T>?): T {
    return try {
        objectMapper.readValue(json, typeRef)
    } catch (e: IOException) {
        throw JsonException(e)
    }
}

fun <T> fromNode(node: JsonNode, typeRef: TypeReference<T>?): T = try {
    objectMapper.readValue(node.toString(), typeRef)
} catch (e: IOException) {
    throw JsonException(e)
}

fun <T> fromObject(obj: Any?, typeRef: TypeReference<T>?): T = try {
    objectMapper.readValue(objectToJson(obj), typeRef)
} catch (e: IOException) {
    throw JsonException(e)
}

fun <T> fromInputStream(`is`: InputStream?, typeRef: TypeReference<T>?): T = try {
    objectMapper.readValue(`is`, typeRef)
} catch (e: IOException) {
    throw JsonException(e)
}

fun objectToJson(obj: Any?): String {
    return try {
        objectMapper.writeValueAsString(obj)
    } catch (e: IOException) {
        throw JsonException(e)
    }
}

fun toPrettyJson(obj: Any?): String = try {
    objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(obj)
} catch (e: IOException) {
    throw JsonException(e)
}

fun toByteArray(obj: Any?): ByteArray = try {
    objectMapper.writeValueAsBytes(obj)
} catch (e: IOException) {
    throw JsonException(e)
}

fun mapFromJson(bytes: ByteArray?): Map<String, Any> = try {
    objectMapper.readValue(bytes, object : TypeReference<Map<String, Any>>() {})
} catch (e: IOException) {
    throw JsonException(e)
}

fun mapFromJson(json: String?): Map<String, Any> = try {
    objectMapper.readValue(json, object : TypeReference<Map<String, Any>>() {})
} catch (e: IOException) {
    throw JsonException(e)
}

fun <T> deserializeListFromJson(json: String?, type: Class<T>?): List<T> = try {
    objectMapper.readValue(json, objectMapper.typeFactory.constructCollectionType(MutableList::class.java, type))
} catch (e: IOException) {
    throw JsonException(e)
}

fun <T> deserializeFromJson(json: String?, type: Class<T>?): T = try {
    objectMapper.readValue(json, objectMapper.typeFactory.constructType(type))
} catch (e: IOException) {
    throw JsonException(e)
}

fun <T> deserializeFromObject(`object`: Any?, type: Class<T>?): T = try {
    val json = objectToJson(`object`)
    objectMapper.readValue(json, objectMapper.typeFactory.constructType(type))
} catch (e: IOException) {
    throw JsonException(e)
}

fun <T> deserializeFromObjectList(input: List<Any?>?, type: Class<T>?): List<T> {
    val content: MutableList<T> = ArrayList()
    input?.stream()?.forEach { item: Any? -> content.add(deserializeFromObject(item, type)) }
    return content
}

fun nodeFromJson(json: String?): JsonNode = try {
    objectMapper.readTree(json)
} catch (e: IOException) {
    throw JsonException(e)
}

fun nodeFromObject(obj: Any?): JsonNode = try {
    objectMapper.readTree(objectToJson(obj))
} catch (e: IOException) {
    throw JsonException(e)
}

===== ./common/common-kotlin/common-api/common-api-json/src/main/kotlin/net/blugrid/api/json/exception/JsonException.kt =====
package net.blugrid.api.json.exception

class JsonException(ex: Exception) : RuntimeException(ex)

===== ./common/common-kotlin/common-api/common-api-json/src/main/kotlin/net/blugrid/api/json/JsonPath.kt =====
package net.blugrid.api.json

import com.nfeld.jsonpathkt.JsonPath
import com.nfeld.jsonpathkt.extension.read

inline fun <reified T : Any> String.readAs(path: String): T? =
    JsonPath.parse(this)?.read(path)

fun String.read(path: String): String? =
    JsonPath.parse(this)?.read(path)

===== ./common/common-kotlin/common-api/common-api-json/src/main/resources/application-json.yml =====
jackson:
  serialization:
    write-bigdecimal-as-plain: true
    write-date-timestamps-as-nanoseconds: false
    write-dates-as-timestamps: false
    write-enums-using-to-string: true
    write_numbers_as_strings: true

  deserialization:
    read-date-timestamps-as-nanoseconds: false
    read-enums-using-to-string: true

===== ./common/common-kotlin/common-api/common-api-json/src/test/kotlin/net/blugrid/api/json/DeserialisationTests.kt =====
package net.blugrid.api.json

import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.databind.exc.MismatchedInputException
import io.micronaut.test.extensions.junit5.annotation.MicronautTest
import org.junit.jupiter.api.Assertions
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.assertThrows
import java.math.BigDecimal

@MicronautTest
class SerdeTests {

    val ServiceEntryJson = "{\n" +
        "      \"ID\": \"rest-api:8080\",\n" +
        "      \"Service\": \"rest-api\",\n" +
        "      \"Tags\": [],\n" +
        "      \"Address\": \"fedora\",\n" +
        "      \"Meta\": null,\n" +
        "      \"Port\": 8080,\n" +
        "      \"Weights\": {\n" +
        "        \"Passing\": 1,\n" +
        "        \"Warning\": 1\n" +
        "      },\n" +
        "      \"EnableTagOverride\": false,\n" +
        "      \"Proxy\": {\n" +
        "        \"MeshGateway\": {},\n" +
        "        \"Expose\": {}\n" +
        "      },\n" +
        "      \"Connect\": {},\n" +
        "      \"CreateIndex\": 177,\n" +
        "      \"ModifyIndex\": 177\n" +
        "    }"

    data class testSalesReportPeriod(
        val qty: BigDecimal = BigDecimal.ZERO,
        val reportPeriodId: Long
    )

    data class testSalesOptionalReportPeriod(
        val qty: BigDecimal = BigDecimal.ZERO,
        val reportPeriodId: Long? = null
    )

//    @Test
//    fun `Test Consul Service Entry`(objectMapper: ObjectMapper) {
//        val consulServiceEntry = objectMapper.readValue(ServiceEntryJson, ServiceEntry::class.java)
//        Assertions.assertNotNull(consulServiceEntry)
//    }

    @Test
    fun `Test Sales Entry`(objectMapper: ObjectMapper) {
        assertThrows<MismatchedInputException> { objectMapper.readValue("{\"qty\":2}", testSalesReportPeriod::class.java) }
    }

    @Test
    fun `Test Sales Optional Entry`(objectMapper: ObjectMapper) {
        val testSalesReportPeriod = objectMapper.readValue("{\"qty\":2}", testSalesOptionalReportPeriod::class.java)
        Assertions.assertNotNull(testSalesReportPeriod)
        Assertions.assertNull(testSalesReportPeriod.reportPeriodId)
    }
}

===== ./common/common-kotlin/common-api/common-api-json/build.gradle.kts =====
plugins {
    alias(libs.plugins.jvm)
    alias(libs.plugins.kapt)
    alias(libs.plugins.allopen)
    alias(libs.plugins.application)
}

dependencies {
    // API dependencies - expose to consumers
    api(project(":common:common-kotlin:common-api:common-api-model"))

    // Platform BOM
    implementation(platform(libs.micronaut.bom))

    // Core dependencies using new bundles
    implementation(libs.bundles.kotlinCore)
    implementation(libs.bundles.micronautCore)
    implementation(libs.bundles.jsonLibs)  // Complete JSON stack including JSONPat
    implementation(libs.micronaut.serde)
    implementation(libs.micronaut.validation)

    // Annotation processing
    kapt(libs.micronaut.inject.java)
    kapt(libs.micronaut.serde.processor)
    kapt(libs.micronaut.openapi)
    kapt(libs.mapstruct.processor)

    // Compile-only dependencies
    compileOnly(libs.bundles.compileOnly)

    // Runtime dependencies
    runtimeOnly(libs.bundles.runtimeCore)

    // Test dependencies
    testImplementation(libs.bundles.testing) {
        exclude(group = "org.slf4j", module = "slf4j-api")
    }
}

java {
    sourceCompatibility = JavaVersion.toVersion("17")
}

kapt {
    arguments {
        arg("micronaut.openapi.project.dir", projectDir.toString())
    }
}

graalvmNative.toolchainDetection = false
micronaut {
    runtime("netty")
    testRuntime("junit5")
    processing {
        incremental(true)
        annotations("net.blugrid.api.*")
    }
}

===== ./common/common-kotlin/common-api/common-api-json/gradle.properties =====
micronautVersion=4.4.3
kotlinVersion=1.9.23

